{"ast":null,"code":"import { isFunction, isArray, isNumber, bind, assign } from 'min-dash';\nvar FN_REF = '__fn';\nvar DEFAULT_PRIORITY = 1000;\nvar slice = Array.prototype.slice;\n\n/**\r\n * A general purpose event bus.\r\n *\r\n * This component is used to communicate across a diagram instance.\r\n * Other parts of a diagram can use it to listen to and broadcast events.\r\n *\r\n *\r\n * ## Registering for Events\r\n *\r\n * The event bus provides the {@link EventBus#on} and {@link EventBus#once}\r\n * methods to register for events. {@link EventBus#off} can be used to\r\n * remove event registrations. Listeners receive an instance of {@link Event}\r\n * as the first argument. It allows them to hook into the event execution.\r\n *\r\n * ```javascript\r\n *\r\n * // listen for event\r\n * eventBus.on('foo', function(event) {\r\n *\r\n *   // access event type\r\n *   event.type; // 'foo'\r\n *\r\n *   // stop propagation to other listeners\r\n *   event.stopPropagation();\r\n *\r\n *   // prevent event default\r\n *   event.preventDefault();\r\n * });\r\n *\r\n * // listen for event with custom payload\r\n * eventBus.on('bar', function(event, payload) {\r\n *   console.log(payload);\r\n * });\r\n *\r\n * // listen for event returning value\r\n * eventBus.on('foobar', function(event) {\r\n *\r\n *   // stop event propagation + prevent default\r\n *   return false;\r\n *\r\n *   // stop event propagation + return custom result\r\n *   return {\r\n *     complex: 'listening result'\r\n *   };\r\n * });\r\n *\r\n *\r\n * // listen with custom priority (default=1000, higher is better)\r\n * eventBus.on('priorityfoo', 1500, function(event) {\r\n *   console.log('invoked first!');\r\n * });\r\n *\r\n *\r\n * // listen for event and pass the context (`this`)\r\n * eventBus.on('foobar', function(event) {\r\n *   this.foo();\r\n * }, this);\r\n * ```\r\n *\r\n *\r\n * ## Emitting Events\r\n *\r\n * Events can be emitted via the event bus using {@link EventBus#fire}.\r\n *\r\n * ```javascript\r\n *\r\n * // false indicates that the default action\r\n * // was prevented by listeners\r\n * if (eventBus.fire('foo') === false) {\r\n *   console.log('default has been prevented!');\r\n * };\r\n *\r\n *\r\n * // custom args + return value listener\r\n * eventBus.on('sum', function(event, a, b) {\r\n *   return a + b;\r\n * });\r\n *\r\n * // you can pass custom arguments + retrieve result values.\r\n * var sum = eventBus.fire('sum', 1, 2);\r\n * console.log(sum); // 3\r\n * ```\r\n */\nexport default function EventBus() {\n  this._listeners = {};\n\n  // cleanup on destroy on lowest priority to allow\n  // message passing until the bitter end\n  this.on('diagram.destroy', 1, this._destroy, this);\n}\n\n/**\r\n * Register an event listener for events with the given name.\r\n *\r\n * The callback will be invoked with `event, ...additionalArguments`\r\n * that have been passed to {@link EventBus#fire}.\r\n *\r\n * Returning false from a listener will prevent the events default action\r\n * (if any is specified). To stop an event from being processed further in\r\n * other listeners execute {@link Event#stopPropagation}.\r\n *\r\n * Returning anything but `undefined` from a listener will stop the listener propagation.\r\n *\r\n * @param {string|Array<string>} events\r\n * @param {number} [priority=1000] the priority in which this listener is called, larger is higher\r\n * @param {Function} callback\r\n * @param {Object} [that] Pass context (`this`) to the callback\r\n */\nEventBus.prototype.on = function (events, priority, callback, that) {\n  events = isArray(events) ? events : [events];\n  if (isFunction(priority)) {\n    that = callback;\n    callback = priority;\n    priority = DEFAULT_PRIORITY;\n  }\n  if (!isNumber(priority)) {\n    throw new Error('priority must be a number');\n  }\n  var actualCallback = callback;\n  if (that) {\n    actualCallback = bind(callback, that);\n\n    // make sure we remember and are able to remove\n    // bound callbacks via {@link #off} using the original\n    // callback\n    actualCallback[FN_REF] = callback[FN_REF] || callback;\n  }\n  var self = this;\n  events.forEach(function (e) {\n    self._addListener(e, {\n      priority: priority,\n      callback: actualCallback,\n      next: null\n    });\n  });\n};\n\n/**\r\n * Register an event listener that is executed only once.\r\n *\r\n * @param {string} event the event name to register for\r\n * @param {number} [priority=1000] the priority in which this listener is called, larger is higher\r\n * @param {Function} callback the callback to execute\r\n * @param {Object} [that] Pass context (`this`) to the callback\r\n */\nEventBus.prototype.once = function (event, priority, callback, that) {\n  var self = this;\n  if (isFunction(priority)) {\n    that = callback;\n    callback = priority;\n    priority = DEFAULT_PRIORITY;\n  }\n  if (!isNumber(priority)) {\n    throw new Error('priority must be a number');\n  }\n  function wrappedCallback() {\n    wrappedCallback.__isTomb = true;\n    var result = callback.apply(that, arguments);\n    self.off(event, wrappedCallback);\n    return result;\n  }\n\n  // make sure we remember and are able to remove\n  // bound callbacks via {@link #off} using the original\n  // callback\n  wrappedCallback[FN_REF] = callback;\n  this.on(event, priority, wrappedCallback);\n};\n\n/**\r\n * Removes event listeners by event and callback.\r\n *\r\n * If no callback is given, all listeners for a given event name are being removed.\r\n *\r\n * @param {string|Array<string>} events\r\n * @param {Function} [callback]\r\n */\nEventBus.prototype.off = function (events, callback) {\n  events = isArray(events) ? events : [events];\n  var self = this;\n  events.forEach(function (event) {\n    self._removeListener(event, callback);\n  });\n};\n\n/**\r\n * Create an EventBus event.\r\n *\r\n * @param {Object} data\r\n *\r\n * @return {Object} event, recognized by the eventBus\r\n */\nEventBus.prototype.createEvent = function (data) {\n  var event = new InternalEvent();\n  event.init(data);\n  return event;\n};\n\n/**\r\n * Fires a named event.\r\n *\r\n * @example\r\n *\r\n * // fire event by name\r\n * events.fire('foo');\r\n *\r\n * // fire event object with nested type\r\n * var event = { type: 'foo' };\r\n * events.fire(event);\r\n *\r\n * // fire event with explicit type\r\n * var event = { x: 10, y: 20 };\r\n * events.fire('element.moved', event);\r\n *\r\n * // pass additional arguments to the event\r\n * events.on('foo', function(event, bar) {\r\n *   alert(bar);\r\n * });\r\n *\r\n * events.fire({ type: 'foo' }, 'I am bar!');\r\n *\r\n * @param {string} [name] the optional event name\r\n * @param {Object} [event] the event object\r\n * @param {...Object} additional arguments to be passed to the callback functions\r\n *\r\n * @return {boolean} the events return value, if specified or false if the\r\n *                   default action was prevented by listeners\r\n */\nEventBus.prototype.fire = function (type, data) {\n  var event, firstListener, returnValue, args;\n  args = slice.call(arguments);\n  if (typeof type === 'object') {\n    data = type;\n    type = data.type;\n  }\n  if (!type) {\n    throw new Error('no event type specified');\n  }\n  firstListener = this._listeners[type];\n  if (!firstListener) {\n    return;\n  }\n\n  // we make sure we fire instances of our home made\n  // events here. We wrap them only once, though\n  if (data instanceof InternalEvent) {\n    // we are fine, we alread have an event\n    event = data;\n  } else {\n    event = this.createEvent(data);\n  }\n\n  // ensure we pass the event as the first parameter\n  args[0] = event;\n\n  // original event type (in case we delegate)\n  var originalType = event.type;\n\n  // update event type before delegation\n  if (type !== originalType) {\n    event.type = type;\n  }\n  try {\n    returnValue = this._invokeListeners(event, args, firstListener);\n  } finally {\n    // reset event type after delegation\n    if (type !== originalType) {\n      event.type = originalType;\n    }\n  }\n\n  // set the return value to false if the event default\n  // got prevented and no other return value exists\n  if (returnValue === undefined && event.defaultPrevented) {\n    returnValue = false;\n  }\n  return returnValue;\n};\nEventBus.prototype.handleError = function (error) {\n  return this.fire('error', {\n    error: error\n  }) === false;\n};\nEventBus.prototype._destroy = function () {\n  this._listeners = {};\n};\nEventBus.prototype._invokeListeners = function (event, args, listener) {\n  var returnValue;\n  while (listener) {\n    // handle stopped propagation\n    if (event.cancelBubble) {\n      break;\n    }\n    returnValue = this._invokeListener(event, args, listener);\n    listener = listener.next;\n  }\n  return returnValue;\n};\nEventBus.prototype._invokeListener = function (event, args, listener) {\n  var returnValue;\n  if (listener.callback.__isTomb) {\n    return returnValue;\n  }\n  try {\n    // returning false prevents the default action\n    returnValue = invokeFunction(listener.callback, args);\n\n    // stop propagation on return value\n    if (returnValue !== undefined) {\n      event.returnValue = returnValue;\n      event.stopPropagation();\n    }\n\n    // prevent default on return false\n    if (returnValue === false) {\n      event.preventDefault();\n    }\n  } catch (error) {\n    if (!this.handleError(error)) {\n      console.error('unhandled error in event listener', error);\n      throw error;\n    }\n  }\n  return returnValue;\n};\n\n/*\r\n * Add new listener with a certain priority to the list\r\n * of listeners (for the given event).\r\n *\r\n * The semantics of listener registration / listener execution are\r\n * first register, first serve: New listeners will always be inserted\r\n * after existing listeners with the same priority.\r\n *\r\n * Example: Inserting two listeners with priority 1000 and 1300\r\n *\r\n *    * before: [ 1500, 1500, 1000, 1000 ]\r\n *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]\r\n *\r\n * @param {string} event\r\n * @param {Object} listener { priority, callback }\r\n */\nEventBus.prototype._addListener = function (event, newListener) {\n  var listener = this._getListeners(event),\n    previousListener;\n\n  // no prior listeners\n  if (!listener) {\n    this._setListeners(event, newListener);\n    return;\n  }\n\n  // ensure we order listeners by priority from\n  // 0 (high) to n > 0 (low)\n  while (listener) {\n    if (listener.priority < newListener.priority) {\n      newListener.next = listener;\n      if (previousListener) {\n        previousListener.next = newListener;\n      } else {\n        this._setListeners(event, newListener);\n      }\n      return;\n    }\n    previousListener = listener;\n    listener = listener.next;\n  }\n\n  // add new listener to back\n  previousListener.next = newListener;\n};\nEventBus.prototype._getListeners = function (name) {\n  return this._listeners[name];\n};\nEventBus.prototype._setListeners = function (name, listener) {\n  this._listeners[name] = listener;\n};\nEventBus.prototype._removeListener = function (event, callback) {\n  var listener = this._getListeners(event),\n    nextListener,\n    previousListener,\n    listenerCallback;\n  if (!callback) {\n    // clear listeners\n    this._setListeners(event, null);\n    return;\n  }\n  while (listener) {\n    nextListener = listener.next;\n    listenerCallback = listener.callback;\n    if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {\n      if (previousListener) {\n        previousListener.next = nextListener;\n      } else {\n        // new first listener\n        this._setListeners(event, nextListener);\n      }\n    }\n    previousListener = listener;\n    listener = nextListener;\n  }\n};\n\n/**\r\n * A event that is emitted via the event bus.\r\n */\nfunction InternalEvent() {}\nInternalEvent.prototype.stopPropagation = function () {\n  this.cancelBubble = true;\n};\nInternalEvent.prototype.preventDefault = function () {\n  this.defaultPrevented = true;\n};\nInternalEvent.prototype.init = function (data) {\n  assign(this, data || {});\n};\n\n/**\r\n * Invoke function. Be fast...\r\n *\r\n * @param {Function} fn\r\n * @param {Array<Object>} args\r\n *\r\n * @return {Any}\r\n */\nfunction invokeFunction(fn, args) {\n  return fn.apply(null, args);\n}","map":{"version":3,"names":["isFunction","isArray","isNumber","bind","assign","FN_REF","DEFAULT_PRIORITY","slice","Array","prototype","EventBus","_listeners","on","_destroy","events","priority","callback","that","Error","actualCallback","self","forEach","e","_addListener","next","once","event","wrappedCallback","__isTomb","result","apply","arguments","off","_removeListener","createEvent","data","InternalEvent","init","fire","type","firstListener","returnValue","args","call","originalType","_invokeListeners","undefined","defaultPrevented","handleError","error","listener","cancelBubble","_invokeListener","invokeFunction","stopPropagation","preventDefault","console","newListener","_getListeners","previousListener","_setListeners","name","nextListener","listenerCallback","fn"],"sources":["C:/Users/sam/final/camunda-react/node_modules/diagram-js/lib/core/EventBus.js"],"sourcesContent":["import {\r\n  isFunction,\r\n  isArray,\r\n  isNumber,\r\n  bind,\r\n  assign\r\n} from 'min-dash';\r\n\r\nvar FN_REF = '__fn';\r\n\r\nvar DEFAULT_PRIORITY = 1000;\r\n\r\nvar slice = Array.prototype.slice;\r\n\r\n/**\r\n * A general purpose event bus.\r\n *\r\n * This component is used to communicate across a diagram instance.\r\n * Other parts of a diagram can use it to listen to and broadcast events.\r\n *\r\n *\r\n * ## Registering for Events\r\n *\r\n * The event bus provides the {@link EventBus#on} and {@link EventBus#once}\r\n * methods to register for events. {@link EventBus#off} can be used to\r\n * remove event registrations. Listeners receive an instance of {@link Event}\r\n * as the first argument. It allows them to hook into the event execution.\r\n *\r\n * ```javascript\r\n *\r\n * // listen for event\r\n * eventBus.on('foo', function(event) {\r\n *\r\n *   // access event type\r\n *   event.type; // 'foo'\r\n *\r\n *   // stop propagation to other listeners\r\n *   event.stopPropagation();\r\n *\r\n *   // prevent event default\r\n *   event.preventDefault();\r\n * });\r\n *\r\n * // listen for event with custom payload\r\n * eventBus.on('bar', function(event, payload) {\r\n *   console.log(payload);\r\n * });\r\n *\r\n * // listen for event returning value\r\n * eventBus.on('foobar', function(event) {\r\n *\r\n *   // stop event propagation + prevent default\r\n *   return false;\r\n *\r\n *   // stop event propagation + return custom result\r\n *   return {\r\n *     complex: 'listening result'\r\n *   };\r\n * });\r\n *\r\n *\r\n * // listen with custom priority (default=1000, higher is better)\r\n * eventBus.on('priorityfoo', 1500, function(event) {\r\n *   console.log('invoked first!');\r\n * });\r\n *\r\n *\r\n * // listen for event and pass the context (`this`)\r\n * eventBus.on('foobar', function(event) {\r\n *   this.foo();\r\n * }, this);\r\n * ```\r\n *\r\n *\r\n * ## Emitting Events\r\n *\r\n * Events can be emitted via the event bus using {@link EventBus#fire}.\r\n *\r\n * ```javascript\r\n *\r\n * // false indicates that the default action\r\n * // was prevented by listeners\r\n * if (eventBus.fire('foo') === false) {\r\n *   console.log('default has been prevented!');\r\n * };\r\n *\r\n *\r\n * // custom args + return value listener\r\n * eventBus.on('sum', function(event, a, b) {\r\n *   return a + b;\r\n * });\r\n *\r\n * // you can pass custom arguments + retrieve result values.\r\n * var sum = eventBus.fire('sum', 1, 2);\r\n * console.log(sum); // 3\r\n * ```\r\n */\r\nexport default function EventBus() {\r\n  this._listeners = {};\r\n\r\n  // cleanup on destroy on lowest priority to allow\r\n  // message passing until the bitter end\r\n  this.on('diagram.destroy', 1, this._destroy, this);\r\n}\r\n\r\n\r\n/**\r\n * Register an event listener for events with the given name.\r\n *\r\n * The callback will be invoked with `event, ...additionalArguments`\r\n * that have been passed to {@link EventBus#fire}.\r\n *\r\n * Returning false from a listener will prevent the events default action\r\n * (if any is specified). To stop an event from being processed further in\r\n * other listeners execute {@link Event#stopPropagation}.\r\n *\r\n * Returning anything but `undefined` from a listener will stop the listener propagation.\r\n *\r\n * @param {string|Array<string>} events\r\n * @param {number} [priority=1000] the priority in which this listener is called, larger is higher\r\n * @param {Function} callback\r\n * @param {Object} [that] Pass context (`this`) to the callback\r\n */\r\nEventBus.prototype.on = function(events, priority, callback, that) {\r\n\r\n  events = isArray(events) ? events : [ events ];\r\n\r\n  if (isFunction(priority)) {\r\n    that = callback;\r\n    callback = priority;\r\n    priority = DEFAULT_PRIORITY;\r\n  }\r\n\r\n  if (!isNumber(priority)) {\r\n    throw new Error('priority must be a number');\r\n  }\r\n\r\n  var actualCallback = callback;\r\n\r\n  if (that) {\r\n    actualCallback = bind(callback, that);\r\n\r\n    // make sure we remember and are able to remove\r\n    // bound callbacks via {@link #off} using the original\r\n    // callback\r\n    actualCallback[FN_REF] = callback[FN_REF] || callback;\r\n  }\r\n\r\n  var self = this;\r\n\r\n  events.forEach(function(e) {\r\n    self._addListener(e, {\r\n      priority: priority,\r\n      callback: actualCallback,\r\n      next: null\r\n    });\r\n  });\r\n};\r\n\r\n\r\n/**\r\n * Register an event listener that is executed only once.\r\n *\r\n * @param {string} event the event name to register for\r\n * @param {number} [priority=1000] the priority in which this listener is called, larger is higher\r\n * @param {Function} callback the callback to execute\r\n * @param {Object} [that] Pass context (`this`) to the callback\r\n */\r\nEventBus.prototype.once = function(event, priority, callback, that) {\r\n  var self = this;\r\n\r\n  if (isFunction(priority)) {\r\n    that = callback;\r\n    callback = priority;\r\n    priority = DEFAULT_PRIORITY;\r\n  }\r\n\r\n  if (!isNumber(priority)) {\r\n    throw new Error('priority must be a number');\r\n  }\r\n\r\n  function wrappedCallback() {\r\n    wrappedCallback.__isTomb = true;\r\n\r\n    var result = callback.apply(that, arguments);\r\n\r\n    self.off(event, wrappedCallback);\r\n\r\n    return result;\r\n  }\r\n\r\n  // make sure we remember and are able to remove\r\n  // bound callbacks via {@link #off} using the original\r\n  // callback\r\n  wrappedCallback[FN_REF] = callback;\r\n\r\n  this.on(event, priority, wrappedCallback);\r\n};\r\n\r\n\r\n/**\r\n * Removes event listeners by event and callback.\r\n *\r\n * If no callback is given, all listeners for a given event name are being removed.\r\n *\r\n * @param {string|Array<string>} events\r\n * @param {Function} [callback]\r\n */\r\nEventBus.prototype.off = function(events, callback) {\r\n\r\n  events = isArray(events) ? events : [ events ];\r\n\r\n  var self = this;\r\n\r\n  events.forEach(function(event) {\r\n    self._removeListener(event, callback);\r\n  });\r\n\r\n};\r\n\r\n\r\n/**\r\n * Create an EventBus event.\r\n *\r\n * @param {Object} data\r\n *\r\n * @return {Object} event, recognized by the eventBus\r\n */\r\nEventBus.prototype.createEvent = function(data) {\r\n  var event = new InternalEvent();\r\n\r\n  event.init(data);\r\n\r\n  return event;\r\n};\r\n\r\n\r\n/**\r\n * Fires a named event.\r\n *\r\n * @example\r\n *\r\n * // fire event by name\r\n * events.fire('foo');\r\n *\r\n * // fire event object with nested type\r\n * var event = { type: 'foo' };\r\n * events.fire(event);\r\n *\r\n * // fire event with explicit type\r\n * var event = { x: 10, y: 20 };\r\n * events.fire('element.moved', event);\r\n *\r\n * // pass additional arguments to the event\r\n * events.on('foo', function(event, bar) {\r\n *   alert(bar);\r\n * });\r\n *\r\n * events.fire({ type: 'foo' }, 'I am bar!');\r\n *\r\n * @param {string} [name] the optional event name\r\n * @param {Object} [event] the event object\r\n * @param {...Object} additional arguments to be passed to the callback functions\r\n *\r\n * @return {boolean} the events return value, if specified or false if the\r\n *                   default action was prevented by listeners\r\n */\r\nEventBus.prototype.fire = function(type, data) {\r\n  var event,\r\n      firstListener,\r\n      returnValue,\r\n      args;\r\n\r\n  args = slice.call(arguments);\r\n\r\n  if (typeof type === 'object') {\r\n    data = type;\r\n    type = data.type;\r\n  }\r\n\r\n  if (!type) {\r\n    throw new Error('no event type specified');\r\n  }\r\n\r\n  firstListener = this._listeners[type];\r\n\r\n  if (!firstListener) {\r\n    return;\r\n  }\r\n\r\n  // we make sure we fire instances of our home made\r\n  // events here. We wrap them only once, though\r\n  if (data instanceof InternalEvent) {\r\n\r\n    // we are fine, we alread have an event\r\n    event = data;\r\n  } else {\r\n    event = this.createEvent(data);\r\n  }\r\n\r\n  // ensure we pass the event as the first parameter\r\n  args[0] = event;\r\n\r\n  // original event type (in case we delegate)\r\n  var originalType = event.type;\r\n\r\n  // update event type before delegation\r\n  if (type !== originalType) {\r\n    event.type = type;\r\n  }\r\n\r\n  try {\r\n    returnValue = this._invokeListeners(event, args, firstListener);\r\n  } finally {\r\n\r\n    // reset event type after delegation\r\n    if (type !== originalType) {\r\n      event.type = originalType;\r\n    }\r\n  }\r\n\r\n  // set the return value to false if the event default\r\n  // got prevented and no other return value exists\r\n  if (returnValue === undefined && event.defaultPrevented) {\r\n    returnValue = false;\r\n  }\r\n\r\n  return returnValue;\r\n};\r\n\r\n\r\nEventBus.prototype.handleError = function(error) {\r\n  return this.fire('error', { error: error }) === false;\r\n};\r\n\r\n\r\nEventBus.prototype._destroy = function() {\r\n  this._listeners = {};\r\n};\r\n\r\nEventBus.prototype._invokeListeners = function(event, args, listener) {\r\n\r\n  var returnValue;\r\n\r\n  while (listener) {\r\n\r\n    // handle stopped propagation\r\n    if (event.cancelBubble) {\r\n      break;\r\n    }\r\n\r\n    returnValue = this._invokeListener(event, args, listener);\r\n\r\n    listener = listener.next;\r\n  }\r\n\r\n  return returnValue;\r\n};\r\n\r\nEventBus.prototype._invokeListener = function(event, args, listener) {\r\n\r\n  var returnValue;\r\n\r\n  if (listener.callback.__isTomb) {\r\n    return returnValue;\r\n  }\r\n\r\n  try {\r\n\r\n    // returning false prevents the default action\r\n    returnValue = invokeFunction(listener.callback, args);\r\n\r\n    // stop propagation on return value\r\n    if (returnValue !== undefined) {\r\n      event.returnValue = returnValue;\r\n      event.stopPropagation();\r\n    }\r\n\r\n    // prevent default on return false\r\n    if (returnValue === false) {\r\n      event.preventDefault();\r\n    }\r\n  } catch (error) {\r\n    if (!this.handleError(error)) {\r\n      console.error('unhandled error in event listener', error);\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  return returnValue;\r\n};\r\n\r\n/*\r\n * Add new listener with a certain priority to the list\r\n * of listeners (for the given event).\r\n *\r\n * The semantics of listener registration / listener execution are\r\n * first register, first serve: New listeners will always be inserted\r\n * after existing listeners with the same priority.\r\n *\r\n * Example: Inserting two listeners with priority 1000 and 1300\r\n *\r\n *    * before: [ 1500, 1500, 1000, 1000 ]\r\n *    * after: [ 1500, 1500, (new=1300), 1000, 1000, (new=1000) ]\r\n *\r\n * @param {string} event\r\n * @param {Object} listener { priority, callback }\r\n */\r\nEventBus.prototype._addListener = function(event, newListener) {\r\n\r\n  var listener = this._getListeners(event),\r\n      previousListener;\r\n\r\n  // no prior listeners\r\n  if (!listener) {\r\n    this._setListeners(event, newListener);\r\n\r\n    return;\r\n  }\r\n\r\n  // ensure we order listeners by priority from\r\n  // 0 (high) to n > 0 (low)\r\n  while (listener) {\r\n\r\n    if (listener.priority < newListener.priority) {\r\n\r\n      newListener.next = listener;\r\n\r\n      if (previousListener) {\r\n        previousListener.next = newListener;\r\n      } else {\r\n        this._setListeners(event, newListener);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    previousListener = listener;\r\n    listener = listener.next;\r\n  }\r\n\r\n  // add new listener to back\r\n  previousListener.next = newListener;\r\n};\r\n\r\n\r\nEventBus.prototype._getListeners = function(name) {\r\n  return this._listeners[name];\r\n};\r\n\r\nEventBus.prototype._setListeners = function(name, listener) {\r\n  this._listeners[name] = listener;\r\n};\r\n\r\nEventBus.prototype._removeListener = function(event, callback) {\r\n\r\n  var listener = this._getListeners(event),\r\n      nextListener,\r\n      previousListener,\r\n      listenerCallback;\r\n\r\n  if (!callback) {\r\n\r\n    // clear listeners\r\n    this._setListeners(event, null);\r\n\r\n    return;\r\n  }\r\n\r\n  while (listener) {\r\n\r\n    nextListener = listener.next;\r\n\r\n    listenerCallback = listener.callback;\r\n\r\n    if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {\r\n      if (previousListener) {\r\n        previousListener.next = nextListener;\r\n      } else {\r\n\r\n        // new first listener\r\n        this._setListeners(event, nextListener);\r\n      }\r\n    }\r\n\r\n    previousListener = listener;\r\n    listener = nextListener;\r\n  }\r\n};\r\n\r\n/**\r\n * A event that is emitted via the event bus.\r\n */\r\nfunction InternalEvent() { }\r\n\r\nInternalEvent.prototype.stopPropagation = function() {\r\n  this.cancelBubble = true;\r\n};\r\n\r\nInternalEvent.prototype.preventDefault = function() {\r\n  this.defaultPrevented = true;\r\n};\r\n\r\nInternalEvent.prototype.init = function(data) {\r\n  assign(this, data || {});\r\n};\r\n\r\n\r\n/**\r\n * Invoke function. Be fast...\r\n *\r\n * @param {Function} fn\r\n * @param {Array<Object>} args\r\n *\r\n * @return {Any}\r\n */\r\nfunction invokeFunction(fn, args) {\r\n  return fn.apply(null, args);\r\n}\r\n"],"mappings":"AAAA,SACEA,UAAU,EACVC,OAAO,EACPC,QAAQ,EACRC,IAAI,EACJC,MAAM,QACD,UAAU;AAEjB,IAAIC,MAAM,GAAG,MAAM;AAEnB,IAAIC,gBAAgB,GAAG,IAAI;AAE3B,IAAIC,KAAK,GAAGC,KAAK,CAACC,SAAS,CAACF,KAAK;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASG,QAAQA,CAAA,EAAG;EACjC,IAAI,CAACC,UAAU,GAAG,CAAC,CAAC;;EAEpB;EACA;EACA,IAAI,CAACC,EAAE,CAAC,iBAAiB,EAAE,CAAC,EAAE,IAAI,CAACC,QAAQ,EAAE,IAAI,CAAC;AACpD;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAH,QAAQ,CAACD,SAAS,CAACG,EAAE,GAAG,UAASE,MAAM,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,IAAI,EAAE;EAEjEH,MAAM,GAAGb,OAAO,CAACa,MAAM,CAAC,GAAGA,MAAM,GAAG,CAAEA,MAAM,CAAE;EAE9C,IAAId,UAAU,CAACe,QAAQ,CAAC,EAAE;IACxBE,IAAI,GAAGD,QAAQ;IACfA,QAAQ,GAAGD,QAAQ;IACnBA,QAAQ,GAAGT,gBAAgB;EAC7B;EAEA,IAAI,CAACJ,QAAQ,CAACa,QAAQ,CAAC,EAAE;IACvB,MAAM,IAAIG,KAAK,CAAC,2BAA2B,CAAC;EA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"},"metadata":{},"sourceType":"module"}