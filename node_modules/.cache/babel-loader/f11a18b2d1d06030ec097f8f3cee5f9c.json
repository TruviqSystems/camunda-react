{"ast":null,"code":"import { assign } from 'min-dash';\nimport { is } from '../util/ModelUtil';\nimport { isLabelExternal, getExternalLabelBounds } from '../util/LabelUtil';\nimport { getMid } from 'diagram-js/lib/layout/LayoutUtil';\nimport { isExpanded } from '../util/DiUtil';\nimport { getLabel } from '../features/label-editing/LabelUtil';\nimport { elementToString } from './Util';\nfunction elementData(semantic, attrs) {\n  return assign({\n    id: semantic.id,\n    type: semantic.$type,\n    businessObject: semantic\n  }, attrs);\n}\nfunction getWaypoints(bo, source, target) {\n  var waypoints = bo.di.waypoint;\n  if (!waypoints || waypoints.length < 2) {\n    return [getMid(source), getMid(target)];\n  }\n  return waypoints.map(function (p) {\n    return {\n      x: p.x,\n      y: p.y\n    };\n  });\n}\nfunction notYetDrawn(translate, semantic, refSemantic, property) {\n  return new Error(translate('element {element} referenced by {referenced}#{property} not yet drawn', {\n    element: elementToString(refSemantic),\n    referenced: elementToString(semantic),\n    property: property\n  }));\n}\n\n/**\r\n * An importer that adds bpmn elements to the canvas\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Canvas} canvas\r\n * @param {ElementFactory} elementFactory\r\n * @param {ElementRegistry} elementRegistry\r\n * @param {Function} translate\r\n * @param {TextRenderer} textRenderer\r\n */\nexport default function BpmnImporter(eventBus, canvas, elementFactory, elementRegistry, translate, textRenderer) {\n  this._eventBus = eventBus;\n  this._canvas = canvas;\n  this._elementFactory = elementFactory;\n  this._elementRegistry = elementRegistry;\n  this._translate = translate;\n  this._textRenderer = textRenderer;\n}\nBpmnImporter.$inject = ['eventBus', 'canvas', 'elementFactory', 'elementRegistry', 'translate', 'textRenderer'];\n\n/**\r\n * Add bpmn element (semantic) to the canvas onto the\r\n * specified parent shape.\r\n */\nBpmnImporter.prototype.add = function (semantic, parentElement) {\n  var di = semantic.di,\n    element,\n    translate = this._translate,\n    hidden;\n  var parentIndex;\n\n  // ROOT ELEMENT\n  // handle the special case that we deal with a\n  // invisible root element (process or collaboration)\n  if (is(di, 'bpmndi:BPMNPlane')) {\n    // add a virtual element (not being drawn)\n    element = this._elementFactory.createRoot(elementData(semantic));\n    this._canvas.setRootElement(element);\n  }\n\n  // SHAPE\n  else if (is(di, 'bpmndi:BPMNShape')) {\n    var collapsed = !isExpanded(semantic),\n      isFrame = isFrameElement(semantic);\n    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);\n    var bounds = semantic.di.bounds;\n    element = this._elementFactory.createShape(elementData(semantic, {\n      collapsed: collapsed,\n      hidden: hidden,\n      x: Math.round(bounds.x),\n      y: Math.round(bounds.y),\n      width: Math.round(bounds.width),\n      height: Math.round(bounds.height),\n      isFrame: isFrame\n    }));\n    if (is(semantic, 'bpmn:BoundaryEvent')) {\n      this._attachBoundary(semantic, element);\n    }\n\n    // insert lanes behind other flow nodes (cf. #727)\n    if (is(semantic, 'bpmn:Lane')) {\n      parentIndex = 0;\n    }\n    if (is(semantic, 'bpmn:DataStoreReference')) {\n      // check whether data store is inside our outside of its semantic parent\n      if (!isPointInsideBBox(parentElement, getMid(bounds))) {\n        parentElement = this._canvas.getRootElement();\n      }\n    }\n    this._canvas.addShape(element, parentElement, parentIndex);\n  }\n\n  // CONNECTION\n  else if (is(di, 'bpmndi:BPMNEdge')) {\n    var source = this._getSource(semantic),\n      target = this._getTarget(semantic);\n    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);\n    element = this._elementFactory.createConnection(elementData(semantic, {\n      hidden: hidden,\n      source: source,\n      target: target,\n      waypoints: getWaypoints(semantic, source, target)\n    }));\n    if (is(semantic, 'bpmn:DataAssociation')) {\n      // render always on top; this ensures DataAssociations\n      // are rendered correctly across different \"hacks\" people\n      // love to model such as cross participant / sub process\n      // associations\n      parentElement = null;\n    }\n\n    // insert sequence flows behind other flow nodes (cf. #727)\n    if (is(semantic, 'bpmn:SequenceFlow')) {\n      parentIndex = 0;\n    }\n    this._canvas.addConnection(element, parentElement, parentIndex);\n  } else {\n    throw new Error(translate('unknown di {di} for element {semantic}', {\n      di: elementToString(di),\n      semantic: elementToString(semantic)\n    }));\n  }\n\n  // (optional) LABEL\n  if (isLabelExternal(semantic) && getLabel(element)) {\n    this.addLabel(semantic, element);\n  }\n  this._eventBus.fire('bpmnElement.added', {\n    element: element\n  });\n  return element;\n};\n\n/**\r\n * Attach the boundary element to the given host\r\n *\r\n * @param {ModdleElement} boundarySemantic\r\n * @param {djs.model.Base} boundaryElement\r\n */\nBpmnImporter.prototype._attachBoundary = function (boundarySemantic, boundaryElement) {\n  var translate = this._translate;\n  var hostSemantic = boundarySemantic.attachedToRef;\n  if (!hostSemantic) {\n    throw new Error(translate('missing {semantic}#attachedToRef', {\n      semantic: elementToString(boundarySemantic)\n    }));\n  }\n  var host = this._elementRegistry.get(hostSemantic.id),\n    attachers = host && host.attachers;\n  if (!host) {\n    throw notYetDrawn(translate, boundarySemantic, hostSemantic, 'attachedToRef');\n  }\n\n  // wire element.host <> host.attachers\n  boundaryElement.host = host;\n  if (!attachers) {\n    host.attachers = attachers = [];\n  }\n  if (attachers.indexOf(boundaryElement) === -1) {\n    attachers.push(boundaryElement);\n  }\n};\n\n/**\r\n * add label for an element\r\n */\nBpmnImporter.prototype.addLabel = function (semantic, element) {\n  var bounds, text, label;\n  bounds = getExternalLabelBounds(semantic, element);\n  text = getLabel(element);\n  if (text) {\n    // get corrected bounds from actual layouted text\n    bounds = this._textRenderer.getExternalLabelBounds(bounds, text);\n  }\n  label = this._elementFactory.createLabel(elementData(semantic, {\n    id: semantic.id + '_label',\n    labelTarget: element,\n    type: 'label',\n    hidden: element.hidden || !getLabel(element),\n    x: Math.round(bounds.x),\n    y: Math.round(bounds.y),\n    width: Math.round(bounds.width),\n    height: Math.round(bounds.height)\n  }));\n  return this._canvas.addShape(label, element.parent);\n};\n\n/**\r\n * Return the drawn connection end based on the given side.\r\n *\r\n * @throws {Error} if the end is not yet drawn\r\n */\nBpmnImporter.prototype._getEnd = function (semantic, side) {\n  var element,\n    refSemantic,\n    type = semantic.$type,\n    translate = this._translate;\n  refSemantic = semantic[side + 'Ref'];\n\n  // handle mysterious isMany DataAssociation#sourceRef\n  if (side === 'source' && type === 'bpmn:DataInputAssociation') {\n    refSemantic = refSemantic && refSemantic[0];\n  }\n\n  // fix source / target for DataInputAssociation / DataOutputAssociation\n  if (side === 'source' && type === 'bpmn:DataOutputAssociation' || side === 'target' && type === 'bpmn:DataInputAssociation') {\n    refSemantic = semantic.$parent;\n  }\n  element = refSemantic && this._getElement(refSemantic);\n  if (element) {\n    return element;\n  }\n  if (refSemantic) {\n    throw notYetDrawn(translate, semantic, refSemantic, side + 'Ref');\n  } else {\n    throw new Error(translate('{semantic}#{side} Ref not specified', {\n      semantic: elementToString(semantic),\n      side: side\n    }));\n  }\n};\nBpmnImporter.prototype._getSource = function (semantic) {\n  return this._getEnd(semantic, 'source');\n};\nBpmnImporter.prototype._getTarget = function (semantic) {\n  return this._getEnd(semantic, 'target');\n};\nBpmnImporter.prototype._getElement = function (semantic) {\n  return this._elementRegistry.get(semantic.id);\n};\n\n// helpers ////////////////////\n\nfunction isPointInsideBBox(bbox, point) {\n  var x = point.x,\n    y = point.y;\n  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;\n}\nfunction isFrameElement(semantic) {\n  return is(semantic, 'bpmn:Group');\n}","map":{"version":3,"names":["assign","is","isLabelExternal","getExternalLabelBounds","getMid","isExpanded","getLabel","elementToString","elementData","semantic","attrs","id","type","$type","businessObject","getWaypoints","bo","source","target","waypoints","di","waypoint","length","map","p","x","y","notYetDrawn","translate","refSemantic","property","Error","element","referenced","BpmnImporter","eventBus","canvas","elementFactory","elementRegistry","textRenderer","_eventBus","_canvas","_elementFactory","_elementRegistry","_translate","_textRenderer","$inject","prototype","add","parentElement","hidden","parentIndex","createRoot","setRootElement","collapsed","isFrame","isFrameElement","bounds","createShape","Math","round","width","height","_attachBoundary","isPointInsideBBox","getRootElement","addShape","_getSource","_getTarget","createConnection","addConnection","addLabel","fire","boundarySemantic","boundaryElement","hostSemantic","attachedToRef","host","get","attachers","indexOf","push","text","label","createLabel","labelTarget","parent","_getEnd","side","$parent","_getElement","bbox","point"],"sources":["C:/Users/sam/final/camunda-react/node_modules/bpmn-js/lib/import/BpmnImporter.js"],"sourcesContent":["import {\r\n  assign\r\n} from 'min-dash';\r\n\r\nimport { is } from '../util/ModelUtil';\r\n\r\nimport {\r\n  isLabelExternal,\r\n  getExternalLabelBounds\r\n} from '../util/LabelUtil';\r\n\r\nimport {\r\n  getMid\r\n} from 'diagram-js/lib/layout/LayoutUtil';\r\n\r\nimport {\r\n  isExpanded\r\n} from '../util/DiUtil';\r\n\r\nimport {\r\n  getLabel\r\n} from '../features/label-editing/LabelUtil';\r\n\r\nimport {\r\n  elementToString\r\n} from './Util';\r\n\r\n\r\nfunction elementData(semantic, attrs) {\r\n  return assign({\r\n    id: semantic.id,\r\n    type: semantic.$type,\r\n    businessObject: semantic\r\n  }, attrs);\r\n}\r\n\r\nfunction getWaypoints(bo, source, target) {\r\n\r\n  var waypoints = bo.di.waypoint;\r\n\r\n  if (!waypoints || waypoints.length < 2) {\r\n    return [ getMid(source), getMid(target) ];\r\n  }\r\n\r\n  return waypoints.map(function(p) {\r\n    return { x: p.x, y: p.y };\r\n  });\r\n}\r\n\r\nfunction notYetDrawn(translate, semantic, refSemantic, property) {\r\n  return new Error(translate('element {element} referenced by {referenced}#{property} not yet drawn', {\r\n    element: elementToString(refSemantic),\r\n    referenced: elementToString(semantic),\r\n    property: property\r\n  }));\r\n}\r\n\r\n\r\n/**\r\n * An importer that adds bpmn elements to the canvas\r\n *\r\n * @param {EventBus} eventBus\r\n * @param {Canvas} canvas\r\n * @param {ElementFactory} elementFactory\r\n * @param {ElementRegistry} elementRegistry\r\n * @param {Function} translate\r\n * @param {TextRenderer} textRenderer\r\n */\r\nexport default function BpmnImporter(\r\n    eventBus, canvas, elementFactory,\r\n    elementRegistry, translate, textRenderer) {\r\n\r\n  this._eventBus = eventBus;\r\n  this._canvas = canvas;\r\n  this._elementFactory = elementFactory;\r\n  this._elementRegistry = elementRegistry;\r\n  this._translate = translate;\r\n  this._textRenderer = textRenderer;\r\n}\r\n\r\nBpmnImporter.$inject = [\r\n  'eventBus',\r\n  'canvas',\r\n  'elementFactory',\r\n  'elementRegistry',\r\n  'translate',\r\n  'textRenderer'\r\n];\r\n\r\n\r\n/**\r\n * Add bpmn element (semantic) to the canvas onto the\r\n * specified parent shape.\r\n */\r\nBpmnImporter.prototype.add = function(semantic, parentElement) {\r\n\r\n  var di = semantic.di,\r\n      element,\r\n      translate = this._translate,\r\n      hidden;\r\n\r\n  var parentIndex;\r\n\r\n  // ROOT ELEMENT\r\n  // handle the special case that we deal with a\r\n  // invisible root element (process or collaboration)\r\n  if (is(di, 'bpmndi:BPMNPlane')) {\r\n\r\n    // add a virtual element (not being drawn)\r\n    element = this._elementFactory.createRoot(elementData(semantic));\r\n\r\n    this._canvas.setRootElement(element);\r\n  }\r\n\r\n  // SHAPE\r\n  else if (is(di, 'bpmndi:BPMNShape')) {\r\n\r\n    var collapsed = !isExpanded(semantic),\r\n        isFrame = isFrameElement(semantic);\r\n    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);\r\n\r\n    var bounds = semantic.di.bounds;\r\n\r\n    element = this._elementFactory.createShape(elementData(semantic, {\r\n      collapsed: collapsed,\r\n      hidden: hidden,\r\n      x: Math.round(bounds.x),\r\n      y: Math.round(bounds.y),\r\n      width: Math.round(bounds.width),\r\n      height: Math.round(bounds.height),\r\n      isFrame: isFrame\r\n    }));\r\n\r\n    if (is(semantic, 'bpmn:BoundaryEvent')) {\r\n      this._attachBoundary(semantic, element);\r\n    }\r\n\r\n    // insert lanes behind other flow nodes (cf. #727)\r\n    if (is(semantic, 'bpmn:Lane')) {\r\n      parentIndex = 0;\r\n    }\r\n\r\n    if (is(semantic, 'bpmn:DataStoreReference')) {\r\n\r\n      // check whether data store is inside our outside of its semantic parent\r\n      if (!isPointInsideBBox(parentElement, getMid(bounds))) {\r\n        parentElement = this._canvas.getRootElement();\r\n      }\r\n    }\r\n\r\n    this._canvas.addShape(element, parentElement, parentIndex);\r\n  }\r\n\r\n  // CONNECTION\r\n  else if (is(di, 'bpmndi:BPMNEdge')) {\r\n\r\n    var source = this._getSource(semantic),\r\n        target = this._getTarget(semantic);\r\n\r\n    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);\r\n\r\n    element = this._elementFactory.createConnection(elementData(semantic, {\r\n      hidden: hidden,\r\n      source: source,\r\n      target: target,\r\n      waypoints: getWaypoints(semantic, source, target)\r\n    }));\r\n\r\n    if (is(semantic, 'bpmn:DataAssociation')) {\r\n\r\n      // render always on top; this ensures DataAssociations\r\n      // are rendered correctly across different \"hacks\" people\r\n      // love to model such as cross participant / sub process\r\n      // associations\r\n      parentElement = null;\r\n    }\r\n\r\n    // insert sequence flows behind other flow nodes (cf. #727)\r\n    if (is(semantic, 'bpmn:SequenceFlow')) {\r\n      parentIndex = 0;\r\n    }\r\n\r\n    this._canvas.addConnection(element, parentElement, parentIndex);\r\n  } else {\r\n    throw new Error(translate('unknown di {di} for element {semantic}', {\r\n      di: elementToString(di),\r\n      semantic: elementToString(semantic)\r\n    }));\r\n  }\r\n\r\n  // (optional) LABEL\r\n  if (isLabelExternal(semantic) && getLabel(element)) {\r\n    this.addLabel(semantic, element);\r\n  }\r\n\r\n\r\n  this._eventBus.fire('bpmnElement.added', { element: element });\r\n\r\n  return element;\r\n};\r\n\r\n\r\n/**\r\n * Attach the boundary element to the given host\r\n *\r\n * @param {ModdleElement} boundarySemantic\r\n * @param {djs.model.Base} boundaryElement\r\n */\r\nBpmnImporter.prototype._attachBoundary = function(boundarySemantic, boundaryElement) {\r\n  var translate = this._translate;\r\n  var hostSemantic = boundarySemantic.attachedToRef;\r\n\r\n  if (!hostSemantic) {\r\n    throw new Error(translate('missing {semantic}#attachedToRef', {\r\n      semantic: elementToString(boundarySemantic)\r\n    }));\r\n  }\r\n\r\n  var host = this._elementRegistry.get(hostSemantic.id),\r\n      attachers = host && host.attachers;\r\n\r\n  if (!host) {\r\n    throw notYetDrawn(translate, boundarySemantic, hostSemantic, 'attachedToRef');\r\n  }\r\n\r\n  // wire element.host <> host.attachers\r\n  boundaryElement.host = host;\r\n\r\n  if (!attachers) {\r\n    host.attachers = attachers = [];\r\n  }\r\n\r\n  if (attachers.indexOf(boundaryElement) === -1) {\r\n    attachers.push(boundaryElement);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * add label for an element\r\n */\r\nBpmnImporter.prototype.addLabel = function(semantic, element) {\r\n  var bounds,\r\n      text,\r\n      label;\r\n\r\n  bounds = getExternalLabelBounds(semantic, element);\r\n\r\n  text = getLabel(element);\r\n\r\n  if (text) {\r\n\r\n    // get corrected bounds from actual layouted text\r\n    bounds = this._textRenderer.getExternalLabelBounds(bounds, text);\r\n  }\r\n\r\n  label = this._elementFactory.createLabel(elementData(semantic, {\r\n    id: semantic.id + '_label',\r\n    labelTarget: element,\r\n    type: 'label',\r\n    hidden: element.hidden || !getLabel(element),\r\n    x: Math.round(bounds.x),\r\n    y: Math.round(bounds.y),\r\n    width: Math.round(bounds.width),\r\n    height: Math.round(bounds.height)\r\n  }));\r\n\r\n  return this._canvas.addShape(label, element.parent);\r\n};\r\n\r\n/**\r\n * Return the drawn connection end based on the given side.\r\n *\r\n * @throws {Error} if the end is not yet drawn\r\n */\r\nBpmnImporter.prototype._getEnd = function(semantic, side) {\r\n\r\n  var element,\r\n      refSemantic,\r\n      type = semantic.$type,\r\n      translate = this._translate;\r\n\r\n  refSemantic = semantic[side + 'Ref'];\r\n\r\n  // handle mysterious isMany DataAssociation#sourceRef\r\n  if (side === 'source' && type === 'bpmn:DataInputAssociation') {\r\n    refSemantic = refSemantic && refSemantic[0];\r\n  }\r\n\r\n  // fix source / target for DataInputAssociation / DataOutputAssociation\r\n  if (side === 'source' && type === 'bpmn:DataOutputAssociation' ||\r\n      side === 'target' && type === 'bpmn:DataInputAssociation') {\r\n\r\n    refSemantic = semantic.$parent;\r\n  }\r\n\r\n  element = refSemantic && this._getElement(refSemantic);\r\n\r\n  if (element) {\r\n    return element;\r\n  }\r\n\r\n  if (refSemantic) {\r\n    throw notYetDrawn(translate, semantic, refSemantic, side + 'Ref');\r\n  } else {\r\n    throw new Error(translate('{semantic}#{side} Ref not specified', {\r\n      semantic: elementToString(semantic),\r\n      side: side\r\n    }));\r\n  }\r\n};\r\n\r\nBpmnImporter.prototype._getSource = function(semantic) {\r\n  return this._getEnd(semantic, 'source');\r\n};\r\n\r\nBpmnImporter.prototype._getTarget = function(semantic) {\r\n  return this._getEnd(semantic, 'target');\r\n};\r\n\r\n\r\nBpmnImporter.prototype._getElement = function(semantic) {\r\n  return this._elementRegistry.get(semantic.id);\r\n};\r\n\r\n\r\n// helpers ////////////////////\r\n\r\nfunction isPointInsideBBox(bbox, point) {\r\n  var x = point.x,\r\n      y = point.y;\r\n\r\n  return x >= bbox.x &&\r\n    x <= bbox.x + bbox.width &&\r\n    y >= bbox.y &&\r\n    y <= bbox.y + bbox.height;\r\n}\r\n\r\nfunction isFrameElement(semantic) {\r\n  return is(semantic, 'bpmn:Group');\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}