{"ast":null,"code":"var fromCharCode = String.fromCharCode;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar ENTITY_PATTERN = /&#(\\d+);|&#x([0-9a-f]+);|&(\\w+);/ig;\nvar ENTITY_MAPPING = {\n  'amp': '&',\n  'apos': '\\'',\n  'gt': '>',\n  'lt': '<',\n  'quot': '\"'\n};\n\n// map UPPERCASE variants of supported special chars\nObject.keys(ENTITY_MAPPING).forEach(function (k) {\n  ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];\n});\nfunction replaceEntities(_, d, x, z) {\n  // reserved names, i.e. &nbsp;\n  if (z) {\n    if (hasOwnProperty.call(ENTITY_MAPPING, z)) {\n      return ENTITY_MAPPING[z];\n    } else {\n      // fall back to original value\n      return '&' + z + ';';\n    }\n  }\n\n  // decimal encoded char\n  if (d) {\n    return fromCharCode(d);\n  }\n\n  // hex encoded char\n  return fromCharCode(parseInt(x, 16));\n}\n\n/**\r\n * A basic entity decoder that can decode a minimal\r\n * sub-set of reserved names (&amp;) as well as\r\n * hex (&#xaaf;) and decimal (&#1231;) encoded characters.\r\n *\r\n * @param {string} str\r\n *\r\n * @return {string} decoded string\r\n */\nfunction decodeEntities(s) {\n  if (s.length > 3 && s.indexOf('&') !== -1) {\n    return s.replace(ENTITY_PATTERN, replaceEntities);\n  }\n  return s;\n}\nvar XSI_URI = 'http://www.w3.org/2001/XMLSchema-instance';\nvar XSI_PREFIX = 'xsi';\nvar XSI_TYPE = 'xsi:type';\nvar NON_WHITESPACE_OUTSIDE_ROOT_NODE = 'non-whitespace outside of root node';\nfunction error(msg) {\n  return new Error(msg);\n}\nfunction missingNamespaceForPrefix(prefix) {\n  return 'missing namespace for prefix <' + prefix + '>';\n}\nfunction getter(getFn) {\n  return {\n    'get': getFn,\n    'enumerable': true\n  };\n}\nfunction cloneNsMatrix(nsMatrix) {\n  var clone = {},\n    key;\n  for (key in nsMatrix) {\n    clone[key] = nsMatrix[key];\n  }\n  return clone;\n}\nfunction uriPrefix(prefix) {\n  return prefix + '$uri';\n}\nfunction buildNsMatrix(nsUriToPrefix) {\n  var nsMatrix = {},\n    uri,\n    prefix;\n  for (uri in nsUriToPrefix) {\n    prefix = nsUriToPrefix[uri];\n    nsMatrix[prefix] = prefix;\n    nsMatrix[uriPrefix(prefix)] = uri;\n  }\n  return nsMatrix;\n}\nfunction noopGetContext() {\n  return {\n    'line': 0,\n    'column': 0\n  };\n}\nfunction throwFunc(err) {\n  throw err;\n}\n\n/**\r\n * Creates a new parser with the given options.\r\n *\r\n * @constructor\r\n *\r\n * @param  {!Object<string, ?>=} options\r\n */\nfunction Parser(options) {\n  if (!this) {\n    return new Parser(options);\n  }\n  var proxy = options && options['proxy'];\n  var onText,\n    onOpenTag,\n    onCloseTag,\n    onCDATA,\n    onError = throwFunc,\n    onWarning,\n    onComment,\n    onQuestion,\n    onAttention;\n  var getContext = noopGetContext;\n\n  /**\r\n   * Do we need to parse the current elements attributes for namespaces?\r\n   *\r\n   * @type {boolean}\r\n   */\n  var maybeNS = false;\n\n  /**\r\n   * Do we process namespaces at all?\r\n   *\r\n   * @type {boolean}\r\n   */\n  var isNamespace = false;\n\n  /**\r\n   * The caught error returned on parse end\r\n   *\r\n   * @type {Error}\r\n   */\n  var returnError = null;\n\n  /**\r\n   * Should we stop parsing?\r\n   *\r\n   * @type {boolean}\r\n   */\n  var parseStop = false;\n\n  /**\r\n   * A map of { uri: prefix } used by the parser.\r\n   *\r\n   * This map will ensure we can normalize prefixes during processing;\r\n   * for each uri, only one prefix will be exposed to the handlers.\r\n   *\r\n   * @type {!Object<string, string>}}\r\n   */\n  var nsUriToPrefix;\n\n  /**\r\n   * Handle parse error.\r\n   *\r\n   * @param  {string|Error} err\r\n   */\n  function handleError(err) {\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n    returnError = err;\n    onError(err, getContext);\n  }\n\n  /**\r\n   * Handle parse error.\r\n   *\r\n   * @param  {string|Error} err\r\n   */\n  function handleWarning(err) {\n    if (!onWarning) {\n      return;\n    }\n    if (!(err instanceof Error)) {\n      err = error(err);\n    }\n    onWarning(err, getContext);\n  }\n\n  /**\r\n   * Register parse listener.\r\n   *\r\n   * @param  {string}   name\r\n   * @param  {Function} cb\r\n   *\r\n   * @return {Parser}\r\n   */\n  this['on'] = function (name, cb) {\n    if (typeof cb !== 'function') {\n      throw error('required args <name, cb>');\n    }\n    switch (name) {\n      case 'openTag':\n        onOpenTag = cb;\n        break;\n      case 'text':\n        onText = cb;\n        break;\n      case 'closeTag':\n        onCloseTag = cb;\n        break;\n      case 'error':\n        onError = cb;\n        break;\n      case 'warn':\n        onWarning = cb;\n        break;\n      case 'cdata':\n        onCDATA = cb;\n        break;\n      case 'attention':\n        onAttention = cb;\n        break;\n      // <!XXXXX zzzz=\"eeee\">\n      case 'question':\n        onQuestion = cb;\n        break;\n      // <? ....  ?>\n      case 'comment':\n        onComment = cb;\n        break;\n      default:\n        throw error('unsupported event: ' + name);\n    }\n    return this;\n  };\n\n  /**\r\n   * Set the namespace to prefix mapping.\r\n   *\r\n   * @example\r\n   *\r\n   * parser.ns({\r\n   *   'http://foo': 'foo',\r\n   *   'http://bar': 'bar'\r\n   * });\r\n   *\r\n   * @param  {!Object<string, string>} nsMap\r\n   *\r\n   * @return {Parser}\r\n   */\n  this['ns'] = function (nsMap) {\n    if (typeof nsMap === 'undefined') {\n      nsMap = {};\n    }\n    if (typeof nsMap !== 'object') {\n      throw error('required args <nsMap={}>');\n    }\n    var _nsUriToPrefix = {},\n      k;\n    for (k in nsMap) {\n      _nsUriToPrefix[k] = nsMap[k];\n    }\n\n    // FORCE default mapping for schema instance\n    _nsUriToPrefix[XSI_URI] = XSI_PREFIX;\n    isNamespace = true;\n    nsUriToPrefix = _nsUriToPrefix;\n    return this;\n  };\n\n  /**\r\n   * Parse xml string.\r\n   *\r\n   * @param  {string} xml\r\n   *\r\n   * @return {Error} returnError, if not thrown\r\n   */\n  this['parse'] = function (xml) {\n    if (typeof xml !== 'string') {\n      throw error('required args <xml=string>');\n    }\n    returnError = null;\n    parse(xml);\n    getContext = noopGetContext;\n    parseStop = false;\n    return returnError;\n  };\n\n  /**\r\n   * Stop parsing.\r\n   */\n  this['stop'] = function () {\n    parseStop = true;\n  };\n\n  /**\r\n   * Parse string, invoking configured listeners on element.\r\n   *\r\n   * @param  {string} xml\r\n   */\n  function parse(xml) {\n    var nsMatrixStack = isNamespace ? [] : null,\n      nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,\n      _nsMatrix,\n      nodeStack = [],\n      anonymousNsCount = 0,\n      tagStart = false,\n      tagEnd = false,\n      i = 0,\n      j = 0,\n      x,\n      y,\n      q,\n      w,\n      v,\n      xmlns,\n      elementName,\n      _elementName,\n      elementProxy;\n    var attrsString = '',\n      attrsStart = 0,\n      cachedAttrs // false = parsed with errors, null = needs parsing\n    ;\n\n    /**\r\n     * Parse attributes on demand and returns the parsed attributes.\r\n     *\r\n     * Return semantics: (1) `false` on attribute parse error,\r\n     * (2) object hash on extracted attrs.\r\n     *\r\n     * @return {boolean|Object}\r\n     */\n    function getAttrs() {\n      if (cachedAttrs !== null) {\n        return cachedAttrs;\n      }\n      var nsUri,\n        nsUriPrefix,\n        nsName,\n        defaultAlias = isNamespace && nsMatrix['xmlns'],\n        attrList = isNamespace && maybeNS ? [] : null,\n        i = attrsStart,\n        s = attrsString,\n        l = s.length,\n        hasNewMatrix,\n        newalias,\n        value,\n        alias,\n        name,\n        attrs = {},\n        seenAttrs = {},\n        skipAttr,\n        w,\n        j;\n      parseAttr: for (; i < l; i++) {\n        skipAttr = false;\n        w = s.charCodeAt(i);\n        if (w === 32 || w < 14 && w > 8) {\n          // WHITESPACE={ \\f\\n\\r\\t\\v}\n          continue;\n        }\n\n        // wait for non whitespace character\n        if (w < 65 || w > 122 || w > 90 && w < 97) {\n          if (w !== 95 && w !== 58) {\n            // char 95\"_\" 58\":\"\n            handleWarning('illegal first char attribute name');\n            skipAttr = true;\n          }\n        }\n\n        // parse attribute name\n        for (j = i + 1; j < l; j++) {\n          w = s.charCodeAt(j);\n          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 46 ||\n          // '.'\n          w === 45 ||\n          // '-'\n          w === 95 // '_'\n          ) {\n            continue;\n          }\n\n          // unexpected whitespace\n          if (w === 32 || w < 14 && w > 8) {\n            // WHITESPACE\n            handleWarning('missing attribute value');\n            i = j;\n            continue parseAttr;\n          }\n\n          // expected \"=\"\n          if (w === 61) {\n            // \"=\" == 61\n            break;\n          }\n          handleWarning('illegal attribute name char');\n          skipAttr = true;\n        }\n        name = s.substring(i, j);\n        if (name === 'xmlns:xmlns') {\n          handleWarning('illegal declaration of xmlns');\n          skipAttr = true;\n        }\n        w = s.charCodeAt(j + 1);\n        if (w === 34) {\n          // '\"'\n          j = s.indexOf('\"', i = j + 2);\n          if (j === -1) {\n            j = s.indexOf('\\'', i);\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n        } else if (w === 39) {\n          // \"'\"\n          j = s.indexOf('\\'', i = j + 2);\n          if (j === -1) {\n            j = s.indexOf('\"', i);\n            if (j !== -1) {\n              handleWarning('attribute value quote missmatch');\n              skipAttr = true;\n            }\n          }\n        } else {\n          handleWarning('missing attribute value quotes');\n          skipAttr = true;\n\n          // skip to next space\n          for (j = j + 1; j < l; j++) {\n            w = s.charCodeAt(j + 1);\n            if (w === 32 || w < 14 && w > 8) {\n              // WHITESPACE\n              break;\n            }\n          }\n        }\n        if (j === -1) {\n          handleWarning('missing closing quotes');\n          j = l;\n          skipAttr = true;\n        }\n        if (!skipAttr) {\n          value = s.substring(i, j);\n        }\n        i = j;\n\n        // ensure SPACE follows attribute\n        // skip illegal content otherwise\n        // example a=\"b\"c\n        for (; j + 1 < l; j++) {\n          w = s.charCodeAt(j + 1);\n          if (w === 32 || w < 14 && w > 8) {\n            // WHITESPACE\n            break;\n          }\n\n          // FIRST ILLEGAL CHAR\n          if (i === j) {\n            handleWarning('illegal character after attribute end');\n            skipAttr = true;\n          }\n        }\n\n        // advance cursor to next attribute\n        i = j + 1;\n        if (skipAttr) {\n          continue parseAttr;\n        }\n\n        // check attribute re-declaration\n        if (name in seenAttrs) {\n          handleWarning('attribute <' + name + '> already defined');\n          continue;\n        }\n        seenAttrs[name] = true;\n        if (!isNamespace) {\n          attrs[name] = value;\n          continue;\n        }\n\n        // try to extract namespace information\n        if (maybeNS) {\n          newalias = name === 'xmlns' ? 'xmlns' : name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:' ? name.substr(6) : null;\n\n          // handle xmlns(:alias) assignment\n          if (newalias !== null) {\n            nsUri = decodeEntities(value);\n            nsUriPrefix = uriPrefix(newalias);\n            alias = nsUriToPrefix[nsUri];\n            if (!alias) {\n              // no prefix defined or prefix collision\n              if (newalias === 'xmlns' || nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri) {\n                // alocate free ns prefix\n                do {\n                  alias = 'ns' + anonymousNsCount++;\n                } while (typeof nsMatrix[alias] !== 'undefined');\n              } else {\n                alias = newalias;\n              }\n              nsUriToPrefix[nsUri] = alias;\n            }\n            if (nsMatrix[newalias] !== alias) {\n              if (!hasNewMatrix) {\n                nsMatrix = cloneNsMatrix(nsMatrix);\n                hasNewMatrix = true;\n              }\n              nsMatrix[newalias] = alias;\n              if (newalias === 'xmlns') {\n                nsMatrix[uriPrefix(alias)] = nsUri;\n                defaultAlias = alias;\n              }\n              nsMatrix[nsUriPrefix] = nsUri;\n            }\n\n            // expose xmlns(:asd)=\"...\" in attributes\n            attrs[name] = value;\n            continue;\n          }\n\n          // collect attributes until all namespace\n          // declarations are processed\n          attrList.push(name, value);\n          continue;\n        } /** end if (maybeNs) */\n\n        // handle attributes on element without\n        // namespace declarations\n        w = name.indexOf(':');\n        if (w === -1) {\n          attrs[name] = value;\n          continue;\n        }\n\n        // normalize ns attribute name\n        if (!(nsName = nsMatrix[name.substring(0, w)])) {\n          handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n          continue;\n        }\n        name = defaultAlias === nsName ? name.substr(w + 1) : nsName + name.substr(w);\n\n        // end: normalize ns attribute name\n\n        // normalize xsi:type ns attribute value\n        if (name === XSI_TYPE) {\n          w = value.indexOf(':');\n          if (w !== -1) {\n            nsName = value.substring(0, w);\n\n            // handle default prefixes, i.e. xs:String gracefully\n            nsName = nsMatrix[nsName] || nsName;\n            value = nsName + value.substring(w);\n          } else {\n            value = defaultAlias + ':' + value;\n          }\n        }\n\n        // end: normalize xsi:type ns attribute value\n\n        attrs[name] = value;\n      }\n\n      // handle deferred, possibly namespaced attributes\n      if (maybeNS) {\n        // normalize captured attributes\n        for (i = 0, l = attrList.length; i < l; i++) {\n          name = attrList[i++];\n          value = attrList[i];\n          w = name.indexOf(':');\n          if (w !== -1) {\n            // normalize ns attribute name\n            if (!(nsName = nsMatrix[name.substring(0, w)])) {\n              handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\n              continue;\n            }\n            name = defaultAlias === nsName ? name.substr(w + 1) : nsName + name.substr(w);\n\n            // end: normalize ns attribute name\n\n            // normalize xsi:type ns attribute value\n            if (name === XSI_TYPE) {\n              w = value.indexOf(':');\n              if (w !== -1) {\n                nsName = value.substring(0, w);\n\n                // handle default prefixes, i.e. xs:String gracefully\n                nsName = nsMatrix[nsName] || nsName;\n                value = nsName + value.substring(w);\n              } else {\n                value = defaultAlias + ':' + value;\n              }\n            }\n\n            // end: normalize xsi:type ns attribute value\n          }\n\n          attrs[name] = value;\n        }\n\n        // end: normalize captured attributes\n      }\n\n      return cachedAttrs = attrs;\n    }\n\n    /**\r\n     * Extract the parse context { line, column, part }\r\n     * from the current parser position.\r\n     *\r\n     * @return {Object} parse context\r\n     */\n    function getParseContext() {\n      var splitsRe = /(\\r\\n|\\r|\\n)/g;\n      var line = 0;\n      var column = 0;\n      var startOfLine = 0;\n      var endOfLine = j;\n      var match;\n      var data;\n      while (i >= startOfLine) {\n        match = splitsRe.exec(xml);\n        if (!match) {\n          break;\n        }\n\n        // end of line = (break idx + break chars)\n        endOfLine = match[0].length + match.index;\n        if (endOfLine > i) {\n          break;\n        }\n\n        // advance to next line\n        line += 1;\n        startOfLine = endOfLine;\n      }\n\n      // EOF errors\n      if (i == -1) {\n        column = endOfLine;\n        data = xml.substring(j);\n      } else\n        // start errors\n        if (j === 0) {\n          data = xml.substring(j, i);\n        }\n\n        // other errors\n        else {\n          column = i - startOfLine;\n          data = j == -1 ? xml.substring(i) : xml.substring(i, j + 1);\n        }\n      return {\n        'data': data,\n        'line': line,\n        'column': column\n      };\n    }\n    getContext = getParseContext;\n    if (proxy) {\n      elementProxy = Object.create({}, {\n        'name': getter(function () {\n          return elementName;\n        }),\n        'originalName': getter(function () {\n          return _elementName;\n        }),\n        'attrs': getter(getAttrs),\n        'ns': getter(function () {\n          return nsMatrix;\n        })\n      });\n    }\n\n    // actual parse logic\n    while (j !== -1) {\n      if (xml.charCodeAt(j) === 60) {\n        // \"<\"\n        i = j;\n      } else {\n        i = xml.indexOf('<', j);\n      }\n\n      // parse end\n      if (i === -1) {\n        if (nodeStack.length) {\n          return handleError('unexpected end of file');\n        }\n        if (j === 0) {\n          return handleError('missing start tag');\n        }\n        if (j < xml.length) {\n          if (xml.substring(j).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n          }\n        }\n        return;\n      }\n\n      // parse text\n      if (j !== i) {\n        if (nodeStack.length) {\n          if (onText) {\n            onText(xml.substring(j, i), decodeEntities, getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n        } else {\n          if (xml.substring(j, i).trim()) {\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\n            if (parseStop) {\n              return;\n            }\n          }\n        }\n      }\n      w = xml.charCodeAt(i + 1);\n\n      // parse comments + CDATA\n      if (w === 33) {\n        // \"!\"\n        q = xml.charCodeAt(i + 2);\n\n        // CDATA section\n        if (q === 91 && xml.substr(i + 3, 6) === 'CDATA[') {\n          // 91 == \"[\"\n          j = xml.indexOf(']]>', i);\n          if (j === -1) {\n            return handleError('unclosed cdata');\n          }\n          if (onCDATA) {\n            onCDATA(xml.substring(i + 9, j), getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n          j += 3;\n          continue;\n        }\n\n        // comment\n        if (q === 45 && xml.charCodeAt(i + 3) === 45) {\n          // 45 == \"-\"\n          j = xml.indexOf('-->', i);\n          if (j === -1) {\n            return handleError('unclosed comment');\n          }\n          if (onComment) {\n            onComment(xml.substring(i + 4, j), decodeEntities, getContext);\n            if (parseStop) {\n              return;\n            }\n          }\n          j += 3;\n          continue;\n        }\n      }\n\n      // parse question <? ... ?>\n      if (w === 63) {\n        // \"?\"\n        j = xml.indexOf('?>', i);\n        if (j === -1) {\n          return handleError('unclosed question');\n        }\n        if (onQuestion) {\n          onQuestion(xml.substring(i, j + 2), getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n        j += 2;\n        continue;\n      }\n\n      // find matching closing tag for attention or standard tags\n      // for that we must skip through attribute values\n      // (enclosed in single or double quotes)\n      for (x = i + 1;; x++) {\n        v = xml.charCodeAt(x);\n        if (isNaN(v)) {\n          j = -1;\n          return handleError('unclosed tag');\n        }\n\n        // [10] AttValue ::= '\"' ([^<&\"] | Reference)* '\"' | \"'\" ([^<&'] | Reference)* \"'\"\n        // skips the quoted string\n        // (double quotes) does not appear in a literal enclosed by (double quotes)\n        // (single quote) does not appear in a literal enclosed by (single quote)\n        if (v === 34) {\n          //  '\"'\n          q = xml.indexOf('\"', x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 39) {\n          // \"'\"\n          q = xml.indexOf(\"'\", x + 1);\n          x = q !== -1 ? q : x;\n        } else if (v === 62) {\n          // '>'\n          j = x;\n          break;\n        }\n      }\n\n      // parse attention <! ...>\n      // previously comment and CDATA have already been parsed\n      if (w === 33) {\n        // \"!\"\n\n        if (onAttention) {\n          onAttention(xml.substring(i, j + 1), decodeEntities, getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n        j += 1;\n        continue;\n      }\n\n      // don't process attributes;\n      // there are none\n      cachedAttrs = {};\n\n      // if (xml.charCodeAt(i+1) === 47) { // </...\n      if (w === 47) {\n        // </...\n        tagStart = false;\n        tagEnd = true;\n        if (!nodeStack.length) {\n          return handleError('missing open tag');\n        }\n\n        // verify open <-> close tag match\n        x = elementName = nodeStack.pop();\n        q = i + 2 + x.length;\n        if (xml.substring(i + 2, q) !== x) {\n          return handleError('closing tag mismatch');\n        }\n\n        // verify chars in close tag\n        for (; q < j; q++) {\n          w = xml.charCodeAt(q);\n          if (w === 32 || w > 8 && w < 14) {\n            // \\f\\n\\r\\t\\v space\n            continue;\n          }\n          return handleError('close tag');\n        }\n      } else {\n        if (xml.charCodeAt(j - 1) === 47) {\n          // .../>\n          x = elementName = xml.substring(i + 1, j - 1);\n          tagStart = true;\n          tagEnd = true;\n        } else {\n          x = elementName = xml.substring(i + 1, j);\n          tagStart = true;\n          tagEnd = false;\n        }\n        if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) {\n          // char 95\"_\" 58\":\"\n          return handleError('illegal first char nodeName');\n        }\n        for (q = 1, y = x.length; q < y; q++) {\n          w = x.charCodeAt(q);\n          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {\n            continue;\n          }\n          if (w === 32 || w < 14 && w > 8) {\n            // \\f\\n\\r\\t\\v space\n            elementName = x.substring(0, q);\n\n            // maybe there are attributes\n            cachedAttrs = null;\n            break;\n          }\n          return handleError('invalid nodeName');\n        }\n        if (!tagEnd) {\n          nodeStack.push(elementName);\n        }\n      }\n      if (isNamespace) {\n        _nsMatrix = nsMatrix;\n        if (tagStart) {\n          // remember old namespace\n          // unless we're self-closing\n          if (!tagEnd) {\n            nsMatrixStack.push(_nsMatrix);\n          }\n          if (cachedAttrs === null) {\n            // quick check, whether there may be namespace\n            // declarations on the node; if that is the case\n            // we need to eagerly parse the node attributes\n            if (maybeNS = x.indexOf('xmlns', q) !== -1) {\n              attrsStart = q;\n              attrsString = x;\n              getAttrs();\n              maybeNS = false;\n            }\n          }\n        }\n        _elementName = elementName;\n        w = elementName.indexOf(':');\n        if (w !== -1) {\n          xmlns = nsMatrix[elementName.substring(0, w)];\n\n          // prefix given; namespace must exist\n          if (!xmlns) {\n            return handleError('missing namespace on <' + _elementName + '>');\n          }\n          elementName = elementName.substr(w + 1);\n        } else {\n          xmlns = nsMatrix['xmlns'];\n\n          // if no default namespace is defined,\n          // we'll import the element as anonymous.\n          //\n          // it is up to users to correct that to the document defined\n          // targetNamespace, or whatever their undersanding of the\n          // XML spec mandates.\n        }\n\n        // adjust namespace prefixs as configured\n        if (xmlns) {\n          elementName = xmlns + ':' + elementName;\n        }\n      }\n      if (tagStart) {\n        attrsStart = q;\n        attrsString = x;\n        if (onOpenTag) {\n          if (proxy) {\n            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);\n          } else {\n            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);\n          }\n          if (parseStop) {\n            return;\n          }\n        }\n      }\n      if (tagEnd) {\n        if (onCloseTag) {\n          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);\n          if (parseStop) {\n            return;\n          }\n        }\n\n        // restore old namespace\n        if (isNamespace) {\n          if (!tagStart) {\n            nsMatrix = nsMatrixStack.pop();\n          } else {\n            nsMatrix = _nsMatrix;\n          }\n        }\n      }\n      j += 1;\n    }\n  } /** end parse */\n}\n\nexport { Parser, decodeEntities as decode };","map":{"version":3,"names":["fromCharCode","String","hasOwnProperty","Object","prototype","ENTITY_PATTERN","ENTITY_MAPPING","keys","forEach","k","toUpperCase","replaceEntities","_","d","x","z","call","parseInt","decodeEntities","s","length","indexOf","replace","XSI_URI","XSI_PREFIX","XSI_TYPE","NON_WHITESPACE_OUTSIDE_ROOT_NODE","error","msg","Error","missingNamespaceForPrefix","prefix","getter","getFn","cloneNsMatrix","nsMatrix","clone","key","uriPrefix","buildNsMatrix","nsUriToPrefix","uri","noopGetContext","throwFunc","err","Parser","options","proxy","onText","onOpenTag","onCloseTag","onCDATA","onError","onWarning","onComment","onQuestion","onAttention","getContext","maybeNS","isNamespace","returnError","parseStop","handleError","handleWarning","name","cb","nsMap","_nsUriToPrefix","xml","parse","nsMatrixStack","_nsMatrix","nodeStack","anonymousNsCount","tagStart","tagEnd","i","j","y","q","w","v","xmlns","elementName","_elementName","elementProxy","attrsString","attrsStart","cachedAttrs","getAttrs","nsUri","nsUriPrefix","nsName","defaultAlias","attrList","l","hasNewMatrix","newalias","value","alias","attrs","seenAttrs","skipAttr","parseAttr","charCodeAt","substring","substr","push","getParseContext","splitsRe","line","column","startOfLine","endOfLine","match","data","exec","index","create","trim","isNaN","pop","decode"],"sources":["C:/Users/sam/final/camunda-react/node_modules/saxen/dist/index.esm.js"],"sourcesContent":["var fromCharCode = String.fromCharCode;\r\n\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\r\nvar ENTITY_PATTERN = /&#(\\d+);|&#x([0-9a-f]+);|&(\\w+);/ig;\r\n\r\nvar ENTITY_MAPPING = {\r\n  'amp': '&',\r\n  'apos': '\\'',\r\n  'gt': '>',\r\n  'lt': '<',\r\n  'quot': '\"'\r\n};\r\n\r\n// map UPPERCASE variants of supported special chars\r\nObject.keys(ENTITY_MAPPING).forEach(function(k) {\r\n  ENTITY_MAPPING[k.toUpperCase()] = ENTITY_MAPPING[k];\r\n});\r\n\r\n\r\nfunction replaceEntities(_, d, x, z) {\r\n\r\n  // reserved names, i.e. &nbsp;\r\n  if (z) {\r\n    if (hasOwnProperty.call(ENTITY_MAPPING, z)) {\r\n      return ENTITY_MAPPING[z];\r\n    } else {\r\n\r\n      // fall back to original value\r\n      return '&' + z + ';';\r\n    }\r\n  }\r\n\r\n  // decimal encoded char\r\n  if (d) {\r\n    return fromCharCode(d);\r\n  }\r\n\r\n  // hex encoded char\r\n  return fromCharCode(parseInt(x, 16));\r\n}\r\n\r\n\r\n/**\r\n * A basic entity decoder that can decode a minimal\r\n * sub-set of reserved names (&amp;) as well as\r\n * hex (&#xaaf;) and decimal (&#1231;) encoded characters.\r\n *\r\n * @param {string} str\r\n *\r\n * @return {string} decoded string\r\n */\r\nfunction decodeEntities(s) {\r\n  if (s.length > 3 && s.indexOf('&') !== -1) {\r\n    return s.replace(ENTITY_PATTERN, replaceEntities);\r\n  }\r\n\r\n  return s;\r\n}\r\n\r\nvar XSI_URI = 'http://www.w3.org/2001/XMLSchema-instance';\r\nvar XSI_PREFIX = 'xsi';\r\nvar XSI_TYPE = 'xsi:type';\r\n\r\nvar NON_WHITESPACE_OUTSIDE_ROOT_NODE = 'non-whitespace outside of root node';\r\n\r\nfunction error(msg) {\r\n  return new Error(msg);\r\n}\r\n\r\nfunction missingNamespaceForPrefix(prefix) {\r\n  return 'missing namespace for prefix <' + prefix + '>';\r\n}\r\n\r\nfunction getter(getFn) {\r\n  return {\r\n    'get': getFn,\r\n    'enumerable': true\r\n  };\r\n}\r\n\r\nfunction cloneNsMatrix(nsMatrix) {\r\n  var clone = {}, key;\r\n  for (key in nsMatrix) {\r\n    clone[key] = nsMatrix[key];\r\n  }\r\n  return clone;\r\n}\r\n\r\nfunction uriPrefix(prefix) {\r\n  return prefix + '$uri';\r\n}\r\n\r\nfunction buildNsMatrix(nsUriToPrefix) {\r\n  var nsMatrix = {},\r\n      uri,\r\n      prefix;\r\n\r\n  for (uri in nsUriToPrefix) {\r\n    prefix = nsUriToPrefix[uri];\r\n    nsMatrix[prefix] = prefix;\r\n    nsMatrix[uriPrefix(prefix)] = uri;\r\n  }\r\n\r\n  return nsMatrix;\r\n}\r\n\r\nfunction noopGetContext() {\r\n  return { 'line': 0, 'column': 0 };\r\n}\r\n\r\nfunction throwFunc(err) {\r\n  throw err;\r\n}\r\n\r\n/**\r\n * Creates a new parser with the given options.\r\n *\r\n * @constructor\r\n *\r\n * @param  {!Object<string, ?>=} options\r\n */\r\nfunction Parser(options) {\r\n\r\n  if (!this) {\r\n    return new Parser(options);\r\n  }\r\n\r\n  var proxy = options && options['proxy'];\r\n\r\n  var onText,\r\n      onOpenTag,\r\n      onCloseTag,\r\n      onCDATA,\r\n      onError = throwFunc,\r\n      onWarning,\r\n      onComment,\r\n      onQuestion,\r\n      onAttention;\r\n\r\n  var getContext = noopGetContext;\r\n\r\n  /**\r\n   * Do we need to parse the current elements attributes for namespaces?\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  var maybeNS = false;\r\n\r\n  /**\r\n   * Do we process namespaces at all?\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  var isNamespace = false;\r\n\r\n  /**\r\n   * The caught error returned on parse end\r\n   *\r\n   * @type {Error}\r\n   */\r\n  var returnError = null;\r\n\r\n  /**\r\n   * Should we stop parsing?\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  var parseStop = false;\r\n\r\n  /**\r\n   * A map of { uri: prefix } used by the parser.\r\n   *\r\n   * This map will ensure we can normalize prefixes during processing;\r\n   * for each uri, only one prefix will be exposed to the handlers.\r\n   *\r\n   * @type {!Object<string, string>}}\r\n   */\r\n  var nsUriToPrefix;\r\n\r\n  /**\r\n   * Handle parse error.\r\n   *\r\n   * @param  {string|Error} err\r\n   */\r\n  function handleError(err) {\r\n    if (!(err instanceof Error)) {\r\n      err = error(err);\r\n    }\r\n\r\n    returnError = err;\r\n\r\n    onError(err, getContext);\r\n  }\r\n\r\n  /**\r\n   * Handle parse error.\r\n   *\r\n   * @param  {string|Error} err\r\n   */\r\n  function handleWarning(err) {\r\n\r\n    if (!onWarning) {\r\n      return;\r\n    }\r\n\r\n    if (!(err instanceof Error)) {\r\n      err = error(err);\r\n    }\r\n\r\n    onWarning(err, getContext);\r\n  }\r\n\r\n  /**\r\n   * Register parse listener.\r\n   *\r\n   * @param  {string}   name\r\n   * @param  {Function} cb\r\n   *\r\n   * @return {Parser}\r\n   */\r\n  this['on'] = function(name, cb) {\r\n\r\n    if (typeof cb !== 'function') {\r\n      throw error('required args <name, cb>');\r\n    }\r\n\r\n    switch (name) {\r\n    case 'openTag': onOpenTag = cb; break;\r\n    case 'text': onText = cb; break;\r\n    case 'closeTag': onCloseTag = cb; break;\r\n    case 'error': onError = cb; break;\r\n    case 'warn': onWarning = cb; break;\r\n    case 'cdata': onCDATA = cb; break;\r\n    case 'attention': onAttention = cb; break; // <!XXXXX zzzz=\"eeee\">\r\n    case 'question': onQuestion = cb; break; // <? ....  ?>\r\n    case 'comment': onComment = cb; break;\r\n    default:\r\n      throw error('unsupported event: ' + name);\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Set the namespace to prefix mapping.\r\n   *\r\n   * @example\r\n   *\r\n   * parser.ns({\r\n   *   'http://foo': 'foo',\r\n   *   'http://bar': 'bar'\r\n   * });\r\n   *\r\n   * @param  {!Object<string, string>} nsMap\r\n   *\r\n   * @return {Parser}\r\n   */\r\n  this['ns'] = function(nsMap) {\r\n\r\n    if (typeof nsMap === 'undefined') {\r\n      nsMap = {};\r\n    }\r\n\r\n    if (typeof nsMap !== 'object') {\r\n      throw error('required args <nsMap={}>');\r\n    }\r\n\r\n    var _nsUriToPrefix = {}, k;\r\n\r\n    for (k in nsMap) {\r\n      _nsUriToPrefix[k] = nsMap[k];\r\n    }\r\n\r\n    // FORCE default mapping for schema instance\r\n    _nsUriToPrefix[XSI_URI] = XSI_PREFIX;\r\n\r\n    isNamespace = true;\r\n    nsUriToPrefix = _nsUriToPrefix;\r\n\r\n    return this;\r\n  };\r\n\r\n  /**\r\n   * Parse xml string.\r\n   *\r\n   * @param  {string} xml\r\n   *\r\n   * @return {Error} returnError, if not thrown\r\n   */\r\n  this['parse'] = function(xml) {\r\n    if (typeof xml !== 'string') {\r\n      throw error('required args <xml=string>');\r\n    }\r\n\r\n    returnError = null;\r\n\r\n    parse(xml);\r\n\r\n    getContext = noopGetContext;\r\n    parseStop = false;\r\n\r\n    return returnError;\r\n  };\r\n\r\n  /**\r\n   * Stop parsing.\r\n   */\r\n  this['stop'] = function() {\r\n    parseStop = true;\r\n  };\r\n\r\n  /**\r\n   * Parse string, invoking configured listeners on element.\r\n   *\r\n   * @param  {string} xml\r\n   */\r\n  function parse(xml) {\r\n    var nsMatrixStack = isNamespace ? [] : null,\r\n        nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null,\r\n        _nsMatrix,\r\n        nodeStack = [],\r\n        anonymousNsCount = 0,\r\n        tagStart = false,\r\n        tagEnd = false,\r\n        i = 0, j = 0,\r\n        x, y, q, w, v,\r\n        xmlns,\r\n        elementName,\r\n        _elementName,\r\n        elementProxy\r\n        ;\r\n\r\n    var attrsString = '',\r\n        attrsStart = 0,\r\n        cachedAttrs // false = parsed with errors, null = needs parsing\r\n        ;\r\n\r\n    /**\r\n     * Parse attributes on demand and returns the parsed attributes.\r\n     *\r\n     * Return semantics: (1) `false` on attribute parse error,\r\n     * (2) object hash on extracted attrs.\r\n     *\r\n     * @return {boolean|Object}\r\n     */\r\n    function getAttrs() {\r\n      if (cachedAttrs !== null) {\r\n        return cachedAttrs;\r\n      }\r\n\r\n      var nsUri,\r\n          nsUriPrefix,\r\n          nsName,\r\n          defaultAlias = isNamespace && nsMatrix['xmlns'],\r\n          attrList = isNamespace && maybeNS ? [] : null,\r\n          i = attrsStart,\r\n          s = attrsString,\r\n          l = s.length,\r\n          hasNewMatrix,\r\n          newalias,\r\n          value,\r\n          alias,\r\n          name,\r\n          attrs = {},\r\n          seenAttrs = {},\r\n          skipAttr,\r\n          w,\r\n          j;\r\n\r\n      parseAttr:\r\n      for (; i < l; i++) {\r\n        skipAttr = false;\r\n        w = s.charCodeAt(i);\r\n\r\n        if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE={ \\f\\n\\r\\t\\v}\r\n          continue;\r\n        }\r\n\r\n        // wait for non whitespace character\r\n        if (w < 65 || w > 122 || (w > 90 && w < 97)) {\r\n          if (w !== 95 && w !== 58) { // char 95\"_\" 58\":\"\r\n            handleWarning('illegal first char attribute name');\r\n            skipAttr = true;\r\n          }\r\n        }\r\n\r\n        // parse attribute name\r\n        for (j = i + 1; j < l; j++) {\r\n          w = s.charCodeAt(j);\r\n\r\n          if (\r\n            w > 96 && w < 123 ||\r\n            w > 64 && w < 91 ||\r\n            w > 47 && w < 59 ||\r\n            w === 46 || // '.'\r\n            w === 45 || // '-'\r\n            w === 95 // '_'\r\n          ) {\r\n            continue;\r\n          }\r\n\r\n          // unexpected whitespace\r\n          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\r\n            handleWarning('missing attribute value');\r\n            i = j;\r\n\r\n            continue parseAttr;\r\n          }\r\n\r\n          // expected \"=\"\r\n          if (w === 61) { // \"=\" == 61\r\n            break;\r\n          }\r\n\r\n          handleWarning('illegal attribute name char');\r\n          skipAttr = true;\r\n        }\r\n\r\n        name = s.substring(i, j);\r\n\r\n        if (name === 'xmlns:xmlns') {\r\n          handleWarning('illegal declaration of xmlns');\r\n          skipAttr = true;\r\n        }\r\n\r\n        w = s.charCodeAt(j + 1);\r\n\r\n        if (w === 34) { // '\"'\r\n          j = s.indexOf('\"', i = j + 2);\r\n\r\n          if (j === -1) {\r\n            j = s.indexOf('\\'', i);\r\n\r\n            if (j !== -1) {\r\n              handleWarning('attribute value quote missmatch');\r\n              skipAttr = true;\r\n            }\r\n          }\r\n\r\n        } else if (w === 39) { // \"'\"\r\n          j = s.indexOf('\\'', i = j + 2);\r\n\r\n          if (j === -1) {\r\n            j = s.indexOf('\"', i);\r\n\r\n            if (j !== -1) {\r\n              handleWarning('attribute value quote missmatch');\r\n              skipAttr = true;\r\n            }\r\n          }\r\n\r\n        } else {\r\n          handleWarning('missing attribute value quotes');\r\n          skipAttr = true;\r\n\r\n          // skip to next space\r\n          for (j = j + 1; j < l; j++) {\r\n            w = s.charCodeAt(j + 1);\r\n\r\n            if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\r\n              break;\r\n            }\r\n          }\r\n\r\n        }\r\n\r\n        if (j === -1) {\r\n          handleWarning('missing closing quotes');\r\n\r\n          j = l;\r\n          skipAttr = true;\r\n        }\r\n\r\n        if (!skipAttr) {\r\n          value = s.substring(i, j);\r\n        }\r\n\r\n        i = j;\r\n\r\n        // ensure SPACE follows attribute\r\n        // skip illegal content otherwise\r\n        // example a=\"b\"c\r\n        for (; j + 1 < l; j++) {\r\n          w = s.charCodeAt(j + 1);\r\n\r\n          if (w === 32 || (w < 14 && w > 8)) { // WHITESPACE\r\n            break;\r\n          }\r\n\r\n          // FIRST ILLEGAL CHAR\r\n          if (i === j) {\r\n            handleWarning('illegal character after attribute end');\r\n            skipAttr = true;\r\n          }\r\n        }\r\n\r\n        // advance cursor to next attribute\r\n        i = j + 1;\r\n\r\n        if (skipAttr) {\r\n          continue parseAttr;\r\n        }\r\n\r\n        // check attribute re-declaration\r\n        if (name in seenAttrs) {\r\n          handleWarning('attribute <' + name + '> already defined');\r\n          continue;\r\n        }\r\n\r\n        seenAttrs[name] = true;\r\n\r\n        if (!isNamespace) {\r\n          attrs[name] = value;\r\n          continue;\r\n        }\r\n\r\n        // try to extract namespace information\r\n        if (maybeNS) {\r\n          newalias = (\r\n            name === 'xmlns'\r\n              ? 'xmlns'\r\n              : (name.charCodeAt(0) === 120 && name.substr(0, 6) === 'xmlns:')\r\n                ? name.substr(6)\r\n                : null\r\n          );\r\n\r\n          // handle xmlns(:alias) assignment\r\n          if (newalias !== null) {\r\n            nsUri = decodeEntities(value);\r\n            nsUriPrefix = uriPrefix(newalias);\r\n\r\n            alias = nsUriToPrefix[nsUri];\r\n\r\n            if (!alias) {\r\n\r\n              // no prefix defined or prefix collision\r\n              if (\r\n                (newalias === 'xmlns') ||\r\n                (nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri)\r\n              ) {\r\n\r\n                // alocate free ns prefix\r\n                do {\r\n                  alias = 'ns' + (anonymousNsCount++);\r\n                } while (typeof nsMatrix[alias] !== 'undefined');\r\n              } else {\r\n                alias = newalias;\r\n              }\r\n\r\n              nsUriToPrefix[nsUri] = alias;\r\n            }\r\n\r\n            if (nsMatrix[newalias] !== alias) {\r\n              if (!hasNewMatrix) {\r\n                nsMatrix = cloneNsMatrix(nsMatrix);\r\n                hasNewMatrix = true;\r\n              }\r\n\r\n              nsMatrix[newalias] = alias;\r\n              if (newalias === 'xmlns') {\r\n                nsMatrix[uriPrefix(alias)] = nsUri;\r\n                defaultAlias = alias;\r\n              }\r\n\r\n              nsMatrix[nsUriPrefix] = nsUri;\r\n            }\r\n\r\n            // expose xmlns(:asd)=\"...\" in attributes\r\n            attrs[name] = value;\r\n            continue;\r\n          }\r\n\r\n          // collect attributes until all namespace\r\n          // declarations are processed\r\n          attrList.push(name, value);\r\n          continue;\r\n\r\n        } /** end if (maybeNs) */\r\n\r\n        // handle attributes on element without\r\n        // namespace declarations\r\n        w = name.indexOf(':');\r\n        if (w === -1) {\r\n          attrs[name] = value;\r\n          continue;\r\n        }\r\n\r\n        // normalize ns attribute name\r\n        if (!(nsName = nsMatrix[name.substring(0, w)])) {\r\n          handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\r\n          continue;\r\n        }\r\n\r\n        name = defaultAlias === nsName\r\n          ? name.substr(w + 1)\r\n          : nsName + name.substr(w);\r\n\r\n        // end: normalize ns attribute name\r\n\r\n        // normalize xsi:type ns attribute value\r\n        if (name === XSI_TYPE) {\r\n          w = value.indexOf(':');\r\n\r\n          if (w !== -1) {\r\n            nsName = value.substring(0, w);\r\n\r\n            // handle default prefixes, i.e. xs:String gracefully\r\n            nsName = nsMatrix[nsName] || nsName;\r\n            value = nsName + value.substring(w);\r\n          } else {\r\n            value = defaultAlias + ':' + value;\r\n          }\r\n        }\r\n\r\n        // end: normalize xsi:type ns attribute value\r\n\r\n        attrs[name] = value;\r\n      }\r\n\r\n\r\n      // handle deferred, possibly namespaced attributes\r\n      if (maybeNS) {\r\n\r\n        // normalize captured attributes\r\n        for (i = 0, l = attrList.length; i < l; i++) {\r\n\r\n          name = attrList[i++];\r\n          value = attrList[i];\r\n\r\n          w = name.indexOf(':');\r\n\r\n          if (w !== -1) {\r\n\r\n            // normalize ns attribute name\r\n            if (!(nsName = nsMatrix[name.substring(0, w)])) {\r\n              handleWarning(missingNamespaceForPrefix(name.substring(0, w)));\r\n              continue;\r\n            }\r\n\r\n            name = defaultAlias === nsName\r\n              ? name.substr(w + 1)\r\n              : nsName + name.substr(w);\r\n\r\n            // end: normalize ns attribute name\r\n\r\n            // normalize xsi:type ns attribute value\r\n            if (name === XSI_TYPE) {\r\n              w = value.indexOf(':');\r\n\r\n              if (w !== -1) {\r\n                nsName = value.substring(0, w);\r\n\r\n                // handle default prefixes, i.e. xs:String gracefully\r\n                nsName = nsMatrix[nsName] || nsName;\r\n                value = nsName + value.substring(w);\r\n              } else {\r\n                value = defaultAlias + ':' + value;\r\n              }\r\n            }\r\n\r\n            // end: normalize xsi:type ns attribute value\r\n          }\r\n\r\n          attrs[name] = value;\r\n        }\r\n\r\n        // end: normalize captured attributes\r\n      }\r\n\r\n      return cachedAttrs = attrs;\r\n    }\r\n\r\n    /**\r\n     * Extract the parse context { line, column, part }\r\n     * from the current parser position.\r\n     *\r\n     * @return {Object} parse context\r\n     */\r\n    function getParseContext() {\r\n      var splitsRe = /(\\r\\n|\\r|\\n)/g;\r\n\r\n      var line = 0;\r\n      var column = 0;\r\n      var startOfLine = 0;\r\n      var endOfLine = j;\r\n      var match;\r\n      var data;\r\n\r\n      while (i >= startOfLine) {\r\n\r\n        match = splitsRe.exec(xml);\r\n\r\n        if (!match) {\r\n          break;\r\n        }\r\n\r\n        // end of line = (break idx + break chars)\r\n        endOfLine = match[0].length + match.index;\r\n\r\n        if (endOfLine > i) {\r\n          break;\r\n        }\r\n\r\n        // advance to next line\r\n        line += 1;\r\n\r\n        startOfLine = endOfLine;\r\n      }\r\n\r\n      // EOF errors\r\n      if (i == -1) {\r\n        column = endOfLine;\r\n        data = xml.substring(j);\r\n      } else\r\n\r\n      // start errors\r\n      if (j === 0) {\r\n        data = xml.substring(j, i);\r\n      }\r\n\r\n      // other errors\r\n      else {\r\n        column = i - startOfLine;\r\n        data = (j == -1 ? xml.substring(i) : xml.substring(i, j + 1));\r\n      }\r\n\r\n      return {\r\n        'data': data,\r\n        'line': line,\r\n        'column': column\r\n      };\r\n    }\r\n\r\n    getContext = getParseContext;\r\n\r\n\r\n    if (proxy) {\r\n      elementProxy = Object.create({}, {\r\n        'name': getter(function() {\r\n          return elementName;\r\n        }),\r\n        'originalName': getter(function() {\r\n          return _elementName;\r\n        }),\r\n        'attrs': getter(getAttrs),\r\n        'ns': getter(function() {\r\n          return nsMatrix;\r\n        })\r\n      });\r\n    }\r\n\r\n    // actual parse logic\r\n    while (j !== -1) {\r\n\r\n      if (xml.charCodeAt(j) === 60) { // \"<\"\r\n        i = j;\r\n      } else {\r\n        i = xml.indexOf('<', j);\r\n      }\r\n\r\n      // parse end\r\n      if (i === -1) {\r\n        if (nodeStack.length) {\r\n          return handleError('unexpected end of file');\r\n        }\r\n\r\n        if (j === 0) {\r\n          return handleError('missing start tag');\r\n        }\r\n\r\n        if (j < xml.length) {\r\n          if (xml.substring(j).trim()) {\r\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\r\n          }\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      // parse text\r\n      if (j !== i) {\r\n\r\n        if (nodeStack.length) {\r\n          if (onText) {\r\n            onText(xml.substring(j, i), decodeEntities, getContext);\r\n\r\n            if (parseStop) {\r\n              return;\r\n            }\r\n          }\r\n        } else {\r\n          if (xml.substring(j, i).trim()) {\r\n            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);\r\n\r\n            if (parseStop) {\r\n              return;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      w = xml.charCodeAt(i+1);\r\n\r\n      // parse comments + CDATA\r\n      if (w === 33) { // \"!\"\r\n        q = xml.charCodeAt(i+2);\r\n\r\n        // CDATA section\r\n        if (q === 91 && xml.substr(i + 3, 6) === 'CDATA[') { // 91 == \"[\"\r\n          j = xml.indexOf(']]>', i);\r\n          if (j === -1) {\r\n            return handleError('unclosed cdata');\r\n          }\r\n\r\n          if (onCDATA) {\r\n            onCDATA(xml.substring(i + 9, j), getContext);\r\n            if (parseStop) {\r\n              return;\r\n            }\r\n          }\r\n\r\n          j += 3;\r\n          continue;\r\n        }\r\n\r\n        // comment\r\n        if (q === 45 && xml.charCodeAt(i + 3) === 45) { // 45 == \"-\"\r\n          j = xml.indexOf('-->', i);\r\n          if (j === -1) {\r\n            return handleError('unclosed comment');\r\n          }\r\n\r\n\r\n          if (onComment) {\r\n            onComment(xml.substring(i + 4, j), decodeEntities, getContext);\r\n            if (parseStop) {\r\n              return;\r\n            }\r\n          }\r\n\r\n          j += 3;\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // parse question <? ... ?>\r\n      if (w === 63) { // \"?\"\r\n        j = xml.indexOf('?>', i);\r\n        if (j === -1) {\r\n          return handleError('unclosed question');\r\n        }\r\n\r\n        if (onQuestion) {\r\n          onQuestion(xml.substring(i, j + 2), getContext);\r\n          if (parseStop) {\r\n            return;\r\n          }\r\n        }\r\n\r\n        j += 2;\r\n        continue;\r\n      }\r\n\r\n      // find matching closing tag for attention or standard tags\r\n      // for that we must skip through attribute values\r\n      // (enclosed in single or double quotes)\r\n      for (x = i + 1; ; x++) {\r\n        v = xml.charCodeAt(x);\r\n        if (isNaN(v)) {\r\n          j = -1;\r\n          return handleError('unclosed tag');\r\n        }\r\n\r\n        // [10] AttValue ::= '\"' ([^<&\"] | Reference)* '\"' | \"'\" ([^<&'] | Reference)* \"'\"\r\n        // skips the quoted string\r\n        // (double quotes) does not appear in a literal enclosed by (double quotes)\r\n        // (single quote) does not appear in a literal enclosed by (single quote)\r\n        if (v === 34) { //  '\"'\r\n          q = xml.indexOf('\"', x + 1);\r\n          x = q !== -1 ? q : x;\r\n        } else if (v === 39) { // \"'\"\r\n          q = xml.indexOf(\"'\", x + 1);\r\n          x = q !== -1 ? q : x;\r\n        } else if (v === 62) { // '>'\r\n          j = x;\r\n          break;\r\n        }\r\n      }\r\n\r\n\r\n      // parse attention <! ...>\r\n      // previously comment and CDATA have already been parsed\r\n      if (w === 33) { // \"!\"\r\n\r\n        if (onAttention) {\r\n          onAttention(xml.substring(i, j + 1), decodeEntities, getContext);\r\n          if (parseStop) {\r\n            return;\r\n          }\r\n        }\r\n\r\n        j += 1;\r\n        continue;\r\n      }\r\n\r\n      // don't process attributes;\r\n      // there are none\r\n      cachedAttrs = {};\r\n\r\n      // if (xml.charCodeAt(i+1) === 47) { // </...\r\n      if (w === 47) { // </...\r\n        tagStart = false;\r\n        tagEnd = true;\r\n\r\n        if (!nodeStack.length) {\r\n          return handleError('missing open tag');\r\n        }\r\n\r\n        // verify open <-> close tag match\r\n        x = elementName = nodeStack.pop();\r\n        q = i + 2 + x.length;\r\n\r\n        if (xml.substring(i + 2, q) !== x) {\r\n          return handleError('closing tag mismatch');\r\n        }\r\n\r\n        // verify chars in close tag\r\n        for (; q < j; q++) {\r\n          w = xml.charCodeAt(q);\r\n\r\n          if (w === 32 || (w > 8 && w < 14)) { // \\f\\n\\r\\t\\v space\r\n            continue;\r\n          }\r\n\r\n          return handleError('close tag');\r\n        }\r\n\r\n      } else {\r\n        if (xml.charCodeAt(j - 1) === 47) { // .../>\r\n          x = elementName = xml.substring(i + 1, j - 1);\r\n\r\n          tagStart = true;\r\n          tagEnd = true;\r\n\r\n        } else {\r\n          x = elementName = xml.substring(i + 1, j);\r\n\r\n          tagStart = true;\r\n          tagEnd = false;\r\n        }\r\n\r\n        if (!(w > 96 && w < 123 || w > 64 && w < 91 || w === 95 || w === 58)) { // char 95\"_\" 58\":\"\r\n          return handleError('illegal first char nodeName');\r\n        }\r\n\r\n        for (q = 1, y = x.length; q < y; q++) {\r\n          w = x.charCodeAt(q);\r\n\r\n          if (w > 96 && w < 123 || w > 64 && w < 91 || w > 47 && w < 59 || w === 45 || w === 95 || w == 46) {\r\n            continue;\r\n          }\r\n\r\n          if (w === 32 || (w < 14 && w > 8)) { // \\f\\n\\r\\t\\v space\r\n            elementName = x.substring(0, q);\r\n\r\n            // maybe there are attributes\r\n            cachedAttrs = null;\r\n            break;\r\n          }\r\n\r\n          return handleError('invalid nodeName');\r\n        }\r\n\r\n        if (!tagEnd) {\r\n          nodeStack.push(elementName);\r\n        }\r\n      }\r\n\r\n      if (isNamespace) {\r\n\r\n        _nsMatrix = nsMatrix;\r\n\r\n        if (tagStart) {\r\n\r\n          // remember old namespace\r\n          // unless we're self-closing\r\n          if (!tagEnd) {\r\n            nsMatrixStack.push(_nsMatrix);\r\n          }\r\n\r\n          if (cachedAttrs === null) {\r\n\r\n            // quick check, whether there may be namespace\r\n            // declarations on the node; if that is the case\r\n            // we need to eagerly parse the node attributes\r\n            if ((maybeNS = x.indexOf('xmlns', q) !== -1)) {\r\n              attrsStart = q;\r\n              attrsString = x;\r\n\r\n              getAttrs();\r\n\r\n              maybeNS = false;\r\n            }\r\n          }\r\n        }\r\n\r\n        _elementName = elementName;\r\n\r\n        w = elementName.indexOf(':');\r\n        if (w !== -1) {\r\n          xmlns = nsMatrix[elementName.substring(0, w)];\r\n\r\n          // prefix given; namespace must exist\r\n          if (!xmlns) {\r\n            return handleError('missing namespace on <' + _elementName + '>');\r\n          }\r\n\r\n          elementName = elementName.substr(w + 1);\r\n        } else {\r\n          xmlns = nsMatrix['xmlns'];\r\n\r\n          // if no default namespace is defined,\r\n          // we'll import the element as anonymous.\r\n          //\r\n          // it is up to users to correct that to the document defined\r\n          // targetNamespace, or whatever their undersanding of the\r\n          // XML spec mandates.\r\n        }\r\n\r\n        // adjust namespace prefixs as configured\r\n        if (xmlns) {\r\n          elementName = xmlns + ':' + elementName;\r\n        }\r\n\r\n      }\r\n\r\n      if (tagStart) {\r\n        attrsStart = q;\r\n        attrsString = x;\r\n\r\n        if (onOpenTag) {\r\n          if (proxy) {\r\n            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);\r\n          } else {\r\n            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);\r\n          }\r\n\r\n          if (parseStop) {\r\n            return;\r\n          }\r\n        }\r\n\r\n      }\r\n\r\n      if (tagEnd) {\r\n\r\n        if (onCloseTag) {\r\n          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);\r\n\r\n          if (parseStop) {\r\n            return;\r\n          }\r\n        }\r\n\r\n        // restore old namespace\r\n        if (isNamespace) {\r\n          if (!tagStart) {\r\n            nsMatrix = nsMatrixStack.pop();\r\n          } else {\r\n            nsMatrix = _nsMatrix;\r\n          }\r\n        }\r\n      }\r\n\r\n      j += 1;\r\n    }\r\n  } /** end parse */\r\n\r\n}\r\n\r\nexport { Parser, decodeEntities as decode };\r\n"],"mappings":"AAAA,IAAIA,YAAY,GAAGC,MAAM,CAACD,YAAY;AAEtC,IAAIE,cAAc,GAAGC,MAAM,CAACC,SAAS,CAACF,cAAc;AAEpD,IAAIG,cAAc,GAAG,oCAAoC;AAEzD,IAAIC,cAAc,GAAG;EACnB,KAAK,EAAE,GAAG;EACV,MAAM,EAAE,IAAI;EACZ,IAAI,EAAE,GAAG;EACT,IAAI,EAAE,GAAG;EACT,MAAM,EAAE;AACV,CAAC;;AAED;AACAH,MAAM,CAACI,IAAI,CAACD,cAAc,CAAC,CAACE,OAAO,CAAC,UAASC,CAAC,EAAE;EAC9CH,cAAc,CAACG,CAAC,CAACC,WAAW,EAAE,CAAC,GAAGJ,cAAc,CAACG,CAAC,CAAC;AACrD,CAAC,CAAC;AAGF,SAASE,eAAeA,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAE;EAEnC;EACA,IAAIA,CAAC,EAAE;IACL,IAAIb,cAAc,CAACc,IAAI,CAACV,cAAc,EAAES,CAAC,CAAC,EAAE;MAC1C,OAAOT,cAAc,CAACS,CAAC,CAAC;IAC1B,CAAC,MAAM;MAEL;MACA,OAAO,GAAG,GAAGA,CAAC,GAAG,GAAG;IACtB;EACF;;EAEA;EACA,IAAIF,CAAC,EAAE;IACL,OAAOb,YAAY,CAACa,CAAC,CAAC;EACxB;;EAEA;EACA,OAAOb,YAAY,CAACiB,QAAQ,CAACH,CAAC,EAAE,EAAE,CAAC,CAAC;AACtC;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,cAAcA,CAACC,CAAC,EAAE;EACzB,IAAIA,CAAC,CAACC,MAAM,GAAG,CAAC,IAAID,CAAC,CAACE,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;IACzC,OAAOF,CAAC,CAACG,OAAO,CAACjB,cAAc,EAAEM,eAAe,CAAC;EACnD;EAEA,OAAOQ,CAAC;AACV;AAEA,IAAII,OAAO,GAAG,2CAA2C;AACzD,IAAIC,UAAU,GAAG,KAAK;AACtB,IAAIC,QAAQ,GAAG,UAAU;AAEzB,IAAIC,gCAAgC,GAAG,qCAAqC;AAE5E,SAASC,KAAKA,CAACC,GAAG,EAAE;EAClB,OAAO,IAAIC,KAAK,CAACD,GAAG,CAAC;AACvB;AAEA,SAASE,yBAAyBA,CAACC,MAAM,EAAE;EACzC,OAAO,gCAAgC,GAAGA,MAAM,GAAG,GAAG;AACxD;AAEA,SAASC,MAAMA,CAACC,KAAK,EAAE;EACrB,OAAO;IACL,KAAK,EAAEA,KAAK;IACZ,YAAY,EAAE;EAChB,CAAC;AACH;AAEA,SAASC,aAAaA,CAACC,QAAQ,EAAE;EAC/B,IAAIC,KAAK,GAAG,CAAC,CAAC;IAAEC,GAAG;EACnB,KAAKA,GAAG,IAAIF,QAAQ,EAAE;IACpBC,KAAK,CAACC,GAAG,CAAC,GAAGF,QAAQ,CAACE,GAAG,CAAC;EAC5B;EACA,OAAOD,KAAK;AACd;AAEA,SAASE,SAASA,CAACP,MAAM,EAAE;EACzB,OAAOA,MAAM,GAAG,MAAM;AACxB;AAEA,SAASQ,aAAaA,CAACC,aAAa,EAAE;EACpC,IAAIL,QAAQ,GAAG,CAAC,CAAC;IACbM,GAAG;IACHV,MAAM;EAEV,KAAKU,GAAG,IAAID,aAAa,EAAE;IACzBT,MAAM,GAAGS,aAAa,CAACC,GAAG,CAAC;IAC3BN,QAAQ,CAACJ,MAAM,CAAC,GAAGA,MAAM;IACzBI,QAAQ,CAACG,SAAS,CAACP,MAAM,CAAC,CAAC,GAAGU,GAAG;EACnC;EAEA,OAAON,QAAQ;AACjB;AAEA,SAASO,cAAcA,CAAA,EAAG;EACxB,OAAO;IAAE,MAAM,EAAE,CAAC;IAAE,QAAQ,EAAE;EAAE,CAAC;AACnC;AAEA,SAASC,SAASA,CAACC,GAAG,EAAE;EACtB,MAAMA,GAAG;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAMA,CAACC,OAAO,EAAE;EAEvB,IAAI,CAAC,IAAI,EAAE;IACT,OAAO,IAAID,MAAM,CAACC,OAAO,CAAC;EAC5B;EAEA,IAAIC,KAAK,GAAGD,OAAO,IAAIA,OAAO,CAAC,OAAO,CAAC;EAEvC,IAAIE,MAAM;IACNC,SAAS;IACTC,UAAU;IACVC,OAAO;IACPC,OAAO,GAAGT,SAAS;IACnBU,SAAS;IACTC,SAAS;IACTC,UAAU;IACVC,WAAW;EAEf,IAAIC,UAAU,GAAGf,cAAc;;EAE/B;AACF;AACA;AACA;AACA;EACE,IAAIgB,OAAO,GAAG,KAAK;;EAEnB;AACF;AACA;AACA;AACA;EACE,IAAIC,WAAW,GAAG,KAAK;;EAEvB;AACF;AACA;AACA;AACA;EACE,IAAIC,WAAW,GAAG,IAAI;;EAEtB;AACF;AACA;AACA;AACA;EACE,IAAIC,SAAS,GAAG,KAAK;;EAErB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAIrB,aAAa;;EAEjB;AACF;AACA;AACA;AACA;EACE,SAASsB,WAAWA,CAAClB,GAAG,EAAE;IACxB,IAAI,EAAEA,GAAG,YAAYf,KAAK,CAAC,EAAE;MAC3Be,GAAG,GAAGjB,KAAK,CAACiB,GAAG,CAAC;IAClB;IAEAgB,WAAW,GAAGhB,GAAG;IAEjBQ,OAAO,CAACR,GAAG,EAAEa,UAAU,CAAC;EAC1B;;EAEA;AACF;AACA;AACA;AACA;EACE,SAASM,aAAaA,CAACnB,GAAG,EAAE;IAE1B,IAAI,CAACS,SAAS,EAAE;MACd;IACF;IAEA,IAAI,EAAET,GAAG,YAAYf,KAAK,CAAC,EAAE;MAC3Be,GAAG,GAAGjB,KAAK,CAACiB,GAAG,CAAC;IAClB;IAEAS,SAAS,CAACT,GAAG,EAAEa,UAAU,CAAC;EAC5B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAAC,IAAI,CAAC,GAAG,UAASO,IAAI,EAAEC,EAAE,EAAE;IAE9B,IAAI,OAAOA,EAAE,KAAK,UAAU,EAAE;MAC5B,MAAMtC,KAAK,CAAC,0BAA0B,CAAC;IACzC;IAEA,QAAQqC,IAAI;MACZ,KAAK,SAAS;QAAEf,SAAS,GAAGgB,EAAE;QAAE;MAChC,KAAK,MAAM;QAAEjB,MAAM,GAAGiB,EAAE;QAAE;MAC1B,KAAK,UAAU;QAAEf,UAAU,GAAGe,EAAE;QAAE;MAClC,KAAK,OAAO;QAAEb,OAAO,GAAGa,EAAE;QAAE;MAC5B,KAAK,MAAM;QAAEZ,SAAS,GAAGY,EAAE;QAAE;MAC7B,KAAK,OAAO;QAAEd,OAAO,GAAGc,EAAE;QAAE;MAC5B,KAAK,WAAW;QAAET,WAAW,GAAGS,EAAE;QAAE;MAAO;MAC3C,KAAK,UAAU;QAAEV,UAAU,GAAGU,EAAE;QAAE;MAAO;MACzC,KAAK,SAAS;QAAEX,SAAS,GAAGW,EAAE;QAAE;MAChC;QACE,MAAMtC,KAAK,CAAC,qBAAqB,GAAGqC,IAAI,CAAC;IAAC;IAG5C,OAAO,IAAI;EACb,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAAC,IAAI,CAAC,GAAG,UAASE,KAAK,EAAE;IAE3B,IAAI,OAAOA,KAAK,KAAK,WAAW,EAAE;MAChCA,KAAK,GAAG,CAAC,CAAC;IACZ;IAEA,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC7B,MAAMvC,KAAK,CAAC,0BAA0B,CAAC;IACzC;IAEA,IAAIwC,cAAc,GAAG,CAAC,CAAC;MAAE1D,CAAC;IAE1B,KAAKA,CAAC,IAAIyD,KAAK,EAAE;MACfC,cAAc,CAAC1D,CAAC,CAAC,GAAGyD,KAAK,CAACzD,CAAC,CAAC;IAC9B;;IAEA;IACA0D,cAAc,CAAC5C,OAAO,CAAC,GAAGC,UAAU;IAEpCmC,WAAW,GAAG,IAAI;IAClBnB,aAAa,GAAG2B,cAAc;IAE9B,OAAO,IAAI;EACb,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAI,CAAC,OAAO,CAAC,GAAG,UAASC,GAAG,EAAE;IAC5B,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;MAC3B,MAAMzC,KAAK,CAAC,4BAA4B,CAAC;IAC3C;IAEAiC,WAAW,GAAG,IAAI;IAElBS,KAAK,CAACD,GAAG,CAAC;IAEVX,UAAU,GAAGf,cAAc;IAC3BmB,SAAS,GAAG,KAAK;IAEjB,OAAOD,WAAW;EACpB,CAAC;;EAED;AACF;AACA;EACE,IAAI,CAAC,MAAM,CAAC,GAAG,YAAW;IACxBC,SAAS,GAAG,IAAI;EAClB,CAAC;;EAED;AACF;AACA;AACA;AACA;EACE,SAASQ,KAAKA,CAACD,GAAG,EAAE;IAClB,IAAIE,aAAa,GAAGX,WAAW,GAAG,EAAE,GAAG,IAAI;MACvCxB,QAAQ,GAAGwB,WAAW,GAAGpB,aAAa,CAACC,aAAa,CAAC,GAAG,IAAI;MAC5D+B,SAAS;MACTC,SAAS,GAAG,EAAE;MACdC,gBAAgB,GAAG,CAAC;MACpBC,QAAQ,GAAG,KAAK;MAChBC,MAAM,GAAG,KAAK;MACdC,CAAC,GAAG,CAAC;MAAEC,CAAC,GAAG,CAAC;MACZ/D,CAAC;MAAEgE,CAAC;MAAEC,CAAC;MAAEC,CAAC;MAAEC,CAAC;MACbC,KAAK;MACLC,WAAW;MACXC,YAAY;MACZC,YAAY;IAGhB,IAAIC,WAAW,GAAG,EAAE;MAChBC,UAAU,GAAG,CAAC;MACdC,WAAW,CAAC;IAAA;;IAGhB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACI,SAASC,QAAQA,CAAA,EAAG;MAClB,IAAID,WAAW,KAAK,IAAI,EAAE;QACxB,OAAOA,WAAW;MACpB;MAEA,IAAIE,KAAK;QACLC,WAAW;QACXC,MAAM;QACNC,YAAY,GAAGlC,WAAW,IAAIxB,QAAQ,CAAC,OAAO,CAAC;QAC/C2D,QAAQ,GAAGnC,WAAW,IAAID,OAAO,GAAG,EAAE,GAAG,IAAI;QAC7CkB,CAAC,GAAGW,UAAU;QACdpE,CAAC,GAAGmE,WAAW;QACfS,CAAC,GAAG5E,CAAC,CAACC,MAAM;QACZ4E,YAAY;QACZC,QAAQ;QACRC,KAAK;QACLC,KAAK;QACLnC,IAAI;QACJoC,KAAK,GAAG,CAAC,CAAC;QACVC,SAAS,GAAG,CAAC,CAAC;QACdC,QAAQ;QACRtB,CAAC;QACDH,CAAC;MAEL0B,SAAS,EACT,OAAO3B,CAAC,GAAGmB,CAAC,EAAEnB,CAAC,EAAE,EAAE;QACjB0B,QAAQ,GAAG,KAAK;QAChBtB,CAAC,GAAG7D,CAAC,CAACqF,UAAU,CAAC5B,CAAC,CAAC;QAEnB,IAAII,CAAC,KAAK,EAAE,IAAKA,CAAC,GAAG,EAAE,IAAIA,CAAC,GAAG,CAAE,EAAE;UAAE;UACnC;QACF;;QAEA;QACA,IAAIA,CAAC,GAAG,EAAE,IAAIA,CAAC,GAAG,GAAG,IAAKA,CAAC,GAAG,EAAE,IAAIA,CAAC,GAAG,EAAG,EAAE;UAC3C,IAAIA,CAAC,KAAK,EAAE,IAAIA,CAAC,KAAK,EAAE,EAAE;YAAE;YAC1BjB,aAAa,CAAC,mCAAmC,CAAC;YAClDuC,QAAQ,GAAG,IAAI;UACjB;QACF;;QAEA;QACA,KAAKzB,CAAC,GAAGD,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGkB,CAAC,EAAElB,CAAC,EAAE,EAAE;UAC1BG,CAAC,GAAG7D,CAAC,CAACqF,UAAU,CAAC3B,CAAC,CAAC;UAEnB,IACEG,CAAC,GAAG,EAAE,IAAIA,CAAC,GAAG,GAAG,IACjBA,CAAC,GAAG,EAAE,IAAIA,CAAC,GAAG,EAAE,IAChBA,CAAC,GAAG,EAAE,IAAIA,CAAC,GAAG,EAAE,IAChBA,CAAC,KAAK,EAAE;UAAI;UACZA,CAAC,KAAK,EAAE;UAAI;UACZA,CAAC,KAAK,EAAE,CAAC;UAAA,EACT;YACA;UACF;;UAEA;UACA,IAAIA,CAAC,KAAK,EAAE,IAAKA,CAAC,GAAG,EAAE,IAAIA,CAAC,GAAG,CAAE,EAAE;YAAE;YACnCjB,aAAa,CAAC,yBAAyB,CAAC;YACxCa,CAAC,GAAGC,CAAC;YAEL,SAAS0B,SAAS;UACpB;;UAEA;UACA,IAAIvB,CAAC,KAAK,EAAE,EAAE;YAAE;YACd;UACF;UAEAjB,aAAa,CAAC,6BAA6B,CAAC;UAC5CuC,QAAQ,GAAG,IAAI;QACjB;QAEAtC,IAAI,GAAG7C,CAAC,CAACsF,SAAS,CAAC7B,CAAC,EAAEC,CAAC,CAAC;QAExB,IAAIb,IAAI,KAAK,aAAa,EAAE;UAC1BD,aAAa,CAAC,8BAA8B,CAAC;UAC7CuC,QAAQ,GAAG,IAAI;QACjB;QAEAtB,CAAC,GAAG7D,CAAC,CAACqF,UAAU,CAAC3B,CAAC,GAAG,CAAC,CAAC;QAEvB,IAAIG,CAAC,KAAK,EAAE,EAAE;UAAE;UACdH,CAAC,GAAG1D,CAAC,CAACE,OAAO,CAAC,GAAG,EAAEuD,CAAC,GAAGC,CAAC,GAAG,CAAC,CAAC;UAE7B,IAAIA,CAAC,KAAK,CAAC,CAAC,EAAE;YACZA,CAAC,GAAG1D,CAAC,CAACE,OAAO,CAAC,IAAI,EAAEuD,CAAC,CAAC;YAEtB,IAAIC,CAAC,KAAK,CAAC,CAAC,EAAE;cACZd,aAAa,CAAC,iCAAiC,CAAC;cAChDuC,QAAQ,GAAG,IAAI;YACjB;UACF;QAEF,CAAC,MAAM,IAAItB,CAAC,KAAK,EAAE,EAAE;UAAE;UACrBH,CAAC,GAAG1D,CAAC,CAACE,OAAO,CAAC,IAAI,EAAEuD,CAAC,GAAGC,CAAC,GAAG,CAAC,CAAC;UAE9B,IAAIA,CAAC,KAAK,CAAC,CAAC,EAAE;YACZA,CAAC,GAAG1D,CAAC,CAACE,OAAO,CAAC,GAAG,EAAEuD,CAAC,CAAC;YAErB,IAAIC,CAAC,KAAK,CAAC,CAAC,EAAE;cACZd,aAAa,CAAC,iCAAiC,CAAC;cAChDuC,QAAQ,GAAG,IAAI;YACjB;UACF;QAEF,CAAC,MAAM;UACLvC,aAAa,CAAC,gCAAgC,CAAC;UAC/CuC,QAAQ,GAAG,IAAI;;UAEf;UACA,KAAKzB,CAAC,GAAGA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkB,CAAC,EAAElB,CAAC,EAAE,EAAE;YAC1BG,CAAC,GAAG7D,CAAC,CAACqF,UAAU,CAAC3B,CAAC,GAAG,CAAC,CAAC;YAEvB,IAAIG,CAAC,KAAK,EAAE,IAAKA,CAAC,GAAG,EAAE,IAAIA,CAAC,GAAG,CAAE,EAAE;cAAE;cACnC;YACF;UACF;QAEF;QAEA,IAAIH,CAAC,KAAK,CAAC,CAAC,EAAE;UACZd,aAAa,CAAC,wBAAwB,CAAC;UAEvCc,CAAC,GAAGkB,CAAC;UACLO,QAAQ,GAAG,IAAI;QACjB;QAEA,IAAI,CAACA,QAAQ,EAAE;UACbJ,KAAK,GAAG/E,CAAC,CAACsF,SAAS,CAAC7B,CAAC,EAAEC,CAAC,CAAC;QAC3B;QAEAD,CAAC,GAAGC,CAAC;;QAEL;QACA;QACA;QACA,OAAOA,CAAC,GAAG,CAAC,GAAGkB,CAAC,EAAElB,CAAC,EAAE,EAAE;UACrBG,CAAC,GAAG7D,CAAC,CAACqF,UAAU,CAAC3B,CAAC,GAAG,CAAC,CAAC;UAEvB,IAAIG,CAAC,KAAK,EAAE,IAAKA,CAAC,GAAG,EAAE,IAAIA,CAAC,GAAG,CAAE,EAAE;YAAE;YACnC;UACF;;UAEA;UACA,IAAIJ,CAAC,KAAKC,CAAC,EAAE;YACXd,aAAa,CAAC,uCAAuC,CAAC;YACtDuC,QAAQ,GAAG,IAAI;UACjB;QACF;;QAEA;QACA1B,CAAC,GAAGC,CAAC,GAAG,CAAC;QAET,IAAIyB,QAAQ,EAAE;UACZ,SAASC,SAAS;QACpB;;QAEA;QACA,IAAIvC,IAAI,IAAIqC,SAAS,EAAE;UACrBtC,aAAa,CAAC,aAAa,GAAGC,IAAI,GAAG,mBAAmB,CAAC;UACzD;QACF;QAEAqC,SAAS,CAACrC,IAAI,CAAC,GAAG,IAAI;QAEtB,IAAI,CAACL,WAAW,EAAE;UAChByC,KAAK,CAACpC,IAAI,CAAC,GAAGkC,KAAK;UACnB;QACF;;QAEA;QACA,IAAIxC,OAAO,EAAE;UACXuC,QAAQ,GACNjC,IAAI,KAAK,OAAO,GACZ,OAAO,GACNA,IAAI,CAACwC,UAAU,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIxC,IAAI,CAAC0C,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,QAAQ,GAC3D1C,IAAI,CAAC0C,MAAM,CAAC,CAAC,CAAC,GACd,IACP;;UAED;UACA,IAAIT,QAAQ,KAAK,IAAI,EAAE;YACrBP,KAAK,GAAGxE,cAAc,CAACgF,KAAK,CAAC;YAC7BP,WAAW,GAAGrD,SAAS,CAAC2D,QAAQ,CAAC;YAEjCE,KAAK,GAAG3D,aAAa,CAACkD,KAAK,CAAC;YAE5B,IAAI,CAACS,KAAK,EAAE;cAEV;cACA,IACGF,QAAQ,KAAK,OAAO,IACpBN,WAAW,IAAIxD,QAAQ,IAAIA,QAAQ,CAACwD,WAAW,CAAC,KAAKD,KAAM,EAC5D;gBAEA;gBACA,GAAG;kBACDS,KAAK,GAAG,IAAI,GAAI1B,gBAAgB,EAAG;gBACrC,CAAC,QAAQ,OAAOtC,QAAQ,CAACgE,KAAK,CAAC,KAAK,WAAW;cACjD,CAAC,MAAM;gBACLA,KAAK,GAAGF,QAAQ;cAClB;cAEAzD,aAAa,CAACkD,KAAK,CAAC,GAAGS,KAAK;YAC9B;YAEA,IAAIhE,QAAQ,CAAC8D,QAAQ,CAAC,KAAKE,KAAK,EAAE;cAChC,IAAI,CAACH,YAAY,EAAE;gBACjB7D,QAAQ,GAAGD,aAAa,CAACC,QAAQ,CAAC;gBAClC6D,YAAY,GAAG,IAAI;cACrB;cAEA7D,QAAQ,CAAC8D,QAAQ,CAAC,GAAGE,KAAK;cAC1B,IAAIF,QAAQ,KAAK,OAAO,EAAE;gBACxB9D,QAAQ,CAACG,SAAS,CAAC6D,KAAK,CAAC,CAAC,GAAGT,KAAK;gBAClCG,YAAY,GAAGM,KAAK;cACtB;cAEAhE,QAAQ,CAACwD,WAAW,CAAC,GAAGD,KAAK;YAC/B;;YAEA;YACAU,KAAK,CAACpC,IAAI,CAAC,GAAGkC,KAAK;YACnB;UACF;;UAEA;UACA;UACAJ,QAAQ,CAACa,IAAI,CAAC3C,IAAI,EAAEkC,KAAK,CAAC;UAC1B;QAEF,CAAC,CAAC;;QAEF;QACA;QACAlB,CAAC,GAAGhB,IAAI,CAAC3C,OAAO,CAAC,GAAG,CAAC;QACrB,IAAI2D,CAAC,KAAK,CAAC,CAAC,EAAE;UACZoB,KAAK,CAACpC,IAAI,CAAC,GAAGkC,KAAK;UACnB;QACF;;QAEA;QACA,IAAI,EAAEN,MAAM,GAAGzD,QAAQ,CAAC6B,IAAI,CAACyC,SAAS,CAAC,CAAC,EAAEzB,CAAC,CAAC,CAAC,CAAC,EAAE;UAC9CjB,aAAa,CAACjC,yBAAyB,CAACkC,IAAI,CAACyC,SAAS,CAAC,CAAC,EAAEzB,CAAC,CAAC,CAAC,CAAC;UAC9D;QACF;QAEAhB,IAAI,GAAG6B,YAAY,KAAKD,MAAM,GAC1B5B,IAAI,CAAC0C,MAAM,CAAC1B,CAAC,GAAG,CAAC,CAAC,GAClBY,MAAM,GAAG5B,IAAI,CAAC0C,MAAM,CAAC1B,CAAC,CAAC;;QAE3B;;QAEA;QACA,IAAIhB,IAAI,KAAKvC,QAAQ,EAAE;UACrBuD,CAAC,GAAGkB,KAAK,CAAC7E,OAAO,CAAC,GAAG,CAAC;UAEtB,IAAI2D,CAAC,KAAK,CAAC,CAAC,EAAE;YACZY,MAAM,GAAGM,KAAK,CAACO,SAAS,CAAC,CAAC,EAAEzB,CAAC,CAAC;;YAE9B;YACAY,MAAM,GAAGzD,QAAQ,CAACyD,MAAM,CAAC,IAAIA,MAAM;YACnCM,KAAK,GAAGN,MAAM,GAAGM,KAAK,CAACO,SAAS,CAACzB,CAAC,CAAC;UACrC,CAAC,MAAM;YACLkB,KAAK,GAAGL,YAAY,GAAG,GAAG,GAAGK,KAAK;UACpC;QACF;;QAEA;;QAEAE,KAAK,CAACpC,IAAI,CAAC,GAAGkC,KAAK;MACrB;;MAGA;MACA,IAAIxC,OAAO,EAAE;QAEX;QACA,KAAKkB,CAAC,GAAG,CAAC,EAAEmB,CAAC,GAAGD,QAAQ,CAAC1E,MAAM,EAAEwD,CAAC,GAAGmB,CAAC,EAAEnB,CAAC,EAAE,EAAE;UAE3CZ,IAAI,GAAG8B,QAAQ,CAAClB,CAAC,EAAE,CAAC;UACpBsB,KAAK,GAAGJ,QAAQ,CAAClB,CAAC,CAAC;UAEnBI,CAAC,GAAGhB,IAAI,CAAC3C,OAAO,CAAC,GAAG,CAAC;UAErB,IAAI2D,CAAC,KAAK,CAAC,CAAC,EAAE;YAEZ;YACA,IAAI,EAAEY,MAAM,GAAGzD,QAAQ,CAAC6B,IAAI,CAACyC,SAAS,CAAC,CAAC,EAAEzB,CAAC,CAAC,CAAC,CAAC,EAAE;cAC9CjB,aAAa,CAACjC,yBAAyB,CAACkC,IAAI,CAACyC,SAAS,CAAC,CAAC,EAAEzB,CAAC,CAAC,CAAC,CAAC;cAC9D;YACF;YAEAhB,IAAI,GAAG6B,YAAY,KAAKD,MAAM,GAC1B5B,IAAI,CAAC0C,MAAM,CAAC1B,CAAC,GAAG,CAAC,CAAC,GAClBY,MAAM,GAAG5B,IAAI,CAAC0C,MAAM,CAAC1B,CAAC,CAAC;;YAE3B;;YAEA;YACA,IAAIhB,IAAI,KAAKvC,QAAQ,EAAE;cACrBuD,CAAC,GAAGkB,KAAK,CAAC7E,OAAO,CAAC,GAAG,CAAC;cAEtB,IAAI2D,CAAC,KAAK,CAAC,CAAC,EAAE;gBACZY,MAAM,GAAGM,KAAK,CAACO,SAAS,CAAC,CAAC,EAAEzB,CAAC,CAAC;;gBAE9B;gBACAY,MAAM,GAAGzD,QAAQ,CAACyD,MAAM,CAAC,IAAIA,MAAM;gBACnCM,KAAK,GAAGN,MAAM,GAAGM,KAAK,CAACO,SAAS,CAACzB,CAAC,CAAC;cACrC,CAAC,MAAM;gBACLkB,KAAK,GAAGL,YAAY,GAAG,GAAG,GAAGK,KAAK;cACpC;YACF;;YAEA;UACF;;UAEAE,KAAK,CAACpC,IAAI,CAAC,GAAGkC,KAAK;QACrB;;QAEA;MACF;;MAEA,OAAOV,WAAW,GAAGY,KAAK;IAC5B;;IAEA;AACJ;AACA;AACA;AACA;AACA;IACI,SAASQ,eAAeA,CAAA,EAAG;MACzB,IAAIC,QAAQ,GAAG,eAAe;MAE9B,IAAIC,IAAI,GAAG,CAAC;MACZ,IAAIC,MAAM,GAAG,CAAC;MACd,IAAIC,WAAW,GAAG,CAAC;MACnB,IAAIC,SAAS,GAAGpC,CAAC;MACjB,IAAIqC,KAAK;MACT,IAAIC,IAAI;MAER,OAAOvC,CAAC,IAAIoC,WAAW,EAAE;QAEvBE,KAAK,GAAGL,QAAQ,CAACO,IAAI,CAAChD,GAAG,CAAC;QAE1B,IAAI,CAAC8C,KAAK,EAAE;UACV;QACF;;QAEA;QACAD,SAAS,GAAGC,KAAK,CAAC,CAAC,CAAC,CAAC9F,MAAM,GAAG8F,KAAK,CAACG,KAAK;QAEzC,IAAIJ,SAAS,GAAGrC,CAAC,EAAE;UACjB;QACF;;QAEA;QACAkC,IAAI,IAAI,CAAC;QAETE,WAAW,GAAGC,SAAS;MACzB;;MAEA;MACA,IAAIrC,CAAC,IAAI,CAAC,CAAC,EAAE;QACXmC,MAAM,GAAGE,SAAS;QAClBE,IAAI,GAAG/C,GAAG,CAACqC,SAAS,CAAC5B,CAAC,CAAC;MACzB,CAAC;QAED;QACA,IAAIA,CAAC,KAAK,CAAC,EAAE;UACXsC,IAAI,GAAG/C,GAAG,CAACqC,SAAS,CAAC5B,CAAC,EAAED,CAAC,CAAC;QAC5B;;QAEA;QAAA,KACK;UACHmC,MAAM,GAAGnC,CAAC,GAAGoC,WAAW;UACxBG,IAAI,GAAItC,CAAC,IAAI,CAAC,CAAC,GAAGT,GAAG,CAACqC,SAAS,CAAC7B,CAAC,CAAC,GAAGR,GAAG,CAACqC,SAAS,CAAC7B,CAAC,EAAEC,CAAC,GAAG,CAAC,CAAE;QAC/D;MAEA,OAAO;QACL,MAAM,EAAEsC,IAAI;QACZ,MAAM,EAAEL,IAAI;QACZ,QAAQ,EAAEC;MACZ,CAAC;IACH;IAEAtD,UAAU,GAAGmD,eAAe;IAG5B,IAAI7D,KAAK,EAAE;MACTsC,YAAY,GAAGlF,MAAM,CAACmH,MAAM,CAAC,CAAC,CAAC,EAAE;QAC/B,MAAM,EAAEtF,MAAM,CAAC,YAAW;UACxB,OAAOmD,WAAW;QACpB,CAAC,CAAC;QACF,cAAc,EAAEnD,MAAM,CAAC,YAAW;UAChC,OAAOoD,YAAY;QACrB,CAAC,CAAC;QACF,OAAO,EAAEpD,MAAM,CAACyD,QAAQ,CAAC;QACzB,IAAI,EAAEzD,MAAM,CAAC,YAAW;UACtB,OAAOG,QAAQ;QACjB,CAAC;MACH,CAAC,CAAC;IACJ;;IAEA;IACA,OAAO0C,CAAC,KAAK,CAAC,CAAC,EAAE;MAEf,IAAIT,GAAG,CAACoC,UAAU,CAAC3B,CAAC,CAAC,KAAK,EAAE,EAAE;QAAE;QAC9BD,CAAC,GAAGC,CAAC;MACP,CAAC,MAAM;QACLD,CAAC,GAAGR,GAAG,CAAC/C,OAAO,CAAC,GAAG,EAAEwD,CAAC,CAAC;MACzB;;MAEA;MACA,IAAID,CAAC,KAAK,CAAC,CAAC,EAAE;QACZ,IAAIJ,SAAS,CAACpD,MAAM,EAAE;UACpB,OAAO0C,WAAW,CAAC,wBAAwB,CAAC;QAC9C;QAEA,IAAIe,CAAC,KAAK,CAAC,EAAE;UACX,OAAOf,WAAW,CAAC,mBAAmB,CAAC;QACzC;QAEA,IAAIe,CAAC,GAAGT,GAAG,CAAChD,MAAM,EAAE;UAClB,IAAIgD,GAAG,CAACqC,SAAS,CAAC5B,CAAC,CAAC,CAAC0C,IAAI,EAAE,EAAE;YAC3BxD,aAAa,CAACrC,gCAAgC,CAAC;UACjD;QACF;QAEA;MACF;;MAEA;MACA,IAAImD,CAAC,KAAKD,CAAC,EAAE;QAEX,IAAIJ,SAAS,CAACpD,MAAM,EAAE;UACpB,IAAI4B,MAAM,EAAE;YACVA,MAAM,CAACoB,GAAG,CAACqC,SAAS,CAAC5B,CAAC,EAAED,CAAC,CAAC,EAAE1D,cAAc,EAAEuC,UAAU,CAAC;YAEvD,IAAII,SAAS,EAAE;cACb;YACF;UACF;QACF,CAAC,MAAM;UACL,IAAIO,GAAG,CAACqC,SAAS,CAAC5B,CAAC,EAAED,CAAC,CAAC,CAAC2C,IAAI,EAAE,EAAE;YAC9BxD,aAAa,CAACrC,gCAAgC,CAAC;YAE/C,IAAImC,SAAS,EAAE;cACb;YACF;UACF;QACF;MACF;MAEAmB,CAAC,GAAGZ,GAAG,CAACoC,UAAU,CAAC5B,CAAC,GAAC,CAAC,CAAC;;MAEvB;MACA,IAAII,CAAC,KAAK,EAAE,EAAE;QAAE;QACdD,CAAC,GAAGX,GAAG,CAACoC,UAAU,CAAC5B,CAAC,GAAC,CAAC,CAAC;;QAEvB;QACA,IAAIG,CAAC,KAAK,EAAE,IAAIX,GAAG,CAACsC,MAAM,CAAC9B,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,KAAK,QAAQ,EAAE;UAAE;UACnDC,CAAC,GAAGT,GAAG,CAAC/C,OAAO,CAAC,KAAK,EAAEuD,CAAC,CAAC;UACzB,IAAIC,CAAC,KAAK,CAAC,CAAC,EAAE;YACZ,OAAOf,WAAW,CAAC,gBAAgB,CAAC;UACtC;UAEA,IAAIX,OAAO,EAAE;YACXA,OAAO,CAACiB,GAAG,CAACqC,SAAS,CAAC7B,CAAC,GAAG,CAAC,EAAEC,CAAC,CAAC,EAAEpB,UAAU,CAAC;YAC5C,IAAII,SAAS,EAAE;cACb;YACF;UACF;UAEAgB,CAAC,IAAI,CAAC;UACN;QACF;;QAEA;QACA,IAAIE,CAAC,KAAK,EAAE,IAAIX,GAAG,CAACoC,UAAU,CAAC5B,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;UAAE;UAC9CC,CAAC,GAAGT,GAAG,CAAC/C,OAAO,CAAC,KAAK,EAAEuD,CAAC,CAAC;UACzB,IAAIC,CAAC,KAAK,CAAC,CAAC,EAAE;YACZ,OAAOf,WAAW,CAAC,kBAAkB,CAAC;UACxC;UAGA,IAAIR,SAAS,EAAE;YACbA,SAAS,CAACc,GAAG,CAACqC,SAAS,CAAC7B,CAAC,GAAG,CAAC,EAAEC,CAAC,CAAC,EAAE3D,cAAc,EAAEuC,UAAU,CAAC;YAC9D,IAAII,SAAS,EAAE;cACb;YACF;UACF;UAEAgB,CAAC,IAAI,CAAC;UACN;QACF;MACF;;MAEA;MACA,IAAIG,CAAC,KAAK,EAAE,EAAE;QAAE;QACdH,CAAC,GAAGT,GAAG,CAAC/C,OAAO,CAAC,IAAI,EAAEuD,CAAC,CAAC;QACxB,IAAIC,CAAC,KAAK,CAAC,CAAC,EAAE;UACZ,OAAOf,WAAW,CAAC,mBAAmB,CAAC;QACzC;QAEA,IAAIP,UAAU,EAAE;UACdA,UAAU,CAACa,GAAG,CAACqC,SAAS,CAAC7B,CAAC,EAAEC,CAAC,GAAG,CAAC,CAAC,EAAEpB,UAAU,CAAC;UAC/C,IAAII,SAAS,EAAE;YACb;UACF;QACF;QAEAgB,CAAC,IAAI,CAAC;QACN;MACF;;MAEA;MACA;MACA;MACA,KAAK/D,CAAC,GAAG8D,CAAC,GAAG,CAAC,GAAI9D,CAAC,EAAE,EAAE;QACrBmE,CAAC,GAAGb,GAAG,CAACoC,UAAU,CAAC1F,CAAC,CAAC;QACrB,IAAI0G,KAAK,CAACvC,CAAC,CAAC,EAAE;UACZJ,CAAC,GAAG,CAAC,CAAC;UACN,OAAOf,WAAW,CAAC,cAAc,CAAC;QACpC;;QAEA;QACA;QACA;QACA;QACA,IAAImB,CAAC,KAAK,EAAE,EAAE;UAAE;UACdF,CAAC,GAAGX,GAAG,CAAC/C,OAAO,CAAC,GAAG,EAAEP,CAAC,GAAG,CAAC,CAAC;UAC3BA,CAAC,GAAGiE,CAAC,KAAK,CAAC,CAAC,GAAGA,CAAC,GAAGjE,CAAC;QACtB,CAAC,MAAM,IAAImE,CAAC,KAAK,EAAE,EAAE;UAAE;UACrBF,CAAC,GAAGX,GAAG,CAAC/C,OAAO,CAAC,GAAG,EAAEP,CAAC,GAAG,CAAC,CAAC;UAC3BA,CAAC,GAAGiE,CAAC,KAAK,CAAC,CAAC,GAAGA,CAAC,GAAGjE,CAAC;QACtB,CAAC,MAAM,IAAImE,CAAC,KAAK,EAAE,EAAE;UAAE;UACrBJ,CAAC,GAAG/D,CAAC;UACL;QACF;MACF;;MAGA;MACA;MACA,IAAIkE,CAAC,KAAK,EAAE,EAAE;QAAE;;QAEd,IAAIxB,WAAW,EAAE;UACfA,WAAW,CAACY,GAAG,CAACqC,SAAS,CAAC7B,CAAC,EAAEC,CAAC,GAAG,CAAC,CAAC,EAAE3D,cAAc,EAAEuC,UAAU,CAAC;UAChE,IAAII,SAAS,EAAE;YACb;UACF;QACF;QAEAgB,CAAC,IAAI,CAAC;QACN;MACF;;MAEA;MACA;MACAW,WAAW,GAAG,CAAC,CAAC;;MAEhB;MACA,IAAIR,CAAC,KAAK,EAAE,EAAE;QAAE;QACdN,QAAQ,GAAG,KAAK;QAChBC,MAAM,GAAG,IAAI;QAEb,IAAI,CAACH,SAAS,CAACpD,MAAM,EAAE;UACrB,OAAO0C,WAAW,CAAC,kBAAkB,CAAC;QACxC;;QAEA;QACAhD,CAAC,GAAGqE,WAAW,GAAGX,SAAS,CAACiD,GAAG,EAAE;QACjC1C,CAAC,GAAGH,CAAC,GAAG,CAAC,GAAG9D,CAAC,CAACM,MAAM;QAEpB,IAAIgD,GAAG,CAACqC,SAAS,CAAC7B,CAAC,GAAG,CAAC,EAAEG,CAAC,CAAC,KAAKjE,CAAC,EAAE;UACjC,OAAOgD,WAAW,CAAC,sBAAsB,CAAC;QAC5C;;QAEA;QACA,OAAOiB,CAAC,GAAGF,CAAC,EAAEE,CAAC,EAAE,EAAE;UACjBC,CAAC,GAAGZ,GAAG,CAACoC,UAAU,CAACzB,CAAC,CAAC;UAErB,IAAIC,CAAC,KAAK,EAAE,IAAKA,CAAC,GAAG,CAAC,IAAIA,CAAC,GAAG,EAAG,EAAE;YAAE;YACnC;UACF;UAEA,OAAOlB,WAAW,CAAC,WAAW,CAAC;QACjC;MAEF,CAAC,MAAM;QACL,IAAIM,GAAG,CAACoC,UAAU,CAAC3B,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;UAAE;UAClC/D,CAAC,GAAGqE,WAAW,GAAGf,GAAG,CAACqC,SAAS,CAAC7B,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,CAAC;UAE7CH,QAAQ,GAAG,IAAI;UACfC,MAAM,GAAG,IAAI;QAEf,CAAC,MAAM;UACL7D,CAAC,GAAGqE,WAAW,GAAGf,GAAG,CAACqC,SAAS,CAAC7B,CAAC,GAAG,CAAC,EAAEC,CAAC,CAAC;UAEzCH,QAAQ,GAAG,IAAI;UACfC,MAAM,GAAG,KAAK;QAChB;QAEA,IAAI,EAAEK,CAAC,GAAG,EAAE,IAAIA,CAAC,GAAG,GAAG,IAAIA,CAAC,GAAG,EAAE,IAAIA,CAAC,GAAG,EAAE,IAAIA,CAAC,KAAK,EAAE,IAAIA,CAAC,KAAK,EAAE,CAAC,EAAE;UAAE;UACtE,OAAOlB,WAAW,CAAC,6BAA6B,CAAC;QACnD;QAEA,KAAKiB,CAAC,GAAG,CAAC,EAAED,CAAC,GAAGhE,CAAC,CAACM,MAAM,EAAE2D,CAAC,GAAGD,CAAC,EAAEC,CAAC,EAAE,EAAE;UACpCC,CAAC,GAAGlE,CAAC,CAAC0F,UAAU,CAACzB,CAAC,CAAC;UAEnB,IAAIC,CAAC,GAAG,EAAE,IAAIA,CAAC,GAAG,GAAG,IAAIA,CAAC,GAAG,EAAE,IAAIA,CAAC,GAAG,EAAE,IAAIA,CAAC,GAAG,EAAE,IAAIA,CAAC,GAAG,EAAE,IAAIA,CAAC,KAAK,EAAE,IAAIA,CAAC,KAAK,EAAE,IAAIA,CAAC,IAAI,EAAE,EAAE;YAChG;UACF;UAEA,IAAIA,CAAC,KAAK,EAAE,IAAKA,CAAC,GAAG,EAAE,IAAIA,CAAC,GAAG,CAAE,EAAE;YAAE;YACnCG,WAAW,GAAGrE,CAAC,CAAC2F,SAAS,CAAC,CAAC,EAAE1B,CAAC,CAAC;;YAE/B;YACAS,WAAW,GAAG,IAAI;YAClB;UACF;UAEA,OAAO1B,WAAW,CAAC,kBAAkB,CAAC;QACxC;QAEA,IAAI,CAACa,MAAM,EAAE;UACXH,SAAS,CAACmC,IAAI,CAACxB,WAAW,CAAC;QAC7B;MACF;MAEA,IAAIxB,WAAW,EAAE;QAEfY,SAAS,GAAGpC,QAAQ;QAEpB,IAAIuC,QAAQ,EAAE;UAEZ;UACA;UACA,IAAI,CAACC,MAAM,EAAE;YACXL,aAAa,CAACqC,IAAI,CAACpC,SAAS,CAAC;UAC/B;UAEA,IAAIiB,WAAW,KAAK,IAAI,EAAE;YAExB;YACA;YACA;YACA,IAAK9B,OAAO,GAAG5C,CAAC,CAACO,OAAO,CAAC,OAAO,EAAE0D,CAAC,CAAC,KAAK,CAAC,CAAC,EAAG;cAC5CQ,UAAU,GAAGR,CAAC;cACdO,WAAW,GAAGxE,CAAC;cAEf2E,QAAQ,EAAE;cAEV/B,OAAO,GAAG,KAAK;YACjB;UACF;QACF;QAEA0B,YAAY,GAAGD,WAAW;QAE1BH,CAAC,GAAGG,WAAW,CAAC9D,OAAO,CAAC,GAAG,CAAC;QAC5B,IAAI2D,CAAC,KAAK,CAAC,CAAC,EAAE;UACZE,KAAK,GAAG/C,QAAQ,CAACgD,WAAW,CAACsB,SAAS,CAAC,CAAC,EAAEzB,CAAC,CAAC,CAAC;;UAE7C;UACA,IAAI,CAACE,KAAK,EAAE;YACV,OAAOpB,WAAW,CAAC,wBAAwB,GAAGsB,YAAY,GAAG,GAAG,CAAC;UACnE;UAEAD,WAAW,GAAGA,WAAW,CAACuB,MAAM,CAAC1B,CAAC,GAAG,CAAC,CAAC;QACzC,CAAC,MAAM;UACLE,KAAK,GAAG/C,QAAQ,CAAC,OAAO,CAAC;;UAEzB;UACA;UACA;UACA;UACA;UACA;QACF;;QAEA;QACA,IAAI+C,KAAK,EAAE;UACTC,WAAW,GAAGD,KAAK,GAAG,GAAG,GAAGC,WAAW;QACzC;MAEF;MAEA,IAAIT,QAAQ,EAAE;QACZa,UAAU,GAAGR,CAAC;QACdO,WAAW,GAAGxE,CAAC;QAEf,IAAImC,SAAS,EAAE;UACb,IAAIF,KAAK,EAAE;YACTE,SAAS,CAACoC,YAAY,EAAEnE,cAAc,EAAEyD,MAAM,EAAElB,UAAU,CAAC;UAC7D,CAAC,MAAM;YACLR,SAAS,CAACkC,WAAW,EAAEM,QAAQ,EAAEvE,cAAc,EAAEyD,MAAM,EAAElB,UAAU,CAAC;UACtE;UAEA,IAAII,SAAS,EAAE;YACb;UACF;QACF;MAEF;MAEA,IAAIc,MAAM,EAAE;QAEV,IAAIzB,UAAU,EAAE;UACdA,UAAU,CAACH,KAAK,GAAGsC,YAAY,GAAGF,WAAW,EAAEjE,cAAc,EAAEwD,QAAQ,EAAEjB,UAAU,CAAC;UAEpF,IAAII,SAAS,EAAE;YACb;UACF;QACF;;QAEA;QACA,IAAIF,WAAW,EAAE;UACf,IAAI,CAACe,QAAQ,EAAE;YACbvC,QAAQ,GAAGmC,aAAa,CAACmD,GAAG,EAAE;UAChC,CAAC,MAAM;YACLtF,QAAQ,GAAGoC,SAAS;UACtB;QACF;MACF;MAEAM,CAAC,IAAI,CAAC;IACR;EACF,CAAC,CAAC;AAEJ;;AAEA,SAAShC,MAAM,EAAE3B,cAAc,IAAIwG,MAAM"},"metadata":{},"sourceType":"module"}