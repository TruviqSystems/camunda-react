{"ast":null,"code":"import { every, isArray } from 'min-dash';\n\n/**\r\n * Computes the distance between two points\r\n *\r\n * @param  {Point}  p\r\n * @param  {Point}  q\r\n *\r\n * @return {number}  distance\r\n */\nexport function pointDistance(a, b) {\n  if (!a || !b) {\n    return -1;\n  }\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n}\n\n/**\r\n * Returns true if the point r is on the line between p and q\r\n *\r\n * @param  {Point}  p\r\n * @param  {Point}  q\r\n * @param  {Point}  r\r\n * @param  {number} [accuracy=5] accuracy for points on line check (lower is better)\r\n *\r\n * @return {boolean}\r\n */\nexport function pointsOnLine(p, q, r, accuracy) {\n  if (typeof accuracy === 'undefined') {\n    accuracy = 5;\n  }\n  if (!p || !q || !r) {\n    return false;\n  }\n  var val = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x),\n    dist = pointDistance(p, q);\n\n  // @see http://stackoverflow.com/a/907491/412190\n  return Math.abs(val / dist) <= accuracy;\n}\nvar ALIGNED_THRESHOLD = 2;\n\n/**\r\n * Check whether two points are horizontally or vertically aligned.\r\n *\r\n * @param {Array<Point>|Point}\r\n * @param {Point}\r\n *\r\n * @return {string|boolean}\r\n */\nexport function pointsAligned(a, b) {\n  var points;\n  if (isArray(a)) {\n    points = a;\n  } else {\n    points = [a, b];\n  }\n  if (pointsAlignedHorizontally(points)) {\n    return 'h';\n  }\n  if (pointsAlignedVertically(points)) {\n    return 'v';\n  }\n  return false;\n}\nexport function pointsAlignedHorizontally(a, b) {\n  var points;\n  if (isArray(a)) {\n    points = a;\n  } else {\n    points = [a, b];\n  }\n  var firstPoint = points.slice().shift();\n  return every(points, function (point) {\n    return Math.abs(firstPoint.y - point.y) <= ALIGNED_THRESHOLD;\n  });\n}\nexport function pointsAlignedVertically(a, b) {\n  var points;\n  if (isArray(a)) {\n    points = a;\n  } else {\n    points = [a, b];\n  }\n  var firstPoint = points.slice().shift();\n  return every(points, function (point) {\n    return Math.abs(firstPoint.x - point.x) <= ALIGNED_THRESHOLD;\n  });\n}\n\n/**\r\n * Returns true if the point p is inside the rectangle rect\r\n *\r\n * @param  {Point}  p\r\n * @param  {Rect} rect\r\n * @param  {number} tolerance\r\n *\r\n * @return {boolean}\r\n */\nexport function pointInRect(p, rect, tolerance) {\n  tolerance = tolerance || 0;\n  return p.x > rect.x - tolerance && p.y > rect.y - tolerance && p.x < rect.x + rect.width + tolerance && p.y < rect.y + rect.height + tolerance;\n}\n\n/**\r\n * Returns a point in the middle of points p and q\r\n *\r\n * @param  {Point}  p\r\n * @param  {Point}  q\r\n *\r\n * @return {Point} middle point\r\n */\nexport function getMidPoint(p, q) {\n  return {\n    x: Math.round(p.x + (q.x - p.x) / 2.0),\n    y: Math.round(p.y + (q.y - p.y) / 2.0)\n  };\n}","map":{"version":3,"names":["every","isArray","pointDistance","a","b","Math","sqrt","pow","x","y","pointsOnLine","p","q","r","accuracy","val","dist","abs","ALIGNED_THRESHOLD","pointsAligned","points","pointsAlignedHorizontally","pointsAlignedVertically","firstPoint","slice","shift","point","pointInRect","rect","tolerance","width","height","getMidPoint","round"],"sources":["C:/Users/sam/final/camunda-react/node_modules/diagram-js/lib/util/Geometry.js"],"sourcesContent":["import {\r\n  every,\r\n  isArray\r\n} from 'min-dash';\r\n\r\n/**\r\n * Computes the distance between two points\r\n *\r\n * @param  {Point}  p\r\n * @param  {Point}  q\r\n *\r\n * @return {number}  distance\r\n */\r\nexport function pointDistance(a, b) {\r\n  if (!a || !b) {\r\n    return -1;\r\n  }\r\n\r\n  return Math.sqrt(\r\n    Math.pow(a.x - b.x, 2) +\r\n    Math.pow(a.y - b.y, 2)\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * Returns true if the point r is on the line between p and q\r\n *\r\n * @param  {Point}  p\r\n * @param  {Point}  q\r\n * @param  {Point}  r\r\n * @param  {number} [accuracy=5] accuracy for points on line check (lower is better)\r\n *\r\n * @return {boolean}\r\n */\r\nexport function pointsOnLine(p, q, r, accuracy) {\r\n\r\n  if (typeof accuracy === 'undefined') {\r\n    accuracy = 5;\r\n  }\r\n\r\n  if (!p || !q || !r) {\r\n    return false;\r\n  }\r\n\r\n  var val = (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x),\r\n      dist = pointDistance(p, q);\r\n\r\n  // @see http://stackoverflow.com/a/907491/412190\r\n  return Math.abs(val / dist) <= accuracy;\r\n}\r\n\r\n\r\nvar ALIGNED_THRESHOLD = 2;\r\n\r\n/**\r\n * Check whether two points are horizontally or vertically aligned.\r\n *\r\n * @param {Array<Point>|Point}\r\n * @param {Point}\r\n *\r\n * @return {string|boolean}\r\n */\r\nexport function pointsAligned(a, b) {\r\n  var points;\r\n\r\n  if (isArray(a)) {\r\n    points = a;\r\n  } else {\r\n    points = [ a, b ];\r\n  }\r\n\r\n  if (pointsAlignedHorizontally(points)) {\r\n    return 'h';\r\n  }\r\n\r\n  if (pointsAlignedVertically(points)) {\r\n    return 'v';\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport function pointsAlignedHorizontally(a, b) {\r\n  var points;\r\n\r\n  if (isArray(a)) {\r\n    points = a;\r\n  } else {\r\n    points = [ a, b ];\r\n  }\r\n\r\n  var firstPoint = points.slice().shift();\r\n\r\n  return every(points, function(point) {\r\n    return Math.abs(firstPoint.y - point.y) <= ALIGNED_THRESHOLD;\r\n  });\r\n}\r\n\r\nexport function pointsAlignedVertically(a, b) {\r\n  var points;\r\n\r\n  if (isArray(a)) {\r\n    points = a;\r\n  } else {\r\n    points = [ a, b ];\r\n  }\r\n\r\n  var firstPoint = points.slice().shift();\r\n\r\n  return every(points, function(point) {\r\n    return Math.abs(firstPoint.x - point.x) <= ALIGNED_THRESHOLD;\r\n  });\r\n}\r\n\r\n\r\n\r\n/**\r\n * Returns true if the point p is inside the rectangle rect\r\n *\r\n * @param  {Point}  p\r\n * @param  {Rect} rect\r\n * @param  {number} tolerance\r\n *\r\n * @return {boolean}\r\n */\r\nexport function pointInRect(p, rect, tolerance) {\r\n  tolerance = tolerance || 0;\r\n\r\n  return p.x > rect.x - tolerance &&\r\n         p.y > rect.y - tolerance &&\r\n         p.x < rect.x + rect.width + tolerance &&\r\n         p.y < rect.y + rect.height + tolerance;\r\n}\r\n\r\n/**\r\n * Returns a point in the middle of points p and q\r\n *\r\n * @param  {Point}  p\r\n * @param  {Point}  q\r\n *\r\n * @return {Point} middle point\r\n */\r\nexport function getMidPoint(p, q) {\r\n  return {\r\n    x: Math.round(p.x + ((q.x - p.x) / 2.0)),\r\n    y: Math.round(p.y + ((q.y - p.y) / 2.0))\r\n  };\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}