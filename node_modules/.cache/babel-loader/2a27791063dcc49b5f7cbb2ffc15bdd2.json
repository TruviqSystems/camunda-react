{"ast":null,"code":"'use strict';\n\nvar Collection = require('./collection');\nfunction hasOwnProperty(e, property) {\n  return Object.prototype.hasOwnProperty.call(e, property.name || property);\n}\nfunction defineCollectionProperty(ref, property, target) {\n  var collection = Collection.extend(target[property.name] || [], ref, property, target);\n  Object.defineProperty(target, property.name, {\n    enumerable: property.enumerable,\n    value: collection\n  });\n  if (collection.length) {\n    collection.forEach(function (o) {\n      ref.set(o, property.inverse, target);\n    });\n  }\n}\nfunction defineProperty(ref, property, target) {\n  var inverseProperty = property.inverse;\n  var _value = target[property.name];\n  Object.defineProperty(target, property.name, {\n    configurable: property.configurable,\n    enumerable: property.enumerable,\n    get: function () {\n      return _value;\n    },\n    set: function (value) {\n      // return if we already performed all changes\n      if (value === _value) {\n        return;\n      }\n      var old = _value;\n\n      // temporary set null\n      _value = null;\n      if (old) {\n        ref.unset(old, inverseProperty, target);\n      }\n\n      // set new value\n      _value = value;\n\n      // set inverse value\n      ref.set(_value, inverseProperty, target);\n    }\n  });\n}\n\n/**\r\n * Creates a new references object defining two inversly related\r\n * attribute descriptors a and b.\r\n *\r\n * <p>\r\n *   When bound to an object using {@link Refs#bind} the references\r\n *   get activated and ensure that add and remove operations are applied\r\n *   reversely, too.\r\n * </p>\r\n *\r\n * <p>\r\n *   For attributes represented as collections {@link Refs} provides the\r\n *   {@link RefsCollection#add}, {@link RefsCollection#remove} and {@link RefsCollection#contains} extensions\r\n *   that must be used to properly hook into the inverse change mechanism.\r\n * </p>\r\n *\r\n * @class Refs\r\n *\r\n * @classdesc A bi-directional reference between two attributes.\r\n *\r\n * @param {Refs.AttributeDescriptor} a property descriptor\r\n * @param {Refs.AttributeDescriptor} b property descriptor\r\n *\r\n * @example\r\n *\r\n * var refs = Refs({ name: 'wheels', collection: true, enumerable: true }, { name: 'car' });\r\n *\r\n * var car = { name: 'toyota' };\r\n * var wheels = [{ pos: 'front-left' }, { pos: 'front-right' }];\r\n *\r\n * refs.bind(car, 'wheels');\r\n *\r\n * car.wheels // []\r\n * car.wheels.add(wheels[0]);\r\n * car.wheels.add(wheels[1]);\r\n *\r\n * car.wheels // [{ pos: 'front-left' }, { pos: 'front-right' }]\r\n *\r\n * wheels[0].car // { name: 'toyota' };\r\n * car.wheels.remove(wheels[0]);\r\n *\r\n * wheels[0].car // undefined\r\n */\nfunction Refs(a, b) {\n  if (!(this instanceof Refs)) {\n    return new Refs(a, b);\n  }\n\n  // link\n  a.inverse = b;\n  b.inverse = a;\n  this.props = {};\n  this.props[a.name] = a;\n  this.props[b.name] = b;\n}\n\n/**\r\n * Binds one side of a bi-directional reference to a\r\n * target object.\r\n *\r\n * @memberOf Refs\r\n *\r\n * @param  {Object} target\r\n * @param  {String} property\r\n */\nRefs.prototype.bind = function (target, property) {\n  if (typeof property === 'string') {\n    if (!this.props[property]) {\n      throw new Error('no property <' + property + '> in ref');\n    }\n    property = this.props[property];\n  }\n  if (property.collection) {\n    defineCollectionProperty(this, property, target);\n  } else {\n    defineProperty(this, property, target);\n  }\n};\nRefs.prototype.ensureRefsCollection = function (target, property) {\n  var collection = target[property.name];\n  if (!Collection.isExtended(collection)) {\n    defineCollectionProperty(this, property, target);\n  }\n  return collection;\n};\nRefs.prototype.ensureBound = function (target, property) {\n  if (!hasOwnProperty(target, property)) {\n    this.bind(target, property);\n  }\n};\nRefs.prototype.unset = function (target, property, value) {\n  if (target) {\n    this.ensureBound(target, property);\n    if (property.collection) {\n      this.ensureRefsCollection(target, property).remove(value);\n    } else {\n      target[property.name] = undefined;\n    }\n  }\n};\nRefs.prototype.set = function (target, property, value) {\n  if (target) {\n    this.ensureBound(target, property);\n    if (property.collection) {\n      this.ensureRefsCollection(target, property).add(value);\n    } else {\n      target[property.name] = value;\n    }\n  }\n};\nmodule.exports = Refs;\n\n/**\r\n * An attribute descriptor to be used specify an attribute in a {@link Refs} instance\r\n *\r\n * @typedef {Object} Refs.AttributeDescriptor\r\n * @property {String} name\r\n * @property {boolean} [collection=false]\r\n * @property {boolean} [enumerable=false]\r\n */","map":{"version":3,"names":["Collection","require","hasOwnProperty","e","property","Object","prototype","call","name","defineCollectionProperty","ref","target","collection","extend","defineProperty","enumerable","value","length","forEach","o","set","inverse","inverseProperty","_value","configurable","get","old","unset","Refs","a","b","props","bind","Error","ensureRefsCollection","isExtended","ensureBound","remove","undefined","add","module","exports"],"sources":["C:/Users/sam/final/camunda-react/node_modules/object-refs/lib/refs.js"],"sourcesContent":["'use strict';\r\n\r\nvar Collection = require('./collection');\r\n\r\nfunction hasOwnProperty(e, property) {\r\n  return Object.prototype.hasOwnProperty.call(e, property.name || property);\r\n}\r\n\r\nfunction defineCollectionProperty(ref, property, target) {\r\n\r\n  var collection = Collection.extend(target[property.name] || [], ref, property, target);\r\n\r\n  Object.defineProperty(target, property.name, {\r\n    enumerable: property.enumerable,\r\n    value: collection\r\n  });\r\n\r\n  if (collection.length) {\r\n\r\n    collection.forEach(function(o) {\r\n      ref.set(o, property.inverse, target);\r\n    });\r\n  }\r\n}\r\n\r\n\r\nfunction defineProperty(ref, property, target) {\r\n\r\n  var inverseProperty = property.inverse;\r\n\r\n  var _value = target[property.name];\r\n\r\n  Object.defineProperty(target, property.name, {\r\n    configurable: property.configurable,\r\n    enumerable: property.enumerable,\r\n\r\n    get: function() {\r\n      return _value;\r\n    },\r\n\r\n    set: function(value) {\r\n\r\n      // return if we already performed all changes\r\n      if (value === _value) {\r\n        return;\r\n      }\r\n\r\n      var old = _value;\r\n\r\n      // temporary set null\r\n      _value = null;\r\n\r\n      if (old) {\r\n        ref.unset(old, inverseProperty, target);\r\n      }\r\n\r\n      // set new value\r\n      _value = value;\r\n\r\n      // set inverse value\r\n      ref.set(_value, inverseProperty, target);\r\n    }\r\n  });\r\n\r\n}\r\n\r\n/**\r\n * Creates a new references object defining two inversly related\r\n * attribute descriptors a and b.\r\n *\r\n * <p>\r\n *   When bound to an object using {@link Refs#bind} the references\r\n *   get activated and ensure that add and remove operations are applied\r\n *   reversely, too.\r\n * </p>\r\n *\r\n * <p>\r\n *   For attributes represented as collections {@link Refs} provides the\r\n *   {@link RefsCollection#add}, {@link RefsCollection#remove} and {@link RefsCollection#contains} extensions\r\n *   that must be used to properly hook into the inverse change mechanism.\r\n * </p>\r\n *\r\n * @class Refs\r\n *\r\n * @classdesc A bi-directional reference between two attributes.\r\n *\r\n * @param {Refs.AttributeDescriptor} a property descriptor\r\n * @param {Refs.AttributeDescriptor} b property descriptor\r\n *\r\n * @example\r\n *\r\n * var refs = Refs({ name: 'wheels', collection: true, enumerable: true }, { name: 'car' });\r\n *\r\n * var car = { name: 'toyota' };\r\n * var wheels = [{ pos: 'front-left' }, { pos: 'front-right' }];\r\n *\r\n * refs.bind(car, 'wheels');\r\n *\r\n * car.wheels // []\r\n * car.wheels.add(wheels[0]);\r\n * car.wheels.add(wheels[1]);\r\n *\r\n * car.wheels // [{ pos: 'front-left' }, { pos: 'front-right' }]\r\n *\r\n * wheels[0].car // { name: 'toyota' };\r\n * car.wheels.remove(wheels[0]);\r\n *\r\n * wheels[0].car // undefined\r\n */\r\nfunction Refs(a, b) {\r\n\r\n  if (!(this instanceof Refs)) {\r\n    return new Refs(a, b);\r\n  }\r\n\r\n  // link\r\n  a.inverse = b;\r\n  b.inverse = a;\r\n\r\n  this.props = {};\r\n  this.props[a.name] = a;\r\n  this.props[b.name] = b;\r\n}\r\n\r\n/**\r\n * Binds one side of a bi-directional reference to a\r\n * target object.\r\n *\r\n * @memberOf Refs\r\n *\r\n * @param  {Object} target\r\n * @param  {String} property\r\n */\r\nRefs.prototype.bind = function(target, property) {\r\n  if (typeof property === 'string') {\r\n    if (!this.props[property]) {\r\n      throw new Error('no property <' + property + '> in ref');\r\n    }\r\n    property = this.props[property];\r\n  }\r\n\r\n  if (property.collection) {\r\n    defineCollectionProperty(this, property, target);\r\n  } else {\r\n    defineProperty(this, property, target);\r\n  }\r\n};\r\n\r\nRefs.prototype.ensureRefsCollection = function(target, property) {\r\n\r\n  var collection = target[property.name];\r\n\r\n  if (!Collection.isExtended(collection)) {\r\n    defineCollectionProperty(this, property, target);\r\n  }\r\n\r\n  return collection;\r\n};\r\n\r\nRefs.prototype.ensureBound = function(target, property) {\r\n  if (!hasOwnProperty(target, property)) {\r\n    this.bind(target, property);\r\n  }\r\n};\r\n\r\nRefs.prototype.unset = function(target, property, value) {\r\n\r\n  if (target) {\r\n    this.ensureBound(target, property);\r\n\r\n    if (property.collection) {\r\n      this.ensureRefsCollection(target, property).remove(value);\r\n    } else {\r\n      target[property.name] = undefined;\r\n    }\r\n  }\r\n};\r\n\r\nRefs.prototype.set = function(target, property, value) {\r\n\r\n  if (target) {\r\n    this.ensureBound(target, property);\r\n\r\n    if (property.collection) {\r\n      this.ensureRefsCollection(target, property).add(value);\r\n    } else {\r\n      target[property.name] = value;\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports = Refs;\r\n\r\n\r\n/**\r\n * An attribute descriptor to be used specify an attribute in a {@link Refs} instance\r\n *\r\n * @typedef {Object} Refs.AttributeDescriptor\r\n * @property {String} name\r\n * @property {boolean} [collection=false]\r\n * @property {boolean} [enumerable=false]\r\n */"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,UAAU,GAAGC,OAAO,CAAC,cAAc,CAAC;AAExC,SAASC,cAAcA,CAACC,CAAC,EAAEC,QAAQ,EAAE;EACnC,OAAOC,MAAM,CAACC,SAAS,CAACJ,cAAc,CAACK,IAAI,CAACJ,CAAC,EAAEC,QAAQ,CAACI,IAAI,IAAIJ,QAAQ,CAAC;AAC3E;AAEA,SAASK,wBAAwBA,CAACC,GAAG,EAAEN,QAAQ,EAAEO,MAAM,EAAE;EAEvD,IAAIC,UAAU,GAAGZ,UAAU,CAACa,MAAM,CAACF,MAAM,CAACP,QAAQ,CAACI,IAAI,CAAC,IAAI,EAAE,EAAEE,GAAG,EAAEN,QAAQ,EAAEO,MAAM,CAAC;EAEtFN,MAAM,CAACS,cAAc,CAACH,MAAM,EAAEP,QAAQ,CAACI,IAAI,EAAE;IAC3CO,UAAU,EAAEX,QAAQ,CAACW,UAAU;IAC/BC,KAAK,EAAEJ;EACT,CAAC,CAAC;EAEF,IAAIA,UAAU,CAACK,MAAM,EAAE;IAErBL,UAAU,CAACM,OAAO,CAAC,UAASC,CAAC,EAAE;MAC7BT,GAAG,CAACU,GAAG,CAACD,CAAC,EAAEf,QAAQ,CAACiB,OAAO,EAAEV,MAAM,CAAC;IACtC,CAAC,CAAC;EACJ;AACF;AAGA,SAASG,cAAcA,CAACJ,GAAG,EAAEN,QAAQ,EAAEO,MAAM,EAAE;EAE7C,IAAIW,eAAe,GAAGlB,QAAQ,CAACiB,OAAO;EAEtC,IAAIE,MAAM,GAAGZ,MAAM,CAACP,QAAQ,CAACI,IAAI,CAAC;EAElCH,MAAM,CAACS,cAAc,CAACH,MAAM,EAAEP,QAAQ,CAACI,IAAI,EAAE;IAC3CgB,YAAY,EAAEpB,QAAQ,CAACoB,YAAY;IACnCT,UAAU,EAAEX,QAAQ,CAACW,UAAU;IAE/BU,GAAG,EAAE,SAAAA,CAAA,EAAW;MACd,OAAOF,MAAM;IACf,CAAC;IAEDH,GAAG,EAAE,SAAAA,CAASJ,KAAK,EAAE;MAEnB;MACA,IAAIA,KAAK,KAAKO,MAAM,EAAE;QACpB;MACF;MAEA,IAAIG,GAAG,GAAGH,MAAM;;MAEhB;MACAA,MAAM,GAAG,IAAI;MAEb,IAAIG,GAAG,EAAE;QACPhB,GAAG,CAACiB,KAAK,CAACD,GAAG,EAAEJ,eAAe,EAAEX,MAAM,CAAC;MACzC;;MAEA;MACAY,MAAM,GAAGP,KAAK;;MAEd;MACAN,GAAG,CAACU,GAAG,CAACG,MAAM,EAAED,eAAe,EAAEX,MAAM,CAAC;IAC1C;EACF,CAAC,CAAC;AAEJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASiB,IAAIA,CAACC,CAAC,EAAEC,CAAC,EAAE;EAElB,IAAI,EAAE,IAAI,YAAYF,IAAI,CAAC,EAAE;IAC3B,OAAO,IAAIA,IAAI,CAACC,CAAC,EAAEC,CAAC,CAAC;EACvB;;EAEA;EACAD,CAAC,CAACR,OAAO,GAAGS,CAAC;EACbA,CAAC,CAACT,OAAO,GAAGQ,CAAC;EAEb,IAAI,CAACE,KAAK,GAAG,CAAC,CAAC;EACf,IAAI,CAACA,KAAK,CAACF,CAAC,CAACrB,IAAI,CAAC,GAAGqB,CAAC;EACtB,IAAI,CAACE,KAAK,CAACD,CAAC,CAACtB,IAAI,CAAC,GAAGsB,CAAC;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAF,IAAI,CAACtB,SAAS,CAAC0B,IAAI,GAAG,UAASrB,MAAM,EAAEP,QAAQ,EAAE;EAC/C,IAAI,OAAOA,QAAQ,KAAK,QAAQ,EAAE;IAChC,IAAI,CAAC,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ,CAAC,EAAE;MACzB,MAAM,IAAI6B,KAAK,CAAC,eAAe,GAAG7B,QAAQ,GAAG,UAAU,CAAC;IAC1D;IACAA,QAAQ,GAAG,IAAI,CAAC2B,KAAK,CAAC3B,QAAQ,CAAC;EACjC;EAEA,IAAIA,QAAQ,CAACQ,UAAU,EAAE;IACvBH,wBAAwB,CAAC,IAAI,EAAEL,QAAQ,EAAEO,MAAM,CAAC;EAClD,CAAC,MAAM;IACLG,cAAc,CAAC,IAAI,EAAEV,QAAQ,EAAEO,MAAM,CAAC;EACxC;AACF,CAAC;AAEDiB,IAAI,CAACtB,SAAS,CAAC4B,oBAAoB,GAAG,UAASvB,MAAM,EAAEP,QAAQ,EAAE;EAE/D,IAAIQ,UAAU,GAAGD,MAAM,CAACP,QAAQ,CAACI,IAAI,CAAC;EAEtC,IAAI,CAACR,UAAU,CAACmC,UAAU,CAACvB,UAAU,CAAC,EAAE;IACtCH,wBAAwB,CAAC,IAAI,EAAEL,QAAQ,EAAEO,MAAM,CAAC;EAClD;EAEA,OAAOC,UAAU;AACnB,CAAC;AAEDgB,IAAI,CAACtB,SAAS,CAAC8B,WAAW,GAAG,UAASzB,MAAM,EAAEP,QAAQ,EAAE;EACtD,IAAI,CAACF,cAAc,CAACS,MAAM,EAAEP,QAAQ,CAAC,EAAE;IACrC,IAAI,CAAC4B,IAAI,CAACrB,MAAM,EAAEP,QAAQ,CAAC;EAC7B;AACF,CAAC;AAEDwB,IAAI,CAACtB,SAAS,CAACqB,KAAK,GAAG,UAAShB,MAAM,EAAEP,QAAQ,EAAEY,KAAK,EAAE;EAEvD,IAAIL,MAAM,EAAE;IACV,IAAI,CAACyB,WAAW,CAACzB,MAAM,EAAEP,QAAQ,CAAC;IAElC,IAAIA,QAAQ,CAACQ,UAAU,EAAE;MACvB,IAAI,CAACsB,oBAAoB,CAACvB,MAAM,EAAEP,QAAQ,CAAC,CAACiC,MAAM,CAACrB,KAAK,CAAC;IAC3D,CAAC,MAAM;MACLL,MAAM,CAACP,QAAQ,CAACI,IAAI,CAAC,GAAG8B,SAAS;IACnC;EACF;AACF,CAAC;AAEDV,IAAI,CAACtB,SAAS,CAACc,GAAG,GAAG,UAAST,MAAM,EAAEP,QAAQ,EAAEY,KAAK,EAAE;EAErD,IAAIL,MAAM,EAAE;IACV,IAAI,CAACyB,WAAW,CAACzB,MAAM,EAAEP,QAAQ,CAAC;IAElC,IAAIA,QAAQ,CAACQ,UAAU,EAAE;MACvB,IAAI,CAACsB,oBAAoB,CAACvB,MAAM,EAAEP,QAAQ,CAAC,CAACmC,GAAG,CAACvB,KAAK,CAAC;IACxD,CAAC,MAAM;MACLL,MAAM,CAACP,QAAQ,CAACI,IAAI,CAAC,GAAGQ,KAAK;IAC/B;EACF;AACF,CAAC;AAEDwB,MAAM,CAACC,OAAO,GAAGb,IAAI;;AAGrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"script"}