{"ast":null,"code":"import { isObject, sortBy } from 'min-dash';\nimport { pointDistance, pointsOnLine } from '../util/Geometry';\nimport intersectPaths from 'path-intersection';\nexport function roundBounds(bounds) {\n  return {\n    x: Math.round(bounds.x),\n    y: Math.round(bounds.y),\n    width: Math.round(bounds.width),\n    height: Math.round(bounds.height)\n  };\n}\nexport function roundPoint(point) {\n  return {\n    x: Math.round(point.x),\n    y: Math.round(point.y)\n  };\n}\n\n/**\r\n * Convert the given bounds to a { top, left, bottom, right } descriptor.\r\n *\r\n * @param {Bounds|Point} bounds\r\n *\r\n * @return {Object}\r\n */\nexport function asTRBL(bounds) {\n  return {\n    top: bounds.y,\n    right: bounds.x + (bounds.width || 0),\n    bottom: bounds.y + (bounds.height || 0),\n    left: bounds.x\n  };\n}\n\n/**\r\n * Convert a { top, left, bottom, right } to an objects bounds.\r\n *\r\n * @param {Object} trbl\r\n *\r\n * @return {Bounds}\r\n */\nexport function asBounds(trbl) {\n  return {\n    x: trbl.left,\n    y: trbl.top,\n    width: trbl.right - trbl.left,\n    height: trbl.bottom - trbl.top\n  };\n}\n\n/**\r\n * Get the mid of the given bounds or point.\r\n *\r\n * @param {Bounds|Point} bounds\r\n *\r\n * @return {Point}\r\n */\nexport function getMid(bounds) {\n  return roundPoint({\n    x: bounds.x + (bounds.width || 0) / 2,\n    y: bounds.y + (bounds.height || 0) / 2\n  });\n}\n\n// orientation utils //////////////////////\n\n/**\r\n * Get orientation of the given rectangle with respect to\r\n * the reference rectangle.\r\n *\r\n * A padding (positive or negative) may be passed to influence\r\n * horizontal / vertical orientation and intersection.\r\n *\r\n * @param {Bounds} rect\r\n * @param {Bounds} reference\r\n * @param {Point|number} padding\r\n *\r\n * @return {string} the orientation; one of top, top-left, left, ..., bottom, right or intersect.\r\n */\nexport function getOrientation(rect, reference, padding) {\n  padding = padding || 0;\n\n  // make sure we can use an object, too\n  // for individual { x, y } padding\n  if (!isObject(padding)) {\n    padding = {\n      x: padding,\n      y: padding\n    };\n  }\n  var rectOrientation = asTRBL(rect),\n    referenceOrientation = asTRBL(reference);\n  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,\n    right = rectOrientation.left - padding.x >= referenceOrientation.right,\n    bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,\n    left = rectOrientation.right + padding.x <= referenceOrientation.left;\n  var vertical = top ? 'top' : bottom ? 'bottom' : null,\n    horizontal = left ? 'left' : right ? 'right' : null;\n  if (horizontal && vertical) {\n    return vertical + '-' + horizontal;\n  } else {\n    return horizontal || vertical || 'intersect';\n  }\n}\n\n// intersection utils //////////////////////\n\n/**\r\n * Get intersection between an element and a line path.\r\n *\r\n * @param {PathDef} elementPath\r\n * @param {PathDef} linePath\r\n * @param {boolean} cropStart crop from start or end\r\n *\r\n * @return {Point}\r\n */\nexport function getElementLineIntersection(elementPath, linePath, cropStart) {\n  var intersections = getIntersections(elementPath, linePath);\n\n  // recognize intersections\n  // only one -> choose\n  // two close together -> choose first\n  // two or more distinct -> pull out appropriate one\n  // none -> ok (fallback to point itself)\n  if (intersections.length === 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {\n    return roundPoint(intersections[0]);\n  } else if (intersections.length > 1) {\n    // sort by intersections based on connection segment +\n    // distance from start\n    intersections = sortBy(intersections, function (i) {\n      var distance = Math.floor(i.t2 * 100) || 1;\n      distance = 100 - distance;\n      distance = (distance < 10 ? '0' : '') + distance;\n\n      // create a sort string that makes sure we sort\n      // line segment ASC + line segment position DESC (for cropStart)\n      // line segment ASC + line segment position ASC (for cropEnd)\n      return i.segment2 + '#' + distance;\n    });\n    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);\n  }\n  return null;\n}\nexport function getIntersections(a, b) {\n  return intersectPaths(a, b);\n}\nexport function filterRedundantWaypoints(waypoints) {\n  // alter copy of waypoints, not original\n  waypoints = waypoints.slice();\n  var idx = 0,\n    point,\n    previousPoint,\n    nextPoint;\n  while (waypoints[idx]) {\n    point = waypoints[idx];\n    previousPoint = waypoints[idx - 1];\n    nextPoint = waypoints[idx + 1];\n    if (pointDistance(point, nextPoint) === 0 || pointsOnLine(previousPoint, nextPoint, point)) {\n      // remove point, if overlapping with {nextPoint}\n      // or on line with {previousPoint} -> {point} -> {nextPoint}\n      waypoints.splice(idx, 1);\n    } else {\n      idx++;\n    }\n  }\n  return waypoints;\n}","map":{"version":3,"names":["isObject","sortBy","pointDistance","pointsOnLine","intersectPaths","roundBounds","bounds","x","Math","round","y","width","height","roundPoint","point","asTRBL","top","right","bottom","left","asBounds","trbl","getMid","getOrientation","rect","reference","padding","rectOrientation","referenceOrientation","vertical","horizontal","getElementLineIntersection","elementPath","linePath","cropStart","intersections","getIntersections","length","i","distance","floor","t2","segment2","a","b","filterRedundantWaypoints","waypoints","slice","idx","previousPoint","nextPoint","splice"],"sources":["C:/Users/sam/final/camunda-react/node_modules/diagram-js/lib/layout/LayoutUtil.js"],"sourcesContent":["import {\r\n  isObject,\r\n  sortBy\r\n} from 'min-dash';\r\n\r\nimport {\r\n  pointDistance,\r\n  pointsOnLine\r\n} from '../util/Geometry';\r\n\r\nimport intersectPaths from 'path-intersection';\r\n\r\n\r\nexport function roundBounds(bounds) {\r\n  return {\r\n    x: Math.round(bounds.x),\r\n    y: Math.round(bounds.y),\r\n    width: Math.round(bounds.width),\r\n    height: Math.round(bounds.height)\r\n  };\r\n}\r\n\r\n\r\nexport function roundPoint(point) {\r\n\r\n  return {\r\n    x: Math.round(point.x),\r\n    y: Math.round(point.y)\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * Convert the given bounds to a { top, left, bottom, right } descriptor.\r\n *\r\n * @param {Bounds|Point} bounds\r\n *\r\n * @return {Object}\r\n */\r\nexport function asTRBL(bounds) {\r\n  return {\r\n    top: bounds.y,\r\n    right: bounds.x + (bounds.width || 0),\r\n    bottom: bounds.y + (bounds.height || 0),\r\n    left: bounds.x\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * Convert a { top, left, bottom, right } to an objects bounds.\r\n *\r\n * @param {Object} trbl\r\n *\r\n * @return {Bounds}\r\n */\r\nexport function asBounds(trbl) {\r\n  return {\r\n    x: trbl.left,\r\n    y: trbl.top,\r\n    width: trbl.right - trbl.left,\r\n    height: trbl.bottom - trbl.top\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * Get the mid of the given bounds or point.\r\n *\r\n * @param {Bounds|Point} bounds\r\n *\r\n * @return {Point}\r\n */\r\nexport function getMid(bounds) {\r\n  return roundPoint({\r\n    x: bounds.x + (bounds.width || 0) / 2,\r\n    y: bounds.y + (bounds.height || 0) / 2\r\n  });\r\n}\r\n\r\n\r\n// orientation utils //////////////////////\r\n\r\n/**\r\n * Get orientation of the given rectangle with respect to\r\n * the reference rectangle.\r\n *\r\n * A padding (positive or negative) may be passed to influence\r\n * horizontal / vertical orientation and intersection.\r\n *\r\n * @param {Bounds} rect\r\n * @param {Bounds} reference\r\n * @param {Point|number} padding\r\n *\r\n * @return {string} the orientation; one of top, top-left, left, ..., bottom, right or intersect.\r\n */\r\nexport function getOrientation(rect, reference, padding) {\r\n\r\n  padding = padding || 0;\r\n\r\n  // make sure we can use an object, too\r\n  // for individual { x, y } padding\r\n  if (!isObject(padding)) {\r\n    padding = { x: padding, y: padding };\r\n  }\r\n\r\n\r\n  var rectOrientation = asTRBL(rect),\r\n      referenceOrientation = asTRBL(reference);\r\n\r\n  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top,\r\n      right = rectOrientation.left - padding.x >= referenceOrientation.right,\r\n      bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom,\r\n      left = rectOrientation.right + padding.x <= referenceOrientation.left;\r\n\r\n  var vertical = top ? 'top' : (bottom ? 'bottom' : null),\r\n      horizontal = left ? 'left' : (right ? 'right' : null);\r\n\r\n  if (horizontal && vertical) {\r\n    return vertical + '-' + horizontal;\r\n  } else {\r\n    return horizontal || vertical || 'intersect';\r\n  }\r\n}\r\n\r\n\r\n// intersection utils //////////////////////\r\n\r\n/**\r\n * Get intersection between an element and a line path.\r\n *\r\n * @param {PathDef} elementPath\r\n * @param {PathDef} linePath\r\n * @param {boolean} cropStart crop from start or end\r\n *\r\n * @return {Point}\r\n */\r\nexport function getElementLineIntersection(elementPath, linePath, cropStart) {\r\n\r\n  var intersections = getIntersections(elementPath, linePath);\r\n\r\n  // recognize intersections\r\n  // only one -> choose\r\n  // two close together -> choose first\r\n  // two or more distinct -> pull out appropriate one\r\n  // none -> ok (fallback to point itself)\r\n  if (intersections.length === 1) {\r\n    return roundPoint(intersections[0]);\r\n  } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {\r\n    return roundPoint(intersections[0]);\r\n  } else if (intersections.length > 1) {\r\n\r\n    // sort by intersections based on connection segment +\r\n    // distance from start\r\n    intersections = sortBy(intersections, function(i) {\r\n      var distance = Math.floor(i.t2 * 100) || 1;\r\n\r\n      distance = 100 - distance;\r\n\r\n      distance = (distance < 10 ? '0' : '') + distance;\r\n\r\n      // create a sort string that makes sure we sort\r\n      // line segment ASC + line segment position DESC (for cropStart)\r\n      // line segment ASC + line segment position ASC (for cropEnd)\r\n      return i.segment2 + '#' + distance;\r\n    });\r\n\r\n    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n\r\nexport function getIntersections(a, b) {\r\n  return intersectPaths(a, b);\r\n}\r\n\r\n\r\nexport function filterRedundantWaypoints(waypoints) {\r\n\r\n  // alter copy of waypoints, not original\r\n  waypoints = waypoints.slice();\r\n\r\n  var idx = 0,\r\n      point,\r\n      previousPoint,\r\n      nextPoint;\r\n\r\n  while (waypoints[idx]) {\r\n    point = waypoints[idx];\r\n    previousPoint = waypoints[idx - 1];\r\n    nextPoint = waypoints[idx + 1];\r\n\r\n    if (pointDistance(point, nextPoint) === 0 ||\r\n        pointsOnLine(previousPoint, nextPoint, point)) {\r\n\r\n      // remove point, if overlapping with {nextPoint}\r\n      // or on line with {previousPoint} -> {point} -> {nextPoint}\r\n      waypoints.splice(idx, 1);\r\n    } else {\r\n      idx++;\r\n    }\r\n  }\r\n\r\n  return waypoints;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}