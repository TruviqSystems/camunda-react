{"ast":null,"code":"import { assign, filter, find, isArray, isNumber, isObject, isUndefined, groupBy, forEach } from 'min-dash';\n\n/**\n * Get parent elements.\n *\n * @param {Array<djs.model.base>} elements\n *\n * @returns {Array<djs.model.Base>}\n */\nexport function getParents(elements) {\n  // find elements that are not children of any other elements\n  return filter(elements, function (element) {\n    return !find(elements, function (e) {\n      return e !== element && getParent(element, e);\n    });\n  });\n}\nfunction getParent(element, parent) {\n  if (!parent) {\n    return;\n  }\n  if (element === parent) {\n    return parent;\n  }\n  if (!element.parent) {\n    return;\n  }\n  return getParent(element.parent, parent);\n}\n\n/**\n * Adds an element to a collection and returns true if the\n * element was added.\n *\n * @param {Array<Object>} elements\n * @param {Object} e\n * @param {boolean} unique\n */\nexport function add(elements, e, unique) {\n  var canAdd = !unique || elements.indexOf(e) === -1;\n  if (canAdd) {\n    elements.push(e);\n  }\n  return canAdd;\n}\n\n/**\n * Iterate over each element in a collection, calling the iterator function `fn`\n * with (element, index, recursionDepth).\n *\n * Recurse into all elements that are returned by `fn`.\n *\n * @param  {Object|Array<Object>} elements\n * @param  {Function} fn iterator function called with (element, index, recursionDepth)\n * @param  {number} [depth] maximum recursion depth\n */\nexport function eachElement(elements, fn, depth) {\n  depth = depth || 0;\n  if (!isArray(elements)) {\n    elements = [elements];\n  }\n  forEach(elements, function (s, i) {\n    var filter = fn(s, i, depth);\n    if (isArray(filter) && filter.length) {\n      eachElement(filter, fn, depth + 1);\n    }\n  });\n}\n\n/**\n * Collects self + child elements up to a given depth from a list of elements.\n *\n * @param  {djs.model.Base|Array<djs.model.Base>} elements the elements to select the children from\n * @param  {boolean} unique whether to return a unique result set (no duplicates)\n * @param  {number} maxDepth the depth to search through or -1 for infinite\n *\n * @return {Array<djs.model.Base>} found elements\n */\nexport function selfAndChildren(elements, unique, maxDepth) {\n  var result = [],\n    processedChildren = [];\n  eachElement(elements, function (element, i, depth) {\n    add(result, element, unique);\n    var children = element.children;\n\n    // max traversal depth not reached yet\n    if (maxDepth === -1 || depth < maxDepth) {\n      // children exist && children not yet processed\n      if (children && add(processedChildren, children, unique)) {\n        return children;\n      }\n    }\n  });\n  return result;\n}\n\n/**\n * Return self + direct children for a number of elements\n *\n * @param  {Array<djs.model.Base>} elements to query\n * @param  {boolean} allowDuplicates to allow duplicates in the result set\n *\n * @return {Array<djs.model.Base>} the collected elements\n */\nexport function selfAndDirectChildren(elements, allowDuplicates) {\n  return selfAndChildren(elements, !allowDuplicates, 1);\n}\n\n/**\n * Return self + ALL children for a number of elements\n *\n * @param  {Array<djs.model.Base>} elements to query\n * @param  {boolean} allowDuplicates to allow duplicates in the result set\n *\n * @return {Array<djs.model.Base>} the collected elements\n */\nexport function selfAndAllChildren(elements, allowDuplicates) {\n  return selfAndChildren(elements, !allowDuplicates, -1);\n}\n\n/**\n * Gets the the closure for all selected elements,\n * their enclosed children and connections.\n *\n * @param {Array<djs.model.Base>} elements\n * @param {boolean} [isTopLevel=true]\n * @param {Object} [existingClosure]\n *\n * @return {Object} newClosure\n */\nexport function getClosure(elements, isTopLevel, closure) {\n  if (isUndefined(isTopLevel)) {\n    isTopLevel = true;\n  }\n  if (isObject(isTopLevel)) {\n    closure = isTopLevel;\n    isTopLevel = true;\n  }\n  closure = closure || {};\n  var allShapes = copyObject(closure.allShapes),\n    allConnections = copyObject(closure.allConnections),\n    enclosedElements = copyObject(closure.enclosedElements),\n    enclosedConnections = copyObject(closure.enclosedConnections);\n  var topLevel = copyObject(closure.topLevel, isTopLevel && groupBy(elements, function (e) {\n    return e.id;\n  }));\n  function handleConnection(c) {\n    if (topLevel[c.source.id] && topLevel[c.target.id]) {\n      topLevel[c.id] = [c];\n    }\n\n    // not enclosed as a child, but maybe logically\n    // (connecting two moved elements?)\n    if (allShapes[c.source.id] && allShapes[c.target.id]) {\n      enclosedConnections[c.id] = enclosedElements[c.id] = c;\n    }\n    allConnections[c.id] = c;\n  }\n  function handleElement(element) {\n    enclosedElements[element.id] = element;\n    if (element.waypoints) {\n      // remember connection\n      enclosedConnections[element.id] = allConnections[element.id] = element;\n    } else {\n      // remember shape\n      allShapes[element.id] = element;\n\n      // remember all connections\n      forEach(element.incoming, handleConnection);\n      forEach(element.outgoing, handleConnection);\n\n      // recurse into children\n      return element.children;\n    }\n  }\n  eachElement(elements, handleElement);\n  return {\n    allShapes: allShapes,\n    allConnections: allConnections,\n    topLevel: topLevel,\n    enclosedConnections: enclosedConnections,\n    enclosedElements: enclosedElements\n  };\n}\n\n/**\n * Returns the surrounding bbox for all elements in\n * the array or the element primitive.\n *\n * @param {Array<djs.model.Shape>|djs.model.Shape} elements\n * @param {boolean} stopRecursion\n */\nexport function getBBox(elements, stopRecursion) {\n  stopRecursion = !!stopRecursion;\n  if (!isArray(elements)) {\n    elements = [elements];\n  }\n  var minX, minY, maxX, maxY;\n  forEach(elements, function (element) {\n    // If element is a connection the bbox must be computed first\n    var bbox = element;\n    if (element.waypoints && !stopRecursion) {\n      bbox = getBBox(element.waypoints, true);\n    }\n    var x = bbox.x,\n      y = bbox.y,\n      height = bbox.height || 0,\n      width = bbox.width || 0;\n    if (x < minX || minX === undefined) {\n      minX = x;\n    }\n    if (y < minY || minY === undefined) {\n      minY = y;\n    }\n    if (x + width > maxX || maxX === undefined) {\n      maxX = x + width;\n    }\n    if (y + height > maxY || maxY === undefined) {\n      maxY = y + height;\n    }\n  });\n  return {\n    x: minX,\n    y: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n}\n\n/**\n * Returns all elements that are enclosed from the bounding box.\n *\n *   * If bbox.(width|height) is not specified the method returns\n *     all elements with element.x/y > bbox.x/y\n *   * If only bbox.x or bbox.y is specified, method return all elements with\n *     e.x > bbox.x or e.y > bbox.y\n *\n * @param {Array<djs.model.Shape>} elements List of Elements to search through\n * @param {djs.model.Shape} bbox the enclosing bbox.\n *\n * @return {Array<djs.model.Shape>} enclosed elements\n */\nexport function getEnclosedElements(elements, bbox) {\n  var filteredElements = {};\n  forEach(elements, function (element) {\n    var e = element;\n    if (e.waypoints) {\n      e = getBBox(e);\n    }\n    if (!isNumber(bbox.y) && e.x > bbox.x) {\n      filteredElements[element.id] = element;\n    }\n    if (!isNumber(bbox.x) && e.y > bbox.y) {\n      filteredElements[element.id] = element;\n    }\n    if (e.x > bbox.x && e.y > bbox.y) {\n      if (isNumber(bbox.width) && isNumber(bbox.height) && e.width + e.x < bbox.width + bbox.x && e.height + e.y < bbox.height + bbox.y) {\n        filteredElements[element.id] = element;\n      } else if (!isNumber(bbox.width) || !isNumber(bbox.height)) {\n        filteredElements[element.id] = element;\n      }\n    }\n  });\n  return filteredElements;\n}\nexport function getType(element) {\n  if ('waypoints' in element) {\n    return 'connection';\n  }\n  if ('x' in element) {\n    return 'shape';\n  }\n  return 'root';\n}\nexport function isFrameElement(element) {\n  return !!(element && element.isFrame);\n}\n\n// helpers ///////////////////////////////\n\nfunction copyObject(src1, src2) {\n  return assign({}, src1 || {}, src2 || {});\n}","map":{"version":3,"names":["assign","filter","find","isArray","isNumber","isObject","isUndefined","groupBy","forEach","getParents","elements","element","e","getParent","parent","add","unique","canAdd","indexOf","push","eachElement","fn","depth","s","i","length","selfAndChildren","maxDepth","result","processedChildren","children","selfAndDirectChildren","allowDuplicates","selfAndAllChildren","getClosure","isTopLevel","closure","allShapes","copyObject","allConnections","enclosedElements","enclosedConnections","topLevel","id","handleConnection","c","source","target","handleElement","waypoints","incoming","outgoing","getBBox","stopRecursion","minX","minY","maxX","maxY","bbox","x","y","height","width","undefined","getEnclosedElements","filteredElements","getType","isFrameElement","isFrame","src1","src2"],"sources":["C:/Users/KondalaRaoThota/camunda/camunda-7-code-examples/snippets/camunda-tasklist-examples/camunda-react-app/node_modules/diagram-js/lib/util/Elements.js"],"sourcesContent":["import {\n  assign,\n  filter,\n  find,\n  isArray,\n  isNumber,\n  isObject,\n  isUndefined,\n  groupBy,\n  forEach\n} from 'min-dash';\n\n\n/**\n * Get parent elements.\n *\n * @param {Array<djs.model.base>} elements\n *\n * @returns {Array<djs.model.Base>}\n */\nexport function getParents(elements) {\n\n  // find elements that are not children of any other elements\n  return filter(elements, function(element) {\n    return !find(elements, function(e) {\n      return e !== element && getParent(element, e);\n    });\n  });\n}\n\n\nfunction getParent(element, parent) {\n  if (!parent) {\n    return;\n  }\n\n  if (element === parent) {\n    return parent;\n  }\n\n  if (!element.parent) {\n    return;\n  }\n\n  return getParent(element.parent, parent);\n}\n\n\n/**\n * Adds an element to a collection and returns true if the\n * element was added.\n *\n * @param {Array<Object>} elements\n * @param {Object} e\n * @param {boolean} unique\n */\nexport function add(elements, e, unique) {\n  var canAdd = !unique || elements.indexOf(e) === -1;\n\n  if (canAdd) {\n    elements.push(e);\n  }\n\n  return canAdd;\n}\n\n\n/**\n * Iterate over each element in a collection, calling the iterator function `fn`\n * with (element, index, recursionDepth).\n *\n * Recurse into all elements that are returned by `fn`.\n *\n * @param  {Object|Array<Object>} elements\n * @param  {Function} fn iterator function called with (element, index, recursionDepth)\n * @param  {number} [depth] maximum recursion depth\n */\nexport function eachElement(elements, fn, depth) {\n\n  depth = depth || 0;\n\n  if (!isArray(elements)) {\n    elements = [ elements ];\n  }\n\n  forEach(elements, function(s, i) {\n    var filter = fn(s, i, depth);\n\n    if (isArray(filter) && filter.length) {\n      eachElement(filter, fn, depth + 1);\n    }\n  });\n}\n\n\n/**\n * Collects self + child elements up to a given depth from a list of elements.\n *\n * @param  {djs.model.Base|Array<djs.model.Base>} elements the elements to select the children from\n * @param  {boolean} unique whether to return a unique result set (no duplicates)\n * @param  {number} maxDepth the depth to search through or -1 for infinite\n *\n * @return {Array<djs.model.Base>} found elements\n */\nexport function selfAndChildren(elements, unique, maxDepth) {\n  var result = [],\n      processedChildren = [];\n\n  eachElement(elements, function(element, i, depth) {\n    add(result, element, unique);\n\n    var children = element.children;\n\n    // max traversal depth not reached yet\n    if (maxDepth === -1 || depth < maxDepth) {\n\n      // children exist && children not yet processed\n      if (children && add(processedChildren, children, unique)) {\n        return children;\n      }\n    }\n  });\n\n  return result;\n}\n\n/**\n * Return self + direct children for a number of elements\n *\n * @param  {Array<djs.model.Base>} elements to query\n * @param  {boolean} allowDuplicates to allow duplicates in the result set\n *\n * @return {Array<djs.model.Base>} the collected elements\n */\nexport function selfAndDirectChildren(elements, allowDuplicates) {\n  return selfAndChildren(elements, !allowDuplicates, 1);\n}\n\n\n/**\n * Return self + ALL children for a number of elements\n *\n * @param  {Array<djs.model.Base>} elements to query\n * @param  {boolean} allowDuplicates to allow duplicates in the result set\n *\n * @return {Array<djs.model.Base>} the collected elements\n */\nexport function selfAndAllChildren(elements, allowDuplicates) {\n  return selfAndChildren(elements, !allowDuplicates, -1);\n}\n\n\n/**\n * Gets the the closure for all selected elements,\n * their enclosed children and connections.\n *\n * @param {Array<djs.model.Base>} elements\n * @param {boolean} [isTopLevel=true]\n * @param {Object} [existingClosure]\n *\n * @return {Object} newClosure\n */\nexport function getClosure(elements, isTopLevel, closure) {\n\n  if (isUndefined(isTopLevel)) {\n    isTopLevel = true;\n  }\n\n  if (isObject(isTopLevel)) {\n    closure = isTopLevel;\n    isTopLevel = true;\n  }\n\n\n  closure = closure || {};\n\n  var allShapes = copyObject(closure.allShapes),\n      allConnections = copyObject(closure.allConnections),\n      enclosedElements = copyObject(closure.enclosedElements),\n      enclosedConnections = copyObject(closure.enclosedConnections);\n\n  var topLevel = copyObject(\n    closure.topLevel,\n    isTopLevel && groupBy(elements, function(e) { return e.id; })\n  );\n\n\n  function handleConnection(c) {\n    if (topLevel[c.source.id] && topLevel[c.target.id]) {\n      topLevel[c.id] = [ c ];\n    }\n\n    // not enclosed as a child, but maybe logically\n    // (connecting two moved elements?)\n    if (allShapes[c.source.id] && allShapes[c.target.id]) {\n      enclosedConnections[c.id] = enclosedElements[c.id] = c;\n    }\n\n    allConnections[c.id] = c;\n  }\n\n  function handleElement(element) {\n\n    enclosedElements[element.id] = element;\n\n    if (element.waypoints) {\n\n      // remember connection\n      enclosedConnections[element.id] = allConnections[element.id] = element;\n    } else {\n\n      // remember shape\n      allShapes[element.id] = element;\n\n      // remember all connections\n      forEach(element.incoming, handleConnection);\n\n      forEach(element.outgoing, handleConnection);\n\n      // recurse into children\n      return element.children;\n    }\n  }\n\n  eachElement(elements, handleElement);\n\n  return {\n    allShapes: allShapes,\n    allConnections: allConnections,\n    topLevel: topLevel,\n    enclosedConnections: enclosedConnections,\n    enclosedElements: enclosedElements\n  };\n}\n\n/**\n * Returns the surrounding bbox for all elements in\n * the array or the element primitive.\n *\n * @param {Array<djs.model.Shape>|djs.model.Shape} elements\n * @param {boolean} stopRecursion\n */\nexport function getBBox(elements, stopRecursion) {\n\n  stopRecursion = !!stopRecursion;\n  if (!isArray(elements)) {\n    elements = [elements];\n  }\n\n  var minX,\n      minY,\n      maxX,\n      maxY;\n\n  forEach(elements, function(element) {\n\n    // If element is a connection the bbox must be computed first\n    var bbox = element;\n    if (element.waypoints && !stopRecursion) {\n      bbox = getBBox(element.waypoints, true);\n    }\n\n    var x = bbox.x,\n        y = bbox.y,\n        height = bbox.height || 0,\n        width = bbox.width || 0;\n\n    if (x < minX || minX === undefined) {\n      minX = x;\n    }\n    if (y < minY || minY === undefined) {\n      minY = y;\n    }\n\n    if ((x + width) > maxX || maxX === undefined) {\n      maxX = x + width;\n    }\n    if ((y + height) > maxY || maxY === undefined) {\n      maxY = y + height;\n    }\n  });\n\n  return {\n    x: minX,\n    y: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n}\n\n\n/**\n * Returns all elements that are enclosed from the bounding box.\n *\n *   * If bbox.(width|height) is not specified the method returns\n *     all elements with element.x/y > bbox.x/y\n *   * If only bbox.x or bbox.y is specified, method return all elements with\n *     e.x > bbox.x or e.y > bbox.y\n *\n * @param {Array<djs.model.Shape>} elements List of Elements to search through\n * @param {djs.model.Shape} bbox the enclosing bbox.\n *\n * @return {Array<djs.model.Shape>} enclosed elements\n */\nexport function getEnclosedElements(elements, bbox) {\n\n  var filteredElements = {};\n\n  forEach(elements, function(element) {\n\n    var e = element;\n\n    if (e.waypoints) {\n      e = getBBox(e);\n    }\n\n    if (!isNumber(bbox.y) && (e.x > bbox.x)) {\n      filteredElements[element.id] = element;\n    }\n    if (!isNumber(bbox.x) && (e.y > bbox.y)) {\n      filteredElements[element.id] = element;\n    }\n    if (e.x > bbox.x && e.y > bbox.y) {\n      if (isNumber(bbox.width) && isNumber(bbox.height) &&\n          e.width + e.x < bbox.width + bbox.x &&\n          e.height + e.y < bbox.height + bbox.y) {\n\n        filteredElements[element.id] = element;\n      } else if (!isNumber(bbox.width) || !isNumber(bbox.height)) {\n        filteredElements[element.id] = element;\n      }\n    }\n  });\n\n  return filteredElements;\n}\n\n\nexport function getType(element) {\n\n  if ('waypoints' in element) {\n    return 'connection';\n  }\n\n  if ('x' in element) {\n    return 'shape';\n  }\n\n  return 'root';\n}\n\nexport function isFrameElement(element) {\n\n  return !!(element && element.isFrame);\n}\n\n// helpers ///////////////////////////////\n\nfunction copyObject(src1, src2) {\n  return assign({}, src1 || {}, src2 || {});\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}