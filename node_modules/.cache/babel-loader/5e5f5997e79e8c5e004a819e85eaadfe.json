{"ast":null,"code":"import { forEach, bind, pick, assign, isString, isObject } from 'min-dash';\n\n/**\n * Moddle base element.\n */\nfunction Base() {}\nBase.prototype.get = function (name) {\n  return this.$model.properties.get(this, name);\n};\nBase.prototype.set = function (name, value) {\n  this.$model.properties.set(this, name, value);\n};\n\n/**\n * A model element factory.\n *\n * @param {Moddle} model\n * @param {Properties} properties\n */\nfunction Factory(model, properties) {\n  this.model = model;\n  this.properties = properties;\n}\nFactory.prototype.createType = function (descriptor) {\n  var model = this.model;\n  var props = this.properties,\n    prototype = Object.create(Base.prototype);\n\n  // initialize default values\n  forEach(descriptor.properties, function (p) {\n    if (!p.isMany && p.default !== undefined) {\n      prototype[p.name] = p.default;\n    }\n  });\n  props.defineModel(prototype, model);\n  props.defineDescriptor(prototype, descriptor);\n  var name = descriptor.ns.name;\n\n  /**\n   * The new type constructor\n   */\n  function ModdleElement(attrs) {\n    props.define(this, '$type', {\n      value: name,\n      enumerable: true\n    });\n    props.define(this, '$attrs', {\n      value: {}\n    });\n    props.define(this, '$parent', {\n      writable: true\n    });\n    forEach(attrs, bind(function (val, key) {\n      this.set(key, val);\n    }, this));\n  }\n  ModdleElement.prototype = prototype;\n  ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;\n\n  // static links\n  props.defineModel(ModdleElement, model);\n  props.defineDescriptor(ModdleElement, descriptor);\n  return ModdleElement;\n};\n\n/**\n * Built-in moddle types\n */\nvar BUILTINS = {\n  String: true,\n  Boolean: true,\n  Integer: true,\n  Real: true,\n  Element: true\n};\n\n/**\n * Converters for built in types from string representations\n */\nvar TYPE_CONVERTERS = {\n  String: function (s) {\n    return s;\n  },\n  Boolean: function (s) {\n    return s === 'true';\n  },\n  Integer: function (s) {\n    return parseInt(s, 10);\n  },\n  Real: function (s) {\n    return parseFloat(s);\n  }\n};\n\n/**\n * Convert a type to its real representation\n */\nfunction coerceType(type, value) {\n  var converter = TYPE_CONVERTERS[type];\n  if (converter) {\n    return converter(value);\n  } else {\n    return value;\n  }\n}\n\n/**\n * Return whether the given type is built-in\n */\nfunction isBuiltIn(type) {\n  return !!BUILTINS[type];\n}\n\n/**\n * Return whether the given type is simple\n */\nfunction isSimple(type) {\n  return !!TYPE_CONVERTERS[type];\n}\n\n/**\n * Parses a namespaced attribute name of the form (ns:)localName to an object,\n * given a default prefix to assume in case no explicit namespace is given.\n *\n * @param {String} name\n * @param {String} [defaultPrefix] the default prefix to take, if none is present.\n *\n * @return {Object} the parsed name\n */\nfunction parseName(name, defaultPrefix) {\n  var parts = name.split(/:/),\n    localName,\n    prefix;\n\n  // no prefix (i.e. only local name)\n  if (parts.length === 1) {\n    localName = name;\n    prefix = defaultPrefix;\n  } else\n    // prefix + local name\n    if (parts.length === 2) {\n      localName = parts[1];\n      prefix = parts[0];\n    } else {\n      throw new Error('expected <prefix:localName> or <localName>, got ' + name);\n    }\n  name = (prefix ? prefix + ':' : '') + localName;\n  return {\n    name: name,\n    prefix: prefix,\n    localName: localName\n  };\n}\n\n/**\n * A utility to build element descriptors.\n */\nfunction DescriptorBuilder(nameNs) {\n  this.ns = nameNs;\n  this.name = nameNs.name;\n  this.allTypes = [];\n  this.allTypesByName = {};\n  this.properties = [];\n  this.propertiesByName = {};\n}\nDescriptorBuilder.prototype.build = function () {\n  return pick(this, ['ns', 'name', 'allTypes', 'allTypesByName', 'properties', 'propertiesByName', 'bodyProperty', 'idProperty']);\n};\n\n/**\n * Add property at given index.\n *\n * @param {Object} p\n * @param {Number} [idx]\n * @param {Boolean} [validate=true]\n */\nDescriptorBuilder.prototype.addProperty = function (p, idx, validate) {\n  if (typeof idx === 'boolean') {\n    validate = idx;\n    idx = undefined;\n  }\n  this.addNamedProperty(p, validate !== false);\n  var properties = this.properties;\n  if (idx !== undefined) {\n    properties.splice(idx, 0, p);\n  } else {\n    properties.push(p);\n  }\n};\nDescriptorBuilder.prototype.replaceProperty = function (oldProperty, newProperty, replace) {\n  var oldNameNs = oldProperty.ns;\n  var props = this.properties,\n    propertiesByName = this.propertiesByName,\n    rename = oldProperty.name !== newProperty.name;\n  if (oldProperty.isId) {\n    if (!newProperty.isId) {\n      throw new Error('property <' + newProperty.ns.name + '> must be id property ' + 'to refine <' + oldProperty.ns.name + '>');\n    }\n    this.setIdProperty(newProperty, false);\n  }\n  if (oldProperty.isBody) {\n    if (!newProperty.isBody) {\n      throw new Error('property <' + newProperty.ns.name + '> must be body property ' + 'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    // TODO: Check compatibility\n    this.setBodyProperty(newProperty, false);\n  }\n\n  // validate existence and get location of old property\n  var idx = props.indexOf(oldProperty);\n  if (idx === -1) {\n    throw new Error('property <' + oldNameNs.name + '> not found in property list');\n  }\n\n  // remove old property\n  props.splice(idx, 1);\n\n  // replacing the named property is intentional\n  //\n  //  * validate only if this is a \"rename\" operation\n  //  * add at specific index unless we \"replace\"\n  //\n  this.addProperty(newProperty, replace ? undefined : idx, rename);\n\n  // make new property available under old name\n  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;\n};\nDescriptorBuilder.prototype.redefineProperty = function (p, targetPropertyName, replace) {\n  var nsPrefix = p.ns.prefix;\n  var parts = targetPropertyName.split('#');\n  var name = parseName(parts[0], nsPrefix);\n  var attrName = parseName(parts[1], name.prefix).name;\n  var redefinedProperty = this.propertiesByName[attrName];\n  if (!redefinedProperty) {\n    throw new Error('refined property <' + attrName + '> not found');\n  } else {\n    this.replaceProperty(redefinedProperty, p, replace);\n  }\n  delete p.redefines;\n};\nDescriptorBuilder.prototype.addNamedProperty = function (p, validate) {\n  var ns = p.ns,\n    propsByName = this.propertiesByName;\n  if (validate) {\n    this.assertNotDefined(p, ns.name);\n    this.assertNotDefined(p, ns.localName);\n  }\n  propsByName[ns.name] = propsByName[ns.localName] = p;\n};\nDescriptorBuilder.prototype.removeNamedProperty = function (p) {\n  var ns = p.ns,\n    propsByName = this.propertiesByName;\n  delete propsByName[ns.name];\n  delete propsByName[ns.localName];\n};\nDescriptorBuilder.prototype.setBodyProperty = function (p, validate) {\n  if (validate && this.bodyProperty) {\n    throw new Error('body property defined multiple times ' + '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n  this.bodyProperty = p;\n};\nDescriptorBuilder.prototype.setIdProperty = function (p, validate) {\n  if (validate && this.idProperty) {\n    throw new Error('id property defined multiple times ' + '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n  this.idProperty = p;\n};\nDescriptorBuilder.prototype.assertNotDefined = function (p, name) {\n  var propertyName = p.name,\n    definedProperty = this.propertiesByName[propertyName];\n  if (definedProperty) {\n    throw new Error('property <' + propertyName + '> already defined; ' + 'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' + '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');\n  }\n};\nDescriptorBuilder.prototype.hasProperty = function (name) {\n  return this.propertiesByName[name];\n};\nDescriptorBuilder.prototype.addTrait = function (t, inherited) {\n  var typesByName = this.allTypesByName,\n    types = this.allTypes;\n  var typeName = t.name;\n  if (typeName in typesByName) {\n    return;\n  }\n  forEach(t.properties, bind(function (p) {\n    // clone property to allow extensions\n    p = assign({}, p, {\n      name: p.ns.localName,\n      inherited: inherited\n    });\n    Object.defineProperty(p, 'definedBy', {\n      value: t\n    });\n    var replaces = p.replaces,\n      redefines = p.redefines;\n\n    // add replace/redefine support\n    if (replaces || redefines) {\n      this.redefineProperty(p, replaces || redefines, replaces);\n    } else {\n      if (p.isBody) {\n        this.setBodyProperty(p);\n      }\n      if (p.isId) {\n        this.setIdProperty(p);\n      }\n      this.addProperty(p);\n    }\n  }, this));\n  types.push(t);\n  typesByName[typeName] = t;\n};\n\n/**\n * A registry of Moddle packages.\n *\n * @param {Array<Package>} packages\n * @param {Properties} properties\n */\nfunction Registry(packages, properties) {\n  this.packageMap = {};\n  this.typeMap = {};\n  this.packages = [];\n  this.properties = properties;\n  forEach(packages, bind(this.registerPackage, this));\n}\nRegistry.prototype.getPackage = function (uriOrPrefix) {\n  return this.packageMap[uriOrPrefix];\n};\nRegistry.prototype.getPackages = function () {\n  return this.packages;\n};\nRegistry.prototype.registerPackage = function (pkg) {\n  // copy package\n  pkg = assign({}, pkg);\n  var pkgMap = this.packageMap;\n  ensureAvailable(pkgMap, pkg, 'prefix');\n  ensureAvailable(pkgMap, pkg, 'uri');\n\n  // register types\n  forEach(pkg.types, bind(function (descriptor) {\n    this.registerType(descriptor, pkg);\n  }, this));\n  pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;\n  this.packages.push(pkg);\n};\n\n/**\n * Register a type from a specific package with us\n */\nRegistry.prototype.registerType = function (type, pkg) {\n  type = assign({}, type, {\n    superClass: (type.superClass || []).slice(),\n    extends: (type.extends || []).slice(),\n    properties: (type.properties || []).slice(),\n    meta: assign(type.meta || {})\n  });\n  var ns = parseName(type.name, pkg.prefix),\n    name = ns.name,\n    propertiesByName = {};\n\n  // parse properties\n  forEach(type.properties, bind(function (p) {\n    // namespace property names\n    var propertyNs = parseName(p.name, ns.prefix),\n      propertyName = propertyNs.name;\n\n    // namespace property types\n    if (!isBuiltIn(p.type)) {\n      p.type = parseName(p.type, propertyNs.prefix).name;\n    }\n    assign(p, {\n      ns: propertyNs,\n      name: propertyName\n    });\n    propertiesByName[propertyName] = p;\n  }, this));\n\n  // update ns + name\n  assign(type, {\n    ns: ns,\n    name: name,\n    propertiesByName: propertiesByName\n  });\n  forEach(type.extends, bind(function (extendsName) {\n    var extended = this.typeMap[extendsName];\n    extended.traits = extended.traits || [];\n    extended.traits.push(name);\n  }, this));\n\n  // link to package\n  this.definePackage(type, pkg);\n\n  // register\n  this.typeMap[name] = type;\n};\n\n/**\n * Traverse the type hierarchy from bottom to top,\n * calling iterator with (type, inherited) for all elements in\n * the inheritance chain.\n *\n * @param {Object} nsName\n * @param {Function} iterator\n * @param {Boolean} [trait=false]\n */\nRegistry.prototype.mapTypes = function (nsName, iterator, trait) {\n  var type = isBuiltIn(nsName.name) ? {\n    name: nsName.name\n  } : this.typeMap[nsName.name];\n  var self = this;\n\n  /**\n   * Traverse the selected trait.\n   *\n   * @param {String} cls\n   */\n  function traverseTrait(cls) {\n    return traverseSuper(cls, true);\n  }\n\n  /**\n   * Traverse the selected super type or trait\n   *\n   * @param {String} cls\n   * @param {Boolean} [trait=false]\n   */\n  function traverseSuper(cls, trait) {\n    var parentNs = parseName(cls, isBuiltIn(cls) ? '' : nsName.prefix);\n    self.mapTypes(parentNs, iterator, trait);\n  }\n  if (!type) {\n    throw new Error('unknown type <' + nsName.name + '>');\n  }\n  forEach(type.superClass, trait ? traverseTrait : traverseSuper);\n\n  // call iterator with (type, inherited=!trait)\n  iterator(type, !trait);\n  forEach(type.traits, traverseTrait);\n};\n\n/**\n * Returns the effective descriptor for a type.\n *\n * @param  {String} type the namespaced name (ns:localName) of the type\n *\n * @return {Descriptor} the resulting effective descriptor\n */\nRegistry.prototype.getEffectiveDescriptor = function (name) {\n  var nsName = parseName(name);\n  var builder = new DescriptorBuilder(nsName);\n  this.mapTypes(nsName, function (type, inherited) {\n    builder.addTrait(type, inherited);\n  });\n  var descriptor = builder.build();\n\n  // define package link\n  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);\n  return descriptor;\n};\nRegistry.prototype.definePackage = function (target, pkg) {\n  this.properties.define(target, '$pkg', {\n    value: pkg\n  });\n};\n\n///////// helpers ////////////////////////////\n\nfunction ensureAvailable(packageMap, pkg, identifierKey) {\n  var value = pkg[identifierKey];\n  if (value in packageMap) {\n    throw new Error('package with ' + identifierKey + ' <' + value + '> already defined');\n  }\n}\n\n/**\n * A utility that gets and sets properties of model elements.\n *\n * @param {Model} model\n */\nfunction Properties(model) {\n  this.model = model;\n}\n\n/**\n * Sets a named property on the target element.\n * If the value is undefined, the property gets deleted.\n *\n * @param {Object} target\n * @param {String} name\n * @param {Object} value\n */\nProperties.prototype.set = function (target, name, value) {\n  if (!isString(name) || !name.length) {\n    throw new TypeError('property name must be a non-empty string');\n  }\n  var property = this.model.getPropertyDescriptor(target, name);\n  var propertyName = property && property.name;\n  if (isUndefined(value)) {\n    // unset the property, if the specified value is undefined;\n    // delete from $attrs (for extensions) or the target itself\n    if (property) {\n      delete target[propertyName];\n    } else {\n      delete target.$attrs[name];\n    }\n  } else {\n    // set the property, defining well defined properties on the fly\n    // or simply updating them in target.$attrs (for extensions)\n    if (property) {\n      if (propertyName in target) {\n        target[propertyName] = value;\n      } else {\n        defineProperty(target, property, value);\n      }\n    } else {\n      target.$attrs[name] = value;\n    }\n  }\n};\n\n/**\n * Returns the named property of the given element\n *\n * @param  {Object} target\n * @param  {String} name\n *\n * @return {Object}\n */\nProperties.prototype.get = function (target, name) {\n  var property = this.model.getPropertyDescriptor(target, name);\n  if (!property) {\n    return target.$attrs[name];\n  }\n  var propertyName = property.name;\n\n  // check if access to collection property and lazily initialize it\n  if (!target[propertyName] && property.isMany) {\n    defineProperty(target, property, []);\n  }\n  return target[propertyName];\n};\n\n/**\n * Define a property on the target element\n *\n * @param  {Object} target\n * @param  {String} name\n * @param  {Object} options\n */\nProperties.prototype.define = function (target, name, options) {\n  if (!options.writable) {\n    var value = options.value;\n\n    // use getters for read-only variables to support ES6 proxies\n    // cf. https://github.com/bpmn-io/internal-docs/issues/386\n    options = assign({}, options, {\n      get: function () {\n        return value;\n      }\n    });\n    delete options.value;\n  }\n  Object.defineProperty(target, name, options);\n};\n\n/**\n * Define the descriptor for an element\n */\nProperties.prototype.defineDescriptor = function (target, descriptor) {\n  this.define(target, '$descriptor', {\n    value: descriptor\n  });\n};\n\n/**\n * Define the model for an element\n */\nProperties.prototype.defineModel = function (target, model) {\n  this.define(target, '$model', {\n    value: model\n  });\n};\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\nfunction defineProperty(target, property, value) {\n  Object.defineProperty(target, property.name, {\n    enumerable: !property.isReference,\n    writable: true,\n    value: value,\n    configurable: true\n  });\n}\n\n//// Moddle implementation /////////////////////////////////////////////////\n\n/**\n * @class Moddle\n *\n * A model that can be used to create elements of a specific type.\n *\n * @example\n *\n * var Moddle = require('moddle');\n *\n * var pkg = {\n *   name: 'mypackage',\n *   prefix: 'my',\n *   types: [\n *     { name: 'Root' }\n *   ]\n * };\n *\n * var moddle = new Moddle([pkg]);\n *\n * @param {Array<Package>} packages the packages to contain\n */\nfunction Moddle(packages) {\n  this.properties = new Properties(this);\n  this.factory = new Factory(this, this.properties);\n  this.registry = new Registry(packages, this.properties);\n  this.typeCache = {};\n}\n\n/**\n * Create an instance of the specified type.\n *\n * @method Moddle#create\n *\n * @example\n *\n * var foo = moddle.create('my:Foo');\n * var bar = moddle.create('my:Bar', { id: 'BAR_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @param  {Object} attrs   a number of attributes to initialize the model instance with\n * @return {Object}         model instance\n */\nModdle.prototype.create = function (descriptor, attrs) {\n  var Type = this.getType(descriptor);\n  if (!Type) {\n    throw new Error('unknown type <' + descriptor + '>');\n  }\n  return new Type(attrs);\n};\n\n/**\n * Returns the type representing a given descriptor\n *\n * @method Moddle#getType\n *\n * @example\n *\n * var Foo = moddle.getType('my:Foo');\n * var foo = new Foo({ 'id' : 'FOO_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @return {Object}         the type representing the descriptor\n */\nModdle.prototype.getType = function (descriptor) {\n  var cache = this.typeCache;\n  var name = isString(descriptor) ? descriptor : descriptor.ns.name;\n  var type = cache[name];\n  if (!type) {\n    descriptor = this.registry.getEffectiveDescriptor(name);\n    type = cache[name] = this.factory.createType(descriptor);\n  }\n  return type;\n};\n\n/**\n * Creates an any-element type to be used within model instances.\n *\n * This can be used to create custom elements that lie outside the meta-model.\n * The created element contains all the meta-data required to serialize it\n * as part of meta-model elements.\n *\n * @method Moddle#createAny\n *\n * @example\n *\n * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {\n *   value: 'bar'\n * });\n *\n * var container = moddle.create('my:Container', 'http://my', {\n *   any: [ foo ]\n * });\n *\n * // go ahead and serialize the stuff\n *\n *\n * @param  {String} name  the name of the element\n * @param  {String} nsUri the namespace uri of the element\n * @param  {Object} [properties] a map of properties to initialize the instance with\n * @return {Object} the any type instance\n */\nModdle.prototype.createAny = function (name, nsUri, properties) {\n  var nameNs = parseName(name);\n  var element = {\n    $type: name,\n    $instanceOf: function (type) {\n      return type === this.$type;\n    }\n  };\n  var descriptor = {\n    name: name,\n    isGeneric: true,\n    ns: {\n      prefix: nameNs.prefix,\n      localName: nameNs.localName,\n      uri: nsUri\n    }\n  };\n  this.properties.defineDescriptor(element, descriptor);\n  this.properties.defineModel(element, this);\n  this.properties.define(element, '$parent', {\n    enumerable: false,\n    writable: true\n  });\n  this.properties.define(element, '$instanceOf', {\n    enumerable: false,\n    writable: true\n  });\n  forEach(properties, function (a, key) {\n    if (isObject(a) && a.value !== undefined) {\n      element[a.name] = a.value;\n    } else {\n      element[key] = a;\n    }\n  });\n  return element;\n};\n\n/**\n * Returns a registered package by uri or prefix\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackage = function (uriOrPrefix) {\n  return this.registry.getPackage(uriOrPrefix);\n};\n\n/**\n * Returns a snapshot of all known packages\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackages = function () {\n  return this.registry.getPackages();\n};\n\n/**\n * Returns the descriptor for an element\n */\nModdle.prototype.getElementDescriptor = function (element) {\n  return element.$descriptor;\n};\n\n/**\n * Returns true if the given descriptor or instance\n * represents the given type.\n *\n * May be applied to this, if element is omitted.\n */\nModdle.prototype.hasType = function (element, type) {\n  if (type === undefined) {\n    type = element;\n    element = this;\n  }\n  var descriptor = element.$model.getElementDescriptor(element);\n  return type in descriptor.allTypesByName;\n};\n\n/**\n * Returns the descriptor of an elements named property\n */\nModdle.prototype.getPropertyDescriptor = function (element, property) {\n  return this.getElementDescriptor(element).propertiesByName[property];\n};\n\n/**\n * Returns a mapped type's descriptor\n */\nModdle.prototype.getTypeDescriptor = function (type) {\n  return this.registry.typeMap[type];\n};\nexport { Moddle, coerceType, isBuiltIn as isBuiltInType, isSimple as isSimpleType, parseName as parseNameNS };","map":{"version":3,"names":["forEach","bind","pick","assign","isString","isObject","Base","prototype","get","name","$model","properties","set","value","Factory","model","createType","descriptor","props","Object","create","p","isMany","default","undefined","defineModel","defineDescriptor","ns","ModdleElement","attrs","define","enumerable","writable","val","key","hasType","$instanceOf","BUILTINS","String","Boolean","Integer","Real","Element","TYPE_CONVERTERS","s","parseInt","parseFloat","coerceType","type","converter","isBuiltIn","isSimple","parseName","defaultPrefix","parts","split","localName","prefix","length","Error","DescriptorBuilder","nameNs","allTypes","allTypesByName","propertiesByName","build","addProperty","idx","validate","addNamedProperty","splice","push","replaceProperty","oldProperty","newProperty","replace","oldNameNs","rename","isId","setIdProperty","isBody","setBodyProperty","indexOf","redefineProperty","targetPropertyName","nsPrefix","attrName","redefinedProperty","redefines","propsByName","assertNotDefined","removeNamedProperty","bodyProperty","idProperty","propertyName","definedProperty","definedBy","hasProperty","addTrait","t","inherited","typesByName","types","typeName","defineProperty","replaces","Registry","packages","packageMap","typeMap","registerPackage","getPackage","uriOrPrefix","getPackages","pkg","pkgMap","ensureAvailable","registerType","uri","superClass","slice","extends","meta","propertyNs","extendsName","extended","traits","definePackage","mapTypes","nsName","iterator","trait","self","traverseTrait","cls","traverseSuper","parentNs","getEffectiveDescriptor","builder","$pkg","target","identifierKey","Properties","TypeError","property","getPropertyDescriptor","isUndefined","$attrs","options","isReference","configurable","Moddle","factory","registry","typeCache","Type","getType","cache","createAny","nsUri","element","$type","isGeneric","a","getElementDescriptor","$descriptor","getTypeDescriptor","isBuiltInType","isSimpleType","parseNameNS"],"sources":["C:/Users/KondalaRaoThota/Truviq_Camunda/camunda-react/node_modules/moddle/dist/index.esm.js"],"sourcesContent":["import { forEach, bind, pick, assign, isString, isObject } from 'min-dash';\n\n/**\n * Moddle base element.\n */\nfunction Base() { }\n\nBase.prototype.get = function(name) {\n  return this.$model.properties.get(this, name);\n};\n\nBase.prototype.set = function(name, value) {\n  this.$model.properties.set(this, name, value);\n};\n\n/**\n * A model element factory.\n *\n * @param {Moddle} model\n * @param {Properties} properties\n */\nfunction Factory(model, properties) {\n  this.model = model;\n  this.properties = properties;\n}\n\n\nFactory.prototype.createType = function(descriptor) {\n\n  var model = this.model;\n\n  var props = this.properties,\n      prototype = Object.create(Base.prototype);\n\n  // initialize default values\n  forEach(descriptor.properties, function(p) {\n    if (!p.isMany && p.default !== undefined) {\n      prototype[p.name] = p.default;\n    }\n  });\n\n  props.defineModel(prototype, model);\n  props.defineDescriptor(prototype, descriptor);\n\n  var name = descriptor.ns.name;\n\n  /**\n   * The new type constructor\n   */\n  function ModdleElement(attrs) {\n    props.define(this, '$type', { value: name, enumerable: true });\n    props.define(this, '$attrs', { value: {} });\n    props.define(this, '$parent', { writable: true });\n\n    forEach(attrs, bind(function(val, key) {\n      this.set(key, val);\n    }, this));\n  }\n\n  ModdleElement.prototype = prototype;\n\n  ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;\n\n  // static links\n  props.defineModel(ModdleElement, model);\n  props.defineDescriptor(ModdleElement, descriptor);\n\n  return ModdleElement;\n};\n\n/**\n * Built-in moddle types\n */\nvar BUILTINS = {\n  String: true,\n  Boolean: true,\n  Integer: true,\n  Real: true,\n  Element: true\n};\n\n/**\n * Converters for built in types from string representations\n */\nvar TYPE_CONVERTERS = {\n  String: function(s) { return s; },\n  Boolean: function(s) { return s === 'true'; },\n  Integer: function(s) { return parseInt(s, 10); },\n  Real: function(s) { return parseFloat(s); }\n};\n\n/**\n * Convert a type to its real representation\n */\nfunction coerceType(type, value) {\n\n  var converter = TYPE_CONVERTERS[type];\n\n  if (converter) {\n    return converter(value);\n  } else {\n    return value;\n  }\n}\n\n/**\n * Return whether the given type is built-in\n */\nfunction isBuiltIn(type) {\n  return !!BUILTINS[type];\n}\n\n/**\n * Return whether the given type is simple\n */\nfunction isSimple(type) {\n  return !!TYPE_CONVERTERS[type];\n}\n\n/**\n * Parses a namespaced attribute name of the form (ns:)localName to an object,\n * given a default prefix to assume in case no explicit namespace is given.\n *\n * @param {String} name\n * @param {String} [defaultPrefix] the default prefix to take, if none is present.\n *\n * @return {Object} the parsed name\n */\nfunction parseName(name, defaultPrefix) {\n  var parts = name.split(/:/),\n      localName, prefix;\n\n  // no prefix (i.e. only local name)\n  if (parts.length === 1) {\n    localName = name;\n    prefix = defaultPrefix;\n  } else\n  // prefix + local name\n  if (parts.length === 2) {\n    localName = parts[1];\n    prefix = parts[0];\n  } else {\n    throw new Error('expected <prefix:localName> or <localName>, got ' + name);\n  }\n\n  name = (prefix ? prefix + ':' : '') + localName;\n\n  return {\n    name: name,\n    prefix: prefix,\n    localName: localName\n  };\n}\n\n/**\n * A utility to build element descriptors.\n */\nfunction DescriptorBuilder(nameNs) {\n  this.ns = nameNs;\n  this.name = nameNs.name;\n  this.allTypes = [];\n  this.allTypesByName = {};\n  this.properties = [];\n  this.propertiesByName = {};\n}\n\n\nDescriptorBuilder.prototype.build = function() {\n  return pick(this, [\n    'ns',\n    'name',\n    'allTypes',\n    'allTypesByName',\n    'properties',\n    'propertiesByName',\n    'bodyProperty',\n    'idProperty'\n  ]);\n};\n\n/**\n * Add property at given index.\n *\n * @param {Object} p\n * @param {Number} [idx]\n * @param {Boolean} [validate=true]\n */\nDescriptorBuilder.prototype.addProperty = function(p, idx, validate) {\n\n  if (typeof idx === 'boolean') {\n    validate = idx;\n    idx = undefined;\n  }\n\n  this.addNamedProperty(p, validate !== false);\n\n  var properties = this.properties;\n\n  if (idx !== undefined) {\n    properties.splice(idx, 0, p);\n  } else {\n    properties.push(p);\n  }\n};\n\n\nDescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty, replace) {\n  var oldNameNs = oldProperty.ns;\n\n  var props = this.properties,\n      propertiesByName = this.propertiesByName,\n      rename = oldProperty.name !== newProperty.name;\n\n  if (oldProperty.isId) {\n    if (!newProperty.isId) {\n      throw new Error(\n        'property <' + newProperty.ns.name + '> must be id property ' +\n        'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    this.setIdProperty(newProperty, false);\n  }\n\n  if (oldProperty.isBody) {\n\n    if (!newProperty.isBody) {\n      throw new Error(\n        'property <' + newProperty.ns.name + '> must be body property ' +\n        'to refine <' + oldProperty.ns.name + '>');\n    }\n\n    // TODO: Check compatibility\n    this.setBodyProperty(newProperty, false);\n  }\n\n  // validate existence and get location of old property\n  var idx = props.indexOf(oldProperty);\n  if (idx === -1) {\n    throw new Error('property <' + oldNameNs.name + '> not found in property list');\n  }\n\n  // remove old property\n  props.splice(idx, 1);\n\n  // replacing the named property is intentional\n  //\n  //  * validate only if this is a \"rename\" operation\n  //  * add at specific index unless we \"replace\"\n  //\n  this.addProperty(newProperty, replace ? undefined : idx, rename);\n\n  // make new property available under old name\n  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;\n};\n\n\nDescriptorBuilder.prototype.redefineProperty = function(p, targetPropertyName, replace) {\n\n  var nsPrefix = p.ns.prefix;\n  var parts = targetPropertyName.split('#');\n\n  var name = parseName(parts[0], nsPrefix);\n  var attrName = parseName(parts[1], name.prefix).name;\n\n  var redefinedProperty = this.propertiesByName[attrName];\n  if (!redefinedProperty) {\n    throw new Error('refined property <' + attrName + '> not found');\n  } else {\n    this.replaceProperty(redefinedProperty, p, replace);\n  }\n\n  delete p.redefines;\n};\n\nDescriptorBuilder.prototype.addNamedProperty = function(p, validate) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n\n  if (validate) {\n    this.assertNotDefined(p, ns.name);\n    this.assertNotDefined(p, ns.localName);\n  }\n\n  propsByName[ns.name] = propsByName[ns.localName] = p;\n};\n\nDescriptorBuilder.prototype.removeNamedProperty = function(p) {\n  var ns = p.ns,\n      propsByName = this.propertiesByName;\n\n  delete propsByName[ns.name];\n  delete propsByName[ns.localName];\n};\n\nDescriptorBuilder.prototype.setBodyProperty = function(p, validate) {\n\n  if (validate && this.bodyProperty) {\n    throw new Error(\n      'body property defined multiple times ' +\n      '(<' + this.bodyProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.bodyProperty = p;\n};\n\nDescriptorBuilder.prototype.setIdProperty = function(p, validate) {\n\n  if (validate && this.idProperty) {\n    throw new Error(\n      'id property defined multiple times ' +\n      '(<' + this.idProperty.ns.name + '>, <' + p.ns.name + '>)');\n  }\n\n  this.idProperty = p;\n};\n\nDescriptorBuilder.prototype.assertNotDefined = function(p, name) {\n  var propertyName = p.name,\n      definedProperty = this.propertiesByName[propertyName];\n\n  if (definedProperty) {\n    throw new Error(\n      'property <' + propertyName + '> already defined; ' +\n      'override of <' + definedProperty.definedBy.ns.name + '#' + definedProperty.ns.name + '> by ' +\n      '<' + p.definedBy.ns.name + '#' + p.ns.name + '> not allowed without redefines');\n  }\n};\n\nDescriptorBuilder.prototype.hasProperty = function(name) {\n  return this.propertiesByName[name];\n};\n\nDescriptorBuilder.prototype.addTrait = function(t, inherited) {\n\n  var typesByName = this.allTypesByName,\n      types = this.allTypes;\n\n  var typeName = t.name;\n\n  if (typeName in typesByName) {\n    return;\n  }\n\n  forEach(t.properties, bind(function(p) {\n\n    // clone property to allow extensions\n    p = assign({}, p, {\n      name: p.ns.localName,\n      inherited: inherited\n    });\n\n    Object.defineProperty(p, 'definedBy', {\n      value: t\n    });\n\n    var replaces = p.replaces,\n        redefines = p.redefines;\n\n    // add replace/redefine support\n    if (replaces || redefines) {\n      this.redefineProperty(p, replaces || redefines, replaces);\n    } else {\n      if (p.isBody) {\n        this.setBodyProperty(p);\n      }\n      if (p.isId) {\n        this.setIdProperty(p);\n      }\n      this.addProperty(p);\n    }\n  }, this));\n\n  types.push(t);\n  typesByName[typeName] = t;\n};\n\n/**\n * A registry of Moddle packages.\n *\n * @param {Array<Package>} packages\n * @param {Properties} properties\n */\nfunction Registry(packages, properties) {\n  this.packageMap = {};\n  this.typeMap = {};\n\n  this.packages = [];\n\n  this.properties = properties;\n\n  forEach(packages, bind(this.registerPackage, this));\n}\n\n\nRegistry.prototype.getPackage = function(uriOrPrefix) {\n  return this.packageMap[uriOrPrefix];\n};\n\nRegistry.prototype.getPackages = function() {\n  return this.packages;\n};\n\n\nRegistry.prototype.registerPackage = function(pkg) {\n\n  // copy package\n  pkg = assign({}, pkg);\n\n  var pkgMap = this.packageMap;\n\n  ensureAvailable(pkgMap, pkg, 'prefix');\n  ensureAvailable(pkgMap, pkg, 'uri');\n\n  // register types\n  forEach(pkg.types, bind(function(descriptor) {\n    this.registerType(descriptor, pkg);\n  }, this));\n\n  pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;\n  this.packages.push(pkg);\n};\n\n\n/**\n * Register a type from a specific package with us\n */\nRegistry.prototype.registerType = function(type, pkg) {\n\n  type = assign({}, type, {\n    superClass: (type.superClass || []).slice(),\n    extends: (type.extends || []).slice(),\n    properties: (type.properties || []).slice(),\n    meta: assign((type.meta || {}))\n  });\n\n  var ns = parseName(type.name, pkg.prefix),\n      name = ns.name,\n      propertiesByName = {};\n\n  // parse properties\n  forEach(type.properties, bind(function(p) {\n\n    // namespace property names\n    var propertyNs = parseName(p.name, ns.prefix),\n        propertyName = propertyNs.name;\n\n    // namespace property types\n    if (!isBuiltIn(p.type)) {\n      p.type = parseName(p.type, propertyNs.prefix).name;\n    }\n\n    assign(p, {\n      ns: propertyNs,\n      name: propertyName\n    });\n\n    propertiesByName[propertyName] = p;\n  }, this));\n\n  // update ns + name\n  assign(type, {\n    ns: ns,\n    name: name,\n    propertiesByName: propertiesByName\n  });\n\n  forEach(type.extends, bind(function(extendsName) {\n    var extended = this.typeMap[extendsName];\n\n    extended.traits = extended.traits || [];\n    extended.traits.push(name);\n  }, this));\n\n  // link to package\n  this.definePackage(type, pkg);\n\n  // register\n  this.typeMap[name] = type;\n};\n\n\n/**\n * Traverse the type hierarchy from bottom to top,\n * calling iterator with (type, inherited) for all elements in\n * the inheritance chain.\n *\n * @param {Object} nsName\n * @param {Function} iterator\n * @param {Boolean} [trait=false]\n */\nRegistry.prototype.mapTypes = function(nsName, iterator, trait) {\n\n  var type = isBuiltIn(nsName.name) ? { name: nsName.name } : this.typeMap[nsName.name];\n\n  var self = this;\n\n  /**\n   * Traverse the selected trait.\n   *\n   * @param {String} cls\n   */\n  function traverseTrait(cls) {\n    return traverseSuper(cls, true);\n  }\n\n  /**\n   * Traverse the selected super type or trait\n   *\n   * @param {String} cls\n   * @param {Boolean} [trait=false]\n   */\n  function traverseSuper(cls, trait) {\n    var parentNs = parseName(cls, isBuiltIn(cls) ? '' : nsName.prefix);\n    self.mapTypes(parentNs, iterator, trait);\n  }\n\n  if (!type) {\n    throw new Error('unknown type <' + nsName.name + '>');\n  }\n\n  forEach(type.superClass, trait ? traverseTrait : traverseSuper);\n\n  // call iterator with (type, inherited=!trait)\n  iterator(type, !trait);\n\n  forEach(type.traits, traverseTrait);\n};\n\n\n/**\n * Returns the effective descriptor for a type.\n *\n * @param  {String} type the namespaced name (ns:localName) of the type\n *\n * @return {Descriptor} the resulting effective descriptor\n */\nRegistry.prototype.getEffectiveDescriptor = function(name) {\n\n  var nsName = parseName(name);\n\n  var builder = new DescriptorBuilder(nsName);\n\n  this.mapTypes(nsName, function(type, inherited) {\n    builder.addTrait(type, inherited);\n  });\n\n  var descriptor = builder.build();\n\n  // define package link\n  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);\n\n  return descriptor;\n};\n\n\nRegistry.prototype.definePackage = function(target, pkg) {\n  this.properties.define(target, '$pkg', { value: pkg });\n};\n\n\n\n///////// helpers ////////////////////////////\n\nfunction ensureAvailable(packageMap, pkg, identifierKey) {\n\n  var value = pkg[identifierKey];\n\n  if (value in packageMap) {\n    throw new Error('package with ' + identifierKey + ' <' + value + '> already defined');\n  }\n}\n\n/**\n * A utility that gets and sets properties of model elements.\n *\n * @param {Model} model\n */\nfunction Properties(model) {\n  this.model = model;\n}\n\n\n/**\n * Sets a named property on the target element.\n * If the value is undefined, the property gets deleted.\n *\n * @param {Object} target\n * @param {String} name\n * @param {Object} value\n */\nProperties.prototype.set = function(target, name, value) {\n\n  if (!isString(name) || !name.length) {\n    throw new TypeError('property name must be a non-empty string');\n  }\n\n  var property = this.model.getPropertyDescriptor(target, name);\n\n  var propertyName = property && property.name;\n\n  if (isUndefined(value)) {\n    // unset the property, if the specified value is undefined;\n    // delete from $attrs (for extensions) or the target itself\n    if (property) {\n      delete target[propertyName];\n    } else {\n      delete target.$attrs[name];\n    }\n  } else {\n    // set the property, defining well defined properties on the fly\n    // or simply updating them in target.$attrs (for extensions)\n    if (property) {\n      if (propertyName in target) {\n        target[propertyName] = value;\n      } else {\n        defineProperty(target, property, value);\n      }\n    } else {\n      target.$attrs[name] = value;\n    }\n  }\n};\n\n/**\n * Returns the named property of the given element\n *\n * @param  {Object} target\n * @param  {String} name\n *\n * @return {Object}\n */\nProperties.prototype.get = function(target, name) {\n\n  var property = this.model.getPropertyDescriptor(target, name);\n\n  if (!property) {\n    return target.$attrs[name];\n  }\n\n  var propertyName = property.name;\n\n  // check if access to collection property and lazily initialize it\n  if (!target[propertyName] && property.isMany) {\n    defineProperty(target, property, []);\n  }\n\n  return target[propertyName];\n};\n\n\n/**\n * Define a property on the target element\n *\n * @param  {Object} target\n * @param  {String} name\n * @param  {Object} options\n */\nProperties.prototype.define = function(target, name, options) {\n\n  if (!options.writable) {\n\n    var value = options.value;\n\n    // use getters for read-only variables to support ES6 proxies\n    // cf. https://github.com/bpmn-io/internal-docs/issues/386\n    options = assign({}, options, {\n      get: function() { return value; }\n    });\n\n    delete options.value;\n  }\n\n  Object.defineProperty(target, name, options);\n};\n\n\n/**\n * Define the descriptor for an element\n */\nProperties.prototype.defineDescriptor = function(target, descriptor) {\n  this.define(target, '$descriptor', { value: descriptor });\n};\n\n/**\n * Define the model for an element\n */\nProperties.prototype.defineModel = function(target, model) {\n  this.define(target, '$model', { value: model });\n};\n\n\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\nfunction defineProperty(target, property, value) {\n  Object.defineProperty(target, property.name, {\n    enumerable: !property.isReference,\n    writable: true,\n    value: value,\n    configurable: true\n  });\n}\n\n//// Moddle implementation /////////////////////////////////////////////////\n\n/**\n * @class Moddle\n *\n * A model that can be used to create elements of a specific type.\n *\n * @example\n *\n * var Moddle = require('moddle');\n *\n * var pkg = {\n *   name: 'mypackage',\n *   prefix: 'my',\n *   types: [\n *     { name: 'Root' }\n *   ]\n * };\n *\n * var moddle = new Moddle([pkg]);\n *\n * @param {Array<Package>} packages the packages to contain\n */\nfunction Moddle(packages) {\n\n  this.properties = new Properties(this);\n\n  this.factory = new Factory(this, this.properties);\n  this.registry = new Registry(packages, this.properties);\n\n  this.typeCache = {};\n}\n\n\n/**\n * Create an instance of the specified type.\n *\n * @method Moddle#create\n *\n * @example\n *\n * var foo = moddle.create('my:Foo');\n * var bar = moddle.create('my:Bar', { id: 'BAR_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @param  {Object} attrs   a number of attributes to initialize the model instance with\n * @return {Object}         model instance\n */\nModdle.prototype.create = function(descriptor, attrs) {\n  var Type = this.getType(descriptor);\n\n  if (!Type) {\n    throw new Error('unknown type <' + descriptor + '>');\n  }\n\n  return new Type(attrs);\n};\n\n\n/**\n * Returns the type representing a given descriptor\n *\n * @method Moddle#getType\n *\n * @example\n *\n * var Foo = moddle.getType('my:Foo');\n * var foo = new Foo({ 'id' : 'FOO_1' });\n *\n * @param  {String|Object} descriptor the type descriptor or name know to the model\n * @return {Object}         the type representing the descriptor\n */\nModdle.prototype.getType = function(descriptor) {\n\n  var cache = this.typeCache;\n\n  var name = isString(descriptor) ? descriptor : descriptor.ns.name;\n\n  var type = cache[name];\n\n  if (!type) {\n    descriptor = this.registry.getEffectiveDescriptor(name);\n    type = cache[name] = this.factory.createType(descriptor);\n  }\n\n  return type;\n};\n\n\n/**\n * Creates an any-element type to be used within model instances.\n *\n * This can be used to create custom elements that lie outside the meta-model.\n * The created element contains all the meta-data required to serialize it\n * as part of meta-model elements.\n *\n * @method Moddle#createAny\n *\n * @example\n *\n * var foo = moddle.createAny('vendor:Foo', 'http://vendor', {\n *   value: 'bar'\n * });\n *\n * var container = moddle.create('my:Container', 'http://my', {\n *   any: [ foo ]\n * });\n *\n * // go ahead and serialize the stuff\n *\n *\n * @param  {String} name  the name of the element\n * @param  {String} nsUri the namespace uri of the element\n * @param  {Object} [properties] a map of properties to initialize the instance with\n * @return {Object} the any type instance\n */\nModdle.prototype.createAny = function(name, nsUri, properties) {\n\n  var nameNs = parseName(name);\n\n  var element = {\n    $type: name,\n    $instanceOf: function(type) {\n      return type === this.$type;\n    }\n  };\n\n  var descriptor = {\n    name: name,\n    isGeneric: true,\n    ns: {\n      prefix: nameNs.prefix,\n      localName: nameNs.localName,\n      uri: nsUri\n    }\n  };\n\n  this.properties.defineDescriptor(element, descriptor);\n  this.properties.defineModel(element, this);\n  this.properties.define(element, '$parent', { enumerable: false, writable: true });\n  this.properties.define(element, '$instanceOf', { enumerable: false, writable: true });\n\n  forEach(properties, function(a, key) {\n    if (isObject(a) && a.value !== undefined) {\n      element[a.name] = a.value;\n    } else {\n      element[key] = a;\n    }\n  });\n\n  return element;\n};\n\n/**\n * Returns a registered package by uri or prefix\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackage = function(uriOrPrefix) {\n  return this.registry.getPackage(uriOrPrefix);\n};\n\n/**\n * Returns a snapshot of all known packages\n *\n * @return {Object} the package\n */\nModdle.prototype.getPackages = function() {\n  return this.registry.getPackages();\n};\n\n/**\n * Returns the descriptor for an element\n */\nModdle.prototype.getElementDescriptor = function(element) {\n  return element.$descriptor;\n};\n\n/**\n * Returns true if the given descriptor or instance\n * represents the given type.\n *\n * May be applied to this, if element is omitted.\n */\nModdle.prototype.hasType = function(element, type) {\n  if (type === undefined) {\n    type = element;\n    element = this;\n  }\n\n  var descriptor = element.$model.getElementDescriptor(element);\n\n  return (type in descriptor.allTypesByName);\n};\n\n/**\n * Returns the descriptor of an elements named property\n */\nModdle.prototype.getPropertyDescriptor = function(element, property) {\n  return this.getElementDescriptor(element).propertiesByName[property];\n};\n\n/**\n * Returns a mapped type's descriptor\n */\nModdle.prototype.getTypeDescriptor = function(type) {\n  return this.registry.typeMap[type];\n};\n\nexport { Moddle, coerceType, isBuiltIn as isBuiltInType, isSimple as isSimpleType, parseName as parseNameNS };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}