{"ast":null,"code":"'use strict';\n\n/**\n * An empty collection stub. Use {@link RefsCollection.extend} to extend a\n * collection with ref semantics.\n *\n * @class RefsCollection\n */\n\n/**\n * Extends a collection with {@link Refs} aware methods\n *\n * @memberof RefsCollection\n * @static\n *\n * @param  {Array<Object>} collection\n * @param  {Refs} refs instance\n * @param  {Object} property represented by the collection\n * @param  {Object} target object the collection is attached to\n *\n * @return {RefsCollection<Object>} the extended array\n */\nfunction extend(collection, refs, property, target) {\n  var inverseProperty = property.inverse;\n\n  /**\n   * Removes the given element from the array and returns it.\n   *\n   * @method RefsCollection#remove\n   *\n   * @param {Object} element the element to remove\n   */\n  Object.defineProperty(collection, 'remove', {\n    value: function (element) {\n      var idx = this.indexOf(element);\n      if (idx !== -1) {\n        this.splice(idx, 1);\n\n        // unset inverse\n        refs.unset(element, inverseProperty, target);\n      }\n      return element;\n    }\n  });\n\n  /**\n   * Returns true if the collection contains the given element\n   *\n   * @method RefsCollection#contains\n   *\n   * @param {Object} element the element to check for\n   */\n  Object.defineProperty(collection, 'contains', {\n    value: function (element) {\n      return this.indexOf(element) !== -1;\n    }\n  });\n\n  /**\n   * Adds an element to the array, unless it exists already (set semantics).\n   *\n   * @method RefsCollection#add\n   *\n   * @param {Object} element the element to add\n   * @param {Number} optional index to add element to\n   *                 (possibly moving other elements around)\n   */\n  Object.defineProperty(collection, 'add', {\n    value: function (element, idx) {\n      var currentIdx = this.indexOf(element);\n      if (typeof idx === 'undefined') {\n        if (currentIdx !== -1) {\n          // element already in collection (!)\n          return;\n        }\n\n        // add to end of array, as no idx is specified\n        idx = this.length;\n      }\n\n      // handle already in collection\n      if (currentIdx !== -1) {\n        // remove element from currentIdx\n        this.splice(currentIdx, 1);\n      }\n\n      // add element at idx\n      this.splice(idx, 0, element);\n      if (currentIdx === -1) {\n        // set inverse, unless element was\n        // in collection already\n        refs.set(element, inverseProperty, target);\n      }\n    }\n  });\n\n  // a simple marker, identifying this element\n  // as being a refs collection\n  Object.defineProperty(collection, '__refs_collection', {\n    value: true\n  });\n  return collection;\n}\nfunction isExtended(collection) {\n  return collection.__refs_collection === true;\n}\nmodule.exports.extend = extend;\nmodule.exports.isExtended = isExtended;","map":{"version":3,"names":["extend","collection","refs","property","target","inverseProperty","inverse","Object","defineProperty","value","element","idx","indexOf","splice","unset","currentIdx","length","set","isExtended","__refs_collection","module","exports"],"sources":["C:/Users/KondalaRaoThota/Truviq_Camunda/camunda-react/node_modules/object-refs/lib/collection.js"],"sourcesContent":["'use strict';\n\n/**\n * An empty collection stub. Use {@link RefsCollection.extend} to extend a\n * collection with ref semantics.\n *\n * @class RefsCollection\n */\n\n/**\n * Extends a collection with {@link Refs} aware methods\n *\n * @memberof RefsCollection\n * @static\n *\n * @param  {Array<Object>} collection\n * @param  {Refs} refs instance\n * @param  {Object} property represented by the collection\n * @param  {Object} target object the collection is attached to\n *\n * @return {RefsCollection<Object>} the extended array\n */\nfunction extend(collection, refs, property, target) {\n\n  var inverseProperty = property.inverse;\n\n  /**\n   * Removes the given element from the array and returns it.\n   *\n   * @method RefsCollection#remove\n   *\n   * @param {Object} element the element to remove\n   */\n  Object.defineProperty(collection, 'remove', {\n    value: function(element) {\n      var idx = this.indexOf(element);\n      if (idx !== -1) {\n        this.splice(idx, 1);\n\n        // unset inverse\n        refs.unset(element, inverseProperty, target);\n      }\n\n      return element;\n    }\n  });\n\n  /**\n   * Returns true if the collection contains the given element\n   *\n   * @method RefsCollection#contains\n   *\n   * @param {Object} element the element to check for\n   */\n  Object.defineProperty(collection, 'contains', {\n    value: function(element) {\n      return this.indexOf(element) !== -1;\n    }\n  });\n\n  /**\n   * Adds an element to the array, unless it exists already (set semantics).\n   *\n   * @method RefsCollection#add\n   *\n   * @param {Object} element the element to add\n   * @param {Number} optional index to add element to\n   *                 (possibly moving other elements around)\n   */\n  Object.defineProperty(collection, 'add', {\n    value: function(element, idx) {\n\n      var currentIdx = this.indexOf(element);\n\n      if (typeof idx === 'undefined') {\n\n        if (currentIdx !== -1) {\n          // element already in collection (!)\n          return;\n        }\n\n        // add to end of array, as no idx is specified\n        idx = this.length;\n      }\n\n      // handle already in collection\n      if (currentIdx !== -1) {\n\n        // remove element from currentIdx\n        this.splice(currentIdx, 1);\n      }\n\n      // add element at idx\n      this.splice(idx, 0, element);\n\n      if (currentIdx === -1) {\n        // set inverse, unless element was\n        // in collection already\n        refs.set(element, inverseProperty, target);\n      }\n    }\n  });\n\n  // a simple marker, identifying this element\n  // as being a refs collection\n  Object.defineProperty(collection, '__refs_collection', {\n    value: true\n  });\n\n  return collection;\n}\n\n\nfunction isExtended(collection) {\n  return collection.__refs_collection === true;\n}\n\nmodule.exports.extend = extend;\n\nmodule.exports.isExtended = isExtended;"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAMA,CAACC,UAAU,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,MAAM,EAAE;EAElD,IAAIC,eAAe,GAAGF,QAAQ,CAACG,OAAO;;EAEtC;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,MAAM,CAACC,cAAc,CAACP,UAAU,EAAE,QAAQ,EAAE;IAC1CQ,KAAK,EAAE,SAAAA,CAASC,OAAO,EAAE;MACvB,IAAIC,GAAG,GAAG,IAAI,CAACC,OAAO,CAACF,OAAO,CAAC;MAC/B,IAAIC,GAAG,KAAK,CAAC,CAAC,EAAE;QACd,IAAI,CAACE,MAAM,CAACF,GAAG,EAAE,CAAC,CAAC;;QAEnB;QACAT,IAAI,CAACY,KAAK,CAACJ,OAAO,EAAEL,eAAe,EAAED,MAAM,CAAC;MAC9C;MAEA,OAAOM,OAAO;IAChB;EACF,CAAC,CAAC;;EAEF;AACF;AACA;AACA;AACA;AACA;AACA;EACEH,MAAM,CAACC,cAAc,CAACP,UAAU,EAAE,UAAU,EAAE;IAC5CQ,KAAK,EAAE,SAAAA,CAASC,OAAO,EAAE;MACvB,OAAO,IAAI,CAACE,OAAO,CAACF,OAAO,CAAC,KAAK,CAAC,CAAC;IACrC;EACF,CAAC,CAAC;;EAEF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEH,MAAM,CAACC,cAAc,CAACP,UAAU,EAAE,KAAK,EAAE;IACvCQ,KAAK,EAAE,SAAAA,CAASC,OAAO,EAAEC,GAAG,EAAE;MAE5B,IAAII,UAAU,GAAG,IAAI,CAACH,OAAO,CAACF,OAAO,CAAC;MAEtC,IAAI,OAAOC,GAAG,KAAK,WAAW,EAAE;QAE9B,IAAII,UAAU,KAAK,CAAC,CAAC,EAAE;UACrB;UACA;QACF;;QAEA;QACAJ,GAAG,GAAG,IAAI,CAACK,MAAM;MACnB;;MAEA;MACA,IAAID,UAAU,KAAK,CAAC,CAAC,EAAE;QAErB;QACA,IAAI,CAACF,MAAM,CAACE,UAAU,EAAE,CAAC,CAAC;MAC5B;;MAEA;MACA,IAAI,CAACF,MAAM,CAACF,GAAG,EAAE,CAAC,EAAED,OAAO,CAAC;MAE5B,IAAIK,UAAU,KAAK,CAAC,CAAC,EAAE;QACrB;QACA;QACAb,IAAI,CAACe,GAAG,CAACP,OAAO,EAAEL,eAAe,EAAED,MAAM,CAAC;MAC5C;IACF;EACF,CAAC,CAAC;;EAEF;EACA;EACAG,MAAM,CAACC,cAAc,CAACP,UAAU,EAAE,mBAAmB,EAAE;IACrDQ,KAAK,EAAE;EACT,CAAC,CAAC;EAEF,OAAOR,UAAU;AACnB;AAGA,SAASiB,UAAUA,CAACjB,UAAU,EAAE;EAC9B,OAAOA,UAAU,CAACkB,iBAAiB,KAAK,IAAI;AAC9C;AAEAC,MAAM,CAACC,OAAO,CAACrB,MAAM,GAAGA,MAAM;AAE9BoB,MAAM,CAACC,OAAO,CAACH,UAAU,GAAGA,UAAU"},"metadata":{},"sourceType":"script"}