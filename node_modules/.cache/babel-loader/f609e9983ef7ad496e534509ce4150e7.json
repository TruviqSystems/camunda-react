{"ast":null,"code":"import { forEach, assign, find, filter, has, isString, findIndex } from 'min-dash';\nimport { Parser } from 'saxen';\nimport { coerceType, parseNameNS, isSimpleType, Moddle } from 'moddle';\nfunction hasLowerCaseAlias(pkg) {\n  return pkg.xml && pkg.xml.tagAlias === 'lowerCase';\n}\nvar DEFAULT_NS_MAP = {\n  'xsi': 'http://www.w3.org/2001/XMLSchema-instance',\n  'xml': 'http://www.w3.org/XML/1998/namespace'\n};\nvar XSI_TYPE = 'xsi:type';\nfunction serializeFormat(element) {\n  return element.xml && element.xml.serialize;\n}\nfunction serializeAsType(element) {\n  return serializeFormat(element) === XSI_TYPE;\n}\nfunction serializeAsProperty(element) {\n  return serializeFormat(element) === 'property';\n}\nfunction capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction aliasToName(aliasNs, pkg) {\n  if (!hasLowerCaseAlias(pkg)) {\n    return aliasNs.name;\n  }\n  return aliasNs.prefix + ':' + capitalize(aliasNs.localName);\n}\nfunction prefixedToName(nameNs, pkg) {\n  var name = nameNs.name,\n    localName = nameNs.localName;\n  var typePrefix = pkg.xml && pkg.xml.typePrefix;\n  if (typePrefix && localName.indexOf(typePrefix) === 0) {\n    return nameNs.prefix + ':' + localName.slice(typePrefix.length);\n  } else {\n    return name;\n  }\n}\nfunction normalizeXsiTypeName(name, model) {\n  var nameNs = parseNameNS(name);\n  var pkg = model.getPackage(nameNs.prefix);\n  return prefixedToName(nameNs, pkg);\n}\nfunction error(message) {\n  return new Error(message);\n}\n\n/**\r\n * Get the moddle descriptor for a given instance or type.\r\n *\r\n * @param  {ModdleElement|Function} element\r\n *\r\n * @return {Object} the moddle descriptor\r\n */\nfunction getModdleDescriptor(element) {\n  return element.$descriptor;\n}\n\n/**\r\n * A parse context.\r\n *\r\n * @class\r\n *\r\n * @param {Object} options\r\n * @param {ElementHandler} options.rootHandler the root handler for parsing a document\r\n * @param {boolean} [options.lax=false] whether or not to ignore invalid elements\r\n */\nfunction Context(options) {\n  /**\r\n   * @property {ElementHandler} rootHandler\r\n   */\n\n  /**\r\n   * @property {Boolean} lax\r\n   */\n\n  assign(this, options);\n  this.elementsById = {};\n  this.references = [];\n  this.warnings = [];\n\n  /**\r\n   * Add an unresolved reference.\r\n   *\r\n   * @param {Object} reference\r\n   */\n  this.addReference = function (reference) {\n    this.references.push(reference);\n  };\n\n  /**\r\n   * Add a processed element.\r\n   *\r\n   * @param {ModdleElement} element\r\n   */\n  this.addElement = function (element) {\n    if (!element) {\n      throw error('expected element');\n    }\n    var elementsById = this.elementsById;\n    var descriptor = getModdleDescriptor(element);\n    var idProperty = descriptor.idProperty,\n      id;\n    if (idProperty) {\n      id = element.get(idProperty.name);\n      if (id) {\n        // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar\n        if (!/^([a-z][\\w-.]*:)?[a-z_][\\w-.]*$/i.test(id)) {\n          throw new Error('illegal ID <' + id + '>');\n        }\n        if (elementsById[id]) {\n          throw error('duplicate ID <' + id + '>');\n        }\n        elementsById[id] = element;\n      }\n    }\n  };\n\n  /**\r\n   * Add an import warning.\r\n   *\r\n   * @param {Object} warning\r\n   * @param {String} warning.message\r\n   * @param {Error} [warning.error]\r\n   */\n  this.addWarning = function (warning) {\n    this.warnings.push(warning);\n  };\n}\nfunction BaseHandler() {}\nBaseHandler.prototype.handleEnd = function () {};\nBaseHandler.prototype.handleText = function () {};\nBaseHandler.prototype.handleNode = function () {};\n\n/**\r\n * A simple pass through handler that does nothing except for\r\n * ignoring all input it receives.\r\n *\r\n * This is used to ignore unknown elements and\r\n * attributes.\r\n */\nfunction NoopHandler() {}\nNoopHandler.prototype = Object.create(BaseHandler.prototype);\nNoopHandler.prototype.handleNode = function () {\n  return this;\n};\nfunction BodyHandler() {}\nBodyHandler.prototype = Object.create(BaseHandler.prototype);\nBodyHandler.prototype.handleText = function (text) {\n  this.body = (this.body || '') + text;\n};\nfunction ReferenceHandler(property, context) {\n  this.property = property;\n  this.context = context;\n}\nReferenceHandler.prototype = Object.create(BodyHandler.prototype);\nReferenceHandler.prototype.handleNode = function (node) {\n  if (this.element) {\n    throw error('expected no sub nodes');\n  } else {\n    this.element = this.createReference(node);\n  }\n  return this;\n};\nReferenceHandler.prototype.handleEnd = function () {\n  this.element.id = this.body;\n};\nReferenceHandler.prototype.createReference = function (node) {\n  return {\n    property: this.property.ns.name,\n    id: ''\n  };\n};\nfunction ValueHandler(propertyDesc, element) {\n  this.element = element;\n  this.propertyDesc = propertyDesc;\n}\nValueHandler.prototype = Object.create(BodyHandler.prototype);\nValueHandler.prototype.handleEnd = function () {\n  var value = this.body || '',\n    element = this.element,\n    propertyDesc = this.propertyDesc;\n  value = coerceType(propertyDesc.type, value);\n  if (propertyDesc.isMany) {\n    element.get(propertyDesc.name).push(value);\n  } else {\n    element.set(propertyDesc.name, value);\n  }\n};\nfunction BaseElementHandler() {}\nBaseElementHandler.prototype = Object.create(BodyHandler.prototype);\nBaseElementHandler.prototype.handleNode = function (node) {\n  var parser = this,\n    element = this.element;\n  if (!element) {\n    element = this.element = this.createElement(node);\n    this.context.addElement(element);\n  } else {\n    parser = this.handleChild(node);\n  }\n  return parser;\n};\n\n/**\r\n * @class Reader.ElementHandler\r\n *\r\n */\nfunction ElementHandler(model, typeName, context) {\n  this.model = model;\n  this.type = model.getType(typeName);\n  this.context = context;\n}\nElementHandler.prototype = Object.create(BaseElementHandler.prototype);\nElementHandler.prototype.addReference = function (reference) {\n  this.context.addReference(reference);\n};\nElementHandler.prototype.handleText = function (text) {\n  var element = this.element,\n    descriptor = getModdleDescriptor(element),\n    bodyProperty = descriptor.bodyProperty;\n  if (!bodyProperty) {\n    throw error('unexpected body text <' + text + '>');\n  }\n  BodyHandler.prototype.handleText.call(this, text);\n};\nElementHandler.prototype.handleEnd = function () {\n  var value = this.body,\n    element = this.element,\n    descriptor = getModdleDescriptor(element),\n    bodyProperty = descriptor.bodyProperty;\n  if (bodyProperty && value !== undefined) {\n    value = coerceType(bodyProperty.type, value);\n    element.set(bodyProperty.name, value);\n  }\n};\n\n/**\r\n * Create an instance of the model from the given node.\r\n *\r\n * @param  {Element} node the xml node\r\n */\nElementHandler.prototype.createElement = function (node) {\n  var attributes = node.attributes,\n    Type = this.type,\n    descriptor = getModdleDescriptor(Type),\n    context = this.context,\n    instance = new Type({}),\n    model = this.model,\n    propNameNs;\n  forEach(attributes, function (value, name) {\n    var prop = descriptor.propertiesByName[name],\n      values;\n    if (prop && prop.isReference) {\n      if (!prop.isMany) {\n        context.addReference({\n          element: instance,\n          property: prop.ns.name,\n          id: value\n        });\n      } else {\n        // IDREFS: parse references as whitespace-separated list\n        values = value.split(' ');\n        forEach(values, function (v) {\n          context.addReference({\n            element: instance,\n            property: prop.ns.name,\n            id: v\n          });\n        });\n      }\n    } else {\n      if (prop) {\n        value = coerceType(prop.type, value);\n      } else if (name !== 'xmlns') {\n        propNameNs = parseNameNS(name, descriptor.ns.prefix);\n\n        // check whether attribute is defined in a well-known namespace\n        // if that is the case we emit a warning to indicate potential misuse\n        if (model.getPackage(propNameNs.prefix)) {\n          context.addWarning({\n            message: 'unknown attribute <' + name + '>',\n            element: instance,\n            property: name,\n            value: value\n          });\n        }\n      }\n      instance.set(name, value);\n    }\n  });\n  return instance;\n};\nElementHandler.prototype.getPropertyForNode = function (node) {\n  var name = node.name;\n  var nameNs = parseNameNS(name);\n  var type = this.type,\n    model = this.model,\n    descriptor = getModdleDescriptor(type);\n  var propertyName = nameNs.name,\n    property = descriptor.propertiesByName[propertyName],\n    elementTypeName,\n    elementType;\n\n  // search for properties by name first\n\n  if (property && !property.isAttr) {\n    if (serializeAsType(property)) {\n      elementTypeName = node.attributes[XSI_TYPE];\n\n      // xsi type is optional, if it does not exists the\n      // default type is assumed\n      if (elementTypeName) {\n        // take possible type prefixes from XML\n        // into account, i.e.: xsi:type=\"t{ActualType}\"\n        elementTypeName = normalizeXsiTypeName(elementTypeName, model);\n        elementType = model.getType(elementTypeName);\n        return assign({}, property, {\n          effectiveType: getModdleDescriptor(elementType).name\n        });\n      }\n    }\n\n    // search for properties by name first\n    return property;\n  }\n  var pkg = model.getPackage(nameNs.prefix);\n  if (pkg) {\n    elementTypeName = aliasToName(nameNs, pkg);\n    elementType = model.getType(elementTypeName);\n\n    // search for collection members later\n    property = find(descriptor.properties, function (p) {\n      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);\n    });\n    if (property) {\n      return assign({}, property, {\n        effectiveType: getModdleDescriptor(elementType).name\n      });\n    }\n  } else {\n    // parse unknown element (maybe extension)\n    property = find(descriptor.properties, function (p) {\n      return !p.isReference && !p.isAttribute && p.type === 'Element';\n    });\n    if (property) {\n      return property;\n    }\n  }\n  throw error('unrecognized element <' + nameNs.name + '>');\n};\nElementHandler.prototype.toString = function () {\n  return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';\n};\nElementHandler.prototype.valueHandler = function (propertyDesc, element) {\n  return new ValueHandler(propertyDesc, element);\n};\nElementHandler.prototype.referenceHandler = function (propertyDesc) {\n  return new ReferenceHandler(propertyDesc, this.context);\n};\nElementHandler.prototype.handler = function (type) {\n  if (type === 'Element') {\n    return new GenericElementHandler(this.model, type, this.context);\n  } else {\n    return new ElementHandler(this.model, type, this.context);\n  }\n};\n\n/**\r\n * Handle the child element parsing\r\n *\r\n * @param  {Element} node the xml node\r\n */\nElementHandler.prototype.handleChild = function (node) {\n  var propertyDesc, type, element, childHandler;\n  propertyDesc = this.getPropertyForNode(node);\n  element = this.element;\n  type = propertyDesc.effectiveType || propertyDesc.type;\n  if (isSimpleType(type)) {\n    return this.valueHandler(propertyDesc, element);\n  }\n  if (propertyDesc.isReference) {\n    childHandler = this.referenceHandler(propertyDesc).handleNode(node);\n  } else {\n    childHandler = this.handler(type).handleNode(node);\n  }\n  var newElement = childHandler.element;\n\n  // child handles may decide to skip elements\n  // by not returning anything\n  if (newElement !== undefined) {\n    if (propertyDesc.isMany) {\n      element.get(propertyDesc.name).push(newElement);\n    } else {\n      element.set(propertyDesc.name, newElement);\n    }\n    if (propertyDesc.isReference) {\n      assign(newElement, {\n        element: element\n      });\n      this.context.addReference(newElement);\n    } else {\n      // establish child -> parent relationship\n      newElement.$parent = element;\n    }\n  }\n  return childHandler;\n};\n\n/**\r\n * An element handler that performs special validation\r\n * to ensure the node it gets initialized with matches\r\n * the handlers type (namespace wise).\r\n *\r\n * @param {Moddle} model\r\n * @param {String} typeName\r\n * @param {Context} context\r\n */\nfunction RootElementHandler(model, typeName, context) {\n  ElementHandler.call(this, model, typeName, context);\n}\nRootElementHandler.prototype = Object.create(ElementHandler.prototype);\nRootElementHandler.prototype.createElement = function (node) {\n  var name = node.name,\n    nameNs = parseNameNS(name),\n    model = this.model,\n    type = this.type,\n    pkg = model.getPackage(nameNs.prefix),\n    typeName = pkg && aliasToName(nameNs, pkg) || name;\n\n  // verify the correct namespace if we parse\n  // the first element in the handler tree\n  //\n  // this ensures we don't mistakenly import wrong namespace elements\n  if (!type.hasType(typeName)) {\n    throw error('unexpected element <' + node.originalName + '>');\n  }\n  return ElementHandler.prototype.createElement.call(this, node);\n};\nfunction GenericElementHandler(model, typeName, context) {\n  this.model = model;\n  this.context = context;\n}\nGenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);\nGenericElementHandler.prototype.createElement = function (node) {\n  var name = node.name,\n    ns = parseNameNS(name),\n    prefix = ns.prefix,\n    uri = node.ns[prefix + '$uri'],\n    attributes = node.attributes;\n  return this.model.createAny(name, uri, attributes);\n};\nGenericElementHandler.prototype.handleChild = function (node) {\n  var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),\n    element = this.element;\n  var newElement = handler.element,\n    children;\n  if (newElement !== undefined) {\n    children = element.$children = element.$children || [];\n    children.push(newElement);\n\n    // establish child -> parent relationship\n    newElement.$parent = element;\n  }\n  return handler;\n};\nGenericElementHandler.prototype.handleEnd = function () {\n  if (this.body) {\n    this.element.$body = this.body;\n  }\n};\n\n/**\r\n * A reader for a meta-model\r\n *\r\n * @param {Object} options\r\n * @param {Model} options.model used to read xml files\r\n * @param {Boolean} options.lax whether to make parse errors warnings\r\n */\nfunction Reader(options) {\n  if (options instanceof Moddle) {\n    options = {\n      model: options\n    };\n  }\n  assign(this, {\n    lax: false\n  }, options);\n}\n\n/**\r\n * The fromXML result.\r\n *\r\n * @typedef {Object} ParseResult\r\n *\r\n * @property {ModdleElement} rootElement\r\n * @property {Array<Object>} references\r\n * @property {Array<Error>} warnings\r\n * @property {Object} elementsById - a mapping containing each ID -> ModdleElement\r\n */\n\n/**\r\n * The fromXML result.\r\n *\r\n * @typedef {Error} ParseError\r\n *\r\n * @property {Array<Error>} warnings\r\n */\n\n/**\r\n * Parse the given XML into a moddle document tree.\r\n *\r\n * @param {String} xml\r\n * @param {ElementHandler|Object} options or rootHandler\r\n *\r\n * @returns {Promise<ParseResult, ParseError>}\r\n */\nReader.prototype.fromXML = function (xml, options, done) {\n  var rootHandler = options.rootHandler;\n  if (options instanceof ElementHandler) {\n    // root handler passed via (xml, { rootHandler: ElementHandler }, ...)\n    rootHandler = options;\n    options = {};\n  } else {\n    if (typeof options === 'string') {\n      // rootHandler passed via (xml, 'someString', ...)\n      rootHandler = this.handler(options);\n      options = {};\n    } else if (typeof rootHandler === 'string') {\n      // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)\n      rootHandler = this.handler(rootHandler);\n    }\n  }\n  var model = this.model,\n    lax = this.lax;\n  var context = new Context(assign({}, options, {\n      rootHandler: rootHandler\n    })),\n    parser = new Parser({\n      proxy: true\n    }),\n    stack = createStack();\n  rootHandler.context = context;\n\n  // push root handler\n  stack.push(rootHandler);\n\n  /**\r\n   * Handle error.\r\n   *\r\n   * @param  {Error} err\r\n   * @param  {Function} getContext\r\n   * @param  {boolean} lax\r\n   *\r\n   * @return {boolean} true if handled\r\n   */\n  function handleError(err, getContext, lax) {\n    var ctx = getContext();\n    var line = ctx.line,\n      column = ctx.column,\n      data = ctx.data;\n\n    // we receive the full context data here,\n    // for elements trim down the information\n    // to the tag name, only\n    if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {\n      data = data.slice(0, data.indexOf(' ')) + '>';\n    }\n    var message = 'unparsable content ' + (data ? data + ' ' : '') + 'detected\\n\\t' + 'line: ' + line + '\\n\\t' + 'column: ' + column + '\\n\\t' + 'nested error: ' + err.message;\n    if (lax) {\n      context.addWarning({\n        message: message,\n        error: err\n      });\n      return true;\n    } else {\n      throw error(message);\n    }\n  }\n  function handleWarning(err, getContext) {\n    // just like handling errors in <lax=true> mode\n    return handleError(err, getContext, true);\n  }\n\n  /**\r\n   * Resolve collected references on parse end.\r\n   */\n  function resolveReferences() {\n    var elementsById = context.elementsById;\n    var references = context.references;\n    var i, r;\n    for (i = 0; r = references[i]; i++) {\n      var element = r.element;\n      var reference = elementsById[r.id];\n      var property = getModdleDescriptor(element).propertiesByName[r.property];\n      if (!reference) {\n        context.addWarning({\n          message: 'unresolved reference <' + r.id + '>',\n          element: r.element,\n          property: r.property,\n          value: r.id\n        });\n      }\n      if (property.isMany) {\n        var collection = element.get(property.name),\n          idx = collection.indexOf(r);\n\n        // we replace an existing place holder (idx != -1) or\n        // append to the collection instead\n        if (idx === -1) {\n          idx = collection.length;\n        }\n        if (!reference) {\n          // remove unresolvable reference\n          collection.splice(idx, 1);\n        } else {\n          // add or update reference in collection\n          collection[idx] = reference;\n        }\n      } else {\n        element.set(property.name, reference);\n      }\n    }\n  }\n  function handleClose() {\n    stack.pop().handleEnd();\n  }\n  var PREAMBLE_START_PATTERN = /^<\\?xml /i;\n  var ENCODING_PATTERN = / encoding=\"([^\"]+)\"/i;\n  var UTF_8_PATTERN = /^utf-8$/i;\n  function handleQuestion(question) {\n    if (!PREAMBLE_START_PATTERN.test(question)) {\n      return;\n    }\n    var match = ENCODING_PATTERN.exec(question);\n    var encoding = match && match[1];\n    if (!encoding || UTF_8_PATTERN.test(encoding)) {\n      return;\n    }\n    context.addWarning({\n      message: 'unsupported document encoding <' + encoding + '>, ' + 'falling back to UTF-8'\n    });\n  }\n  function handleOpen(node, getContext) {\n    var handler = stack.peek();\n    try {\n      stack.push(handler.handleNode(node));\n    } catch (err) {\n      if (handleError(err, getContext, lax)) {\n        stack.push(new NoopHandler());\n      }\n    }\n  }\n  function handleCData(text, getContext) {\n    try {\n      stack.peek().handleText(text);\n    } catch (err) {\n      handleWarning(err, getContext);\n    }\n  }\n  function handleText(text, getContext) {\n    // strip whitespace only nodes, i.e. before\n    // <!CDATA[ ... ]> sections and in between tags\n\n    if (!text.trim()) {\n      return;\n    }\n    handleCData(text, getContext);\n  }\n  var uriMap = model.getPackages().reduce(function (uriMap, p) {\n    uriMap[p.uri] = p.prefix;\n    return uriMap;\n  }, {\n    'http://www.w3.org/XML/1998/namespace': 'xml' // add default xml ns\n  });\n\n  parser.ns(uriMap).on('openTag', function (obj, decodeStr, selfClosing, getContext) {\n    // gracefully handle unparsable attributes (attrs=false)\n    var attrs = obj.attrs || {};\n    var decodedAttrs = Object.keys(attrs).reduce(function (d, key) {\n      var value = decodeStr(attrs[key]);\n      d[key] = value;\n      return d;\n    }, {});\n    var node = {\n      name: obj.name,\n      originalName: obj.originalName,\n      attributes: decodedAttrs,\n      ns: obj.ns\n    };\n    handleOpen(node, getContext);\n  }).on('question', handleQuestion).on('closeTag', handleClose).on('cdata', handleCData).on('text', function (text, decodeEntities, getContext) {\n    handleText(decodeEntities(text), getContext);\n  }).on('error', handleError).on('warn', handleWarning);\n\n  // async XML parsing to make sure the execution environment\n  // (node or brower) is kept responsive and that certain optimization\n  // strategies can kick in.\n  return new Promise(function (resolve, reject) {\n    var err;\n    try {\n      parser.parse(xml);\n      resolveReferences();\n    } catch (e) {\n      err = e;\n    }\n    var rootElement = rootHandler.element;\n    if (!err && !rootElement) {\n      err = error('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');\n    }\n    var warnings = context.warnings;\n    var references = context.references;\n    var elementsById = context.elementsById;\n    if (err) {\n      err.warnings = warnings;\n      return reject(err);\n    } else {\n      return resolve({\n        rootElement: rootElement,\n        elementsById: elementsById,\n        references: references,\n        warnings: warnings\n      });\n    }\n  });\n};\nReader.prototype.handler = function (name) {\n  return new RootElementHandler(this.model, name);\n};\n\n// helpers //////////////////////////\n\nfunction createStack() {\n  var stack = [];\n  Object.defineProperty(stack, 'peek', {\n    value: function () {\n      return this[this.length - 1];\n    }\n  });\n  return stack;\n}\nvar XML_PREAMBLE = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\nvar ESCAPE_ATTR_CHARS = /<|>|'|\"|&|\\n\\r|\\n/g;\nvar ESCAPE_CHARS = /<|>|&/g;\nfunction Namespaces(parent) {\n  var prefixMap = {};\n  var uriMap = {};\n  var used = {};\n  var wellknown = [];\n  var custom = [];\n\n  // API\n\n  this.byUri = function (uri) {\n    return uriMap[uri] || parent && parent.byUri(uri);\n  };\n  this.add = function (ns, isWellknown) {\n    uriMap[ns.uri] = ns;\n    if (isWellknown) {\n      wellknown.push(ns);\n    } else {\n      custom.push(ns);\n    }\n    this.mapPrefix(ns.prefix, ns.uri);\n  };\n  this.uriByPrefix = function (prefix) {\n    return prefixMap[prefix || 'xmlns'];\n  };\n  this.mapPrefix = function (prefix, uri) {\n    prefixMap[prefix || 'xmlns'] = uri;\n  };\n  this.getNSKey = function (ns) {\n    return ns.prefix !== undefined ? ns.uri + '|' + ns.prefix : ns.uri;\n  };\n  this.logUsed = function (ns) {\n    var uri = ns.uri;\n    var nsKey = this.getNSKey(ns);\n    used[nsKey] = this.byUri(uri);\n\n    // Inform parent recursively about the usage of this NS\n    if (parent) {\n      parent.logUsed(ns);\n    }\n  };\n  this.getUsed = function (ns) {\n    function isUsed(ns) {\n      var nsKey = self.getNSKey(ns);\n      return used[nsKey];\n    }\n    var self = this;\n    var allNs = [].concat(wellknown, custom);\n    return allNs.filter(isUsed);\n  };\n}\nfunction lower(string) {\n  return string.charAt(0).toLowerCase() + string.slice(1);\n}\nfunction nameToAlias(name, pkg) {\n  if (hasLowerCaseAlias(pkg)) {\n    return lower(name);\n  } else {\n    return name;\n  }\n}\nfunction inherits(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n}\nfunction nsName(ns) {\n  if (isString(ns)) {\n    return ns;\n  } else {\n    return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;\n  }\n}\nfunction getNsAttrs(namespaces) {\n  return namespaces.getUsed().filter(function (ns) {\n    // do not serialize built in <xml> namespace\n    return ns.prefix !== 'xml';\n  }).map(function (ns) {\n    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');\n    return {\n      name: name,\n      value: ns.uri\n    };\n  });\n}\nfunction getElementNs(ns, descriptor) {\n  if (descriptor.isGeneric) {\n    return assign({\n      localName: descriptor.ns.localName\n    }, ns);\n  } else {\n    return assign({\n      localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg)\n    }, ns);\n  }\n}\nfunction getPropertyNs(ns, descriptor) {\n  return assign({\n    localName: descriptor.ns.localName\n  }, ns);\n}\nfunction getSerializableProperties(element) {\n  var descriptor = element.$descriptor;\n  return filter(descriptor.properties, function (p) {\n    var name = p.name;\n    if (p.isVirtual) {\n      return false;\n    }\n\n    // do not serialize defaults\n    if (!has(element, name)) {\n      return false;\n    }\n    var value = element[name];\n\n    // do not serialize default equals\n    if (value === p.default) {\n      return false;\n    }\n\n    // do not serialize null properties\n    if (value === null) {\n      return false;\n    }\n    return p.isMany ? value.length : true;\n  });\n}\nvar ESCAPE_ATTR_MAP = {\n  '\\n': '#10',\n  '\\n\\r': '#10',\n  '\"': '#34',\n  '\\'': '#39',\n  '<': '#60',\n  '>': '#62',\n  '&': '#38'\n};\nvar ESCAPE_MAP = {\n  '<': 'lt',\n  '>': 'gt',\n  '&': 'amp'\n};\nfunction escape(str, charPattern, replaceMap) {\n  // ensure we are handling strings here\n  str = isString(str) ? str : '' + str;\n  return str.replace(charPattern, function (s) {\n    return '&' + replaceMap[s] + ';';\n  });\n}\n\n/**\r\n * Escape a string attribute to not contain any bad values (line breaks, '\"', ...)\r\n *\r\n * @param {String} str the string to escape\r\n * @return {String} the escaped string\r\n */\nfunction escapeAttr(str) {\n  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);\n}\nfunction escapeBody(str) {\n  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);\n}\nfunction filterAttributes(props) {\n  return filter(props, function (p) {\n    return p.isAttr;\n  });\n}\nfunction filterContained(props) {\n  return filter(props, function (p) {\n    return !p.isAttr;\n  });\n}\nfunction ReferenceSerializer(tagName) {\n  this.tagName = tagName;\n}\nReferenceSerializer.prototype.build = function (element) {\n  this.element = element;\n  return this;\n};\nReferenceSerializer.prototype.serializeTo = function (writer) {\n  writer.appendIndent().append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>').appendNewLine();\n};\nfunction BodySerializer() {}\nBodySerializer.prototype.serializeValue = BodySerializer.prototype.serializeTo = function (writer) {\n  writer.append(this.escape ? escapeBody(this.value) : this.value);\n};\nBodySerializer.prototype.build = function (prop, value) {\n  this.value = value;\n  if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {\n    this.escape = true;\n  }\n  return this;\n};\nfunction ValueSerializer(tagName) {\n  this.tagName = tagName;\n}\ninherits(ValueSerializer, BodySerializer);\nValueSerializer.prototype.serializeTo = function (writer) {\n  writer.appendIndent().append('<' + this.tagName + '>');\n  this.serializeValue(writer);\n  writer.append('</' + this.tagName + '>').appendNewLine();\n};\nfunction ElementSerializer(parent, propertyDescriptor) {\n  this.body = [];\n  this.attrs = [];\n  this.parent = parent;\n  this.propertyDescriptor = propertyDescriptor;\n}\nElementSerializer.prototype.build = function (element) {\n  this.element = element;\n  var elementDescriptor = element.$descriptor,\n    propertyDescriptor = this.propertyDescriptor;\n  var otherAttrs, properties;\n  var isGeneric = elementDescriptor.isGeneric;\n  if (isGeneric) {\n    otherAttrs = this.parseGeneric(element);\n  } else {\n    otherAttrs = this.parseNsAttributes(element);\n  }\n  if (propertyDescriptor) {\n    this.ns = this.nsPropertyTagName(propertyDescriptor);\n  } else {\n    this.ns = this.nsTagName(elementDescriptor);\n  }\n\n  // compute tag name\n  this.tagName = this.addTagName(this.ns);\n  if (!isGeneric) {\n    properties = getSerializableProperties(element);\n    this.parseAttributes(filterAttributes(properties));\n    this.parseContainments(filterContained(properties));\n  }\n  this.parseGenericAttributes(element, otherAttrs);\n  return this;\n};\nElementSerializer.prototype.nsTagName = function (descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getElementNs(effectiveNs, descriptor);\n};\nElementSerializer.prototype.nsPropertyTagName = function (descriptor) {\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\n  return getPropertyNs(effectiveNs, descriptor);\n};\nElementSerializer.prototype.isLocalNs = function (ns) {\n  return ns.uri === this.ns.uri;\n};\n\n/**\r\n * Get the actual ns attribute name for the given element.\r\n *\r\n * @param {Object} element\r\n * @param {Boolean} [element.inherited=false]\r\n *\r\n * @return {Object} nsName\r\n */\nElementSerializer.prototype.nsAttributeName = function (element) {\n  var ns;\n  if (isString(element)) {\n    ns = parseNameNS(element);\n  } else {\n    ns = element.ns;\n  }\n\n  // return just local name for inherited attributes\n  if (element.inherited) {\n    return {\n      localName: ns.localName\n    };\n  }\n\n  // parse + log effective ns\n  var effectiveNs = this.logNamespaceUsed(ns);\n\n  // LOG ACTUAL namespace use\n  this.getNamespaces().logUsed(effectiveNs);\n\n  // strip prefix if same namespace like parent\n  if (this.isLocalNs(effectiveNs)) {\n    return {\n      localName: ns.localName\n    };\n  } else {\n    return assign({\n      localName: ns.localName\n    }, effectiveNs);\n  }\n};\nElementSerializer.prototype.parseGeneric = function (element) {\n  var self = this,\n    body = this.body;\n  var attributes = [];\n  forEach(element, function (val, key) {\n    var nonNsAttr;\n    if (key === '$body') {\n      body.push(new BodySerializer().build({\n        type: 'String'\n      }, val));\n    } else if (key === '$children') {\n      forEach(val, function (child) {\n        body.push(new ElementSerializer(self).build(child));\n      });\n    } else if (key.indexOf('$') !== 0) {\n      nonNsAttr = self.parseNsAttribute(element, key, val);\n      if (nonNsAttr) {\n        attributes.push({\n          name: key,\n          value: val\n        });\n      }\n    }\n  });\n  return attributes;\n};\nElementSerializer.prototype.parseNsAttribute = function (element, name, value) {\n  var model = element.$model;\n  var nameNs = parseNameNS(name);\n  var ns;\n\n  // parse xmlns:foo=\"http://foo.bar\"\n  if (nameNs.prefix === 'xmlns') {\n    ns = {\n      prefix: nameNs.localName,\n      uri: value\n    };\n  }\n\n  // parse xmlns=\"http://foo.bar\"\n  if (!nameNs.prefix && nameNs.localName === 'xmlns') {\n    ns = {\n      uri: value\n    };\n  }\n  if (!ns) {\n    return {\n      name: name,\n      value: value\n    };\n  }\n  if (model && model.getPackage(value)) {\n    // register well known namespace\n    this.logNamespace(ns, true, true);\n  } else {\n    // log custom namespace directly as used\n    var actualNs = this.logNamespaceUsed(ns, true);\n    this.getNamespaces().logUsed(actualNs);\n  }\n};\n\n/**\r\n * Parse namespaces and return a list of left over generic attributes\r\n *\r\n * @param  {Object} element\r\n * @return {Array<Object>}\r\n */\nElementSerializer.prototype.parseNsAttributes = function (element, attrs) {\n  var self = this;\n  var genericAttrs = element.$attrs;\n  var attributes = [];\n\n  // parse namespace attributes first\n  // and log them. push non namespace attributes to a list\n  // and process them later\n  forEach(genericAttrs, function (value, name) {\n    var nonNsAttr = self.parseNsAttribute(element, name, value);\n    if (nonNsAttr) {\n      attributes.push(nonNsAttr);\n    }\n  });\n  return attributes;\n};\nElementSerializer.prototype.parseGenericAttributes = function (element, attributes) {\n  var self = this;\n  forEach(attributes, function (attr) {\n    // do not serialize xsi:type attribute\n    // it is set manually based on the actual implementation type\n    if (attr.name === XSI_TYPE) {\n      return;\n    }\n    try {\n      self.addAttribute(self.nsAttributeName(attr.name), attr.value);\n    } catch (e) {\n      console.warn('missing namespace information for ', attr.name, '=', attr.value, 'on', element, e);\n    }\n  });\n};\nElementSerializer.prototype.parseContainments = function (properties) {\n  var self = this,\n    body = this.body,\n    element = this.element;\n  forEach(properties, function (p) {\n    var value = element.get(p.name),\n      isReference = p.isReference,\n      isMany = p.isMany;\n    if (!isMany) {\n      value = [value];\n    }\n    if (p.isBody) {\n      body.push(new BodySerializer().build(p, value[0]));\n    } else if (isSimpleType(p.type)) {\n      forEach(value, function (v) {\n        body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));\n      });\n    } else if (isReference) {\n      forEach(value, function (v) {\n        body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));\n      });\n    } else {\n      // allow serialization via type\n      // rather than element name\n      var asType = serializeAsType(p),\n        asProperty = serializeAsProperty(p);\n      forEach(value, function (v) {\n        var serializer;\n        if (asType) {\n          serializer = new TypeSerializer(self, p);\n        } else if (asProperty) {\n          serializer = new ElementSerializer(self, p);\n        } else {\n          serializer = new ElementSerializer(self);\n        }\n        body.push(serializer.build(v));\n      });\n    }\n  });\n};\nElementSerializer.prototype.getNamespaces = function (local) {\n  var namespaces = this.namespaces,\n    parent = this.parent,\n    parentNamespaces;\n  if (!namespaces) {\n    parentNamespaces = parent && parent.getNamespaces();\n    if (local || !parentNamespaces) {\n      this.namespaces = namespaces = new Namespaces(parentNamespaces);\n    } else {\n      namespaces = parentNamespaces;\n    }\n  }\n  return namespaces;\n};\nElementSerializer.prototype.logNamespace = function (ns, wellknown, local) {\n  var namespaces = this.getNamespaces(local);\n  var nsUri = ns.uri,\n    nsPrefix = ns.prefix;\n  var existing = namespaces.byUri(nsUri);\n  if (!existing || local) {\n    namespaces.add(ns, wellknown);\n  }\n  namespaces.mapPrefix(nsPrefix, nsUri);\n  return ns;\n};\nElementSerializer.prototype.logNamespaceUsed = function (ns, local) {\n  var element = this.element,\n    model = element.$model,\n    namespaces = this.getNamespaces(local);\n\n  // ns may be\n  //\n  //   * prefix only\n  //   * prefix:uri\n  //   * localName only\n\n  var prefix = ns.prefix,\n    uri = ns.uri,\n    newPrefix,\n    idx,\n    wellknownUri;\n\n  // handle anonymous namespaces (elementForm=unqualified), cf. #23\n  if (!prefix && !uri) {\n    return {\n      localName: ns.localName\n    };\n  }\n  wellknownUri = DEFAULT_NS_MAP[prefix] || model && (model.getPackage(prefix) || {}).uri;\n  uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);\n  if (!uri) {\n    throw new Error('no namespace uri given for prefix <' + prefix + '>');\n  }\n  ns = namespaces.byUri(uri);\n  if (!ns) {\n    newPrefix = prefix;\n    idx = 1;\n\n    // find a prefix that is not mapped yet\n    while (namespaces.uriByPrefix(newPrefix)) {\n      newPrefix = prefix + '_' + idx++;\n    }\n    ns = this.logNamespace({\n      prefix: newPrefix,\n      uri: uri\n    }, wellknownUri === uri);\n  }\n  if (prefix) {\n    namespaces.mapPrefix(prefix, uri);\n  }\n  return ns;\n};\nElementSerializer.prototype.parseAttributes = function (properties) {\n  var self = this,\n    element = this.element;\n  forEach(properties, function (p) {\n    var value = element.get(p.name);\n    if (p.isReference) {\n      if (!p.isMany) {\n        value = value.id;\n      } else {\n        var values = [];\n        forEach(value, function (v) {\n          values.push(v.id);\n        });\n\n        // IDREFS is a whitespace-separated list of references.\n        value = values.join(' ');\n      }\n    }\n    self.addAttribute(self.nsAttributeName(p), value);\n  });\n};\nElementSerializer.prototype.addTagName = function (nsTagName) {\n  var actualNs = this.logNamespaceUsed(nsTagName);\n  this.getNamespaces().logUsed(actualNs);\n  return nsName(nsTagName);\n};\nElementSerializer.prototype.addAttribute = function (name, value) {\n  var attrs = this.attrs;\n  if (isString(value)) {\n    value = escapeAttr(value);\n  }\n\n  // de-duplicate attributes\n  // https://github.com/bpmn-io/moddle-xml/issues/66\n  var idx = findIndex(attrs, function (element) {\n    return element.name.localName === name.localName && element.name.uri === name.uri && element.name.prefix === name.prefix;\n  });\n  var attr = {\n    name: name,\n    value: value\n  };\n  if (idx !== -1) {\n    attrs.splice(idx, 1, attr);\n  } else {\n    attrs.push(attr);\n  }\n};\nElementSerializer.prototype.serializeAttributes = function (writer) {\n  var attrs = this.attrs,\n    namespaces = this.namespaces;\n  if (namespaces) {\n    attrs = getNsAttrs(namespaces).concat(attrs);\n  }\n  forEach(attrs, function (a) {\n    writer.append(' ').append(nsName(a.name)).append('=\"').append(a.value).append('\"');\n  });\n};\nElementSerializer.prototype.serializeTo = function (writer) {\n  var firstBody = this.body[0],\n    indent = firstBody && firstBody.constructor !== BodySerializer;\n  writer.appendIndent().append('<' + this.tagName);\n  this.serializeAttributes(writer);\n  writer.append(firstBody ? '>' : ' />');\n  if (firstBody) {\n    if (indent) {\n      writer.appendNewLine().indent();\n    }\n    forEach(this.body, function (b) {\n      b.serializeTo(writer);\n    });\n    if (indent) {\n      writer.unindent().appendIndent();\n    }\n    writer.append('</' + this.tagName + '>');\n  }\n  writer.appendNewLine();\n};\n\n/**\r\n * A serializer for types that handles serialization of data types\r\n */\nfunction TypeSerializer(parent, propertyDescriptor) {\n  ElementSerializer.call(this, parent, propertyDescriptor);\n}\ninherits(TypeSerializer, ElementSerializer);\nTypeSerializer.prototype.parseNsAttributes = function (element) {\n  // extracted attributes\n  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element);\n  var descriptor = element.$descriptor;\n\n  // only serialize xsi:type if necessary\n  if (descriptor.name === this.propertyDescriptor.type) {\n    return attributes;\n  }\n  var typeNs = this.typeNs = this.nsTagName(descriptor);\n  this.getNamespaces().logUsed(this.typeNs);\n\n  // add xsi:type attribute to represent the elements\n  // actual type\n\n  var pkg = element.$model.getPackage(typeNs.uri),\n    typePrefix = pkg.xml && pkg.xml.typePrefix || '';\n  this.addAttribute(this.nsAttributeName(XSI_TYPE), (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName);\n  return attributes;\n};\nTypeSerializer.prototype.isLocalNs = function (ns) {\n  return ns.uri === (this.typeNs || this.ns).uri;\n};\nfunction SavingWriter() {\n  this.value = '';\n  this.write = function (str) {\n    this.value += str;\n  };\n}\nfunction FormatingWriter(out, format) {\n  var indent = [''];\n  this.append = function (str) {\n    out.write(str);\n    return this;\n  };\n  this.appendNewLine = function () {\n    if (format) {\n      out.write('\\n');\n    }\n    return this;\n  };\n  this.appendIndent = function () {\n    if (format) {\n      out.write(indent.join('  '));\n    }\n    return this;\n  };\n  this.indent = function () {\n    indent.push('');\n    return this;\n  };\n  this.unindent = function () {\n    indent.pop();\n    return this;\n  };\n}\n\n/**\r\n * A writer for meta-model backed document trees\r\n *\r\n * @param {Object} options output options to pass into the writer\r\n */\nfunction Writer(options) {\n  options = assign({\n    format: false,\n    preamble: true\n  }, options || {});\n  function toXML(tree, writer) {\n    var internalWriter = writer || new SavingWriter();\n    var formatingWriter = new FormatingWriter(internalWriter, options.format);\n    if (options.preamble) {\n      formatingWriter.append(XML_PREAMBLE);\n    }\n    new ElementSerializer().build(tree).serializeTo(formatingWriter);\n    if (!writer) {\n      return internalWriter.value;\n    }\n  }\n  return {\n    toXML: toXML\n  };\n}\nexport { Reader, Writer };","map":{"version":3,"names":["forEach","assign","find","filter","has","isString","findIndex","Parser","coerceType","parseNameNS","isSimpleType","Moddle","hasLowerCaseAlias","pkg","xml","tagAlias","DEFAULT_NS_MAP","XSI_TYPE","serializeFormat","element","serialize","serializeAsType","serializeAsProperty","capitalize","str","charAt","toUpperCase","slice","aliasToName","aliasNs","name","prefix","localName","prefixedToName","nameNs","typePrefix","indexOf","length","normalizeXsiTypeName","model","getPackage","error","message","Error","getModdleDescriptor","$descriptor","Context","options","elementsById","references","warnings","addReference","reference","push","addElement","descriptor","idProperty","id","get","test","addWarning","warning","BaseHandler","prototype","handleEnd","handleText","handleNode","NoopHandler","Object","create","BodyHandler","text","body","ReferenceHandler","property","context","node","createReference","ns","ValueHandler","propertyDesc","value","type","isMany","set","BaseElementHandler","parser","createElement","handleChild","ElementHandler","typeName","getType","bodyProperty","call","undefined","attributes","Type","instance","propNameNs","prop","propertiesByName","values","isReference","split","v","getPropertyForNode","propertyName","elementTypeName","elementType","isAttr","effectiveType","properties","p","isVirtual","isAttribute","hasType","toString","valueHandler","referenceHandler","handler","GenericElementHandler","childHandler","newElement","$parent","RootElementHandler","originalName","uri","createAny","children","$children","$body","Reader","lax","fromXML","done","rootHandler","proxy","stack","createStack","handleError","err","getContext","ctx","line","column","data","handleWarning","resolveReferences","i","r","collection","idx","splice","handleClose","pop","PREAMBLE_START_PATTERN","ENCODING_PATTERN","UTF_8_PATTERN","handleQuestion","question","match","exec","encoding","handleOpen","peek","handleCData","trim","uriMap","getPackages","reduce","on","obj","decodeStr","selfClosing","attrs","decodedAttrs","keys","d","key","decodeEntities","Promise","resolve","reject","parse","e","rootElement","defineProperty","XML_PREAMBLE","ESCAPE_ATTR_CHARS","ESCAPE_CHARS","Namespaces","parent","prefixMap","used","wellknown","custom","byUri","add","isWellknown","mapPrefix","uriByPrefix","getNSKey","logUsed","nsKey","getUsed","isUsed","self","allNs","concat","lower","string","toLowerCase","nameToAlias","inherits","ctor","superCtor","super_","constructor","enumerable","writable","configurable","nsName","getNsAttrs","namespaces","map","getElementNs","isGeneric","$pkg","getPropertyNs","getSerializableProperties","default","ESCAPE_ATTR_MAP","ESCAPE_MAP","escape","charPattern","replaceMap","replace","s","escapeAttr","escapeBody","filterAttributes","props","filterContained","ReferenceSerializer","tagName","build","serializeTo","writer","appendIndent","append","appendNewLine","BodySerializer","serializeValue","search","ValueSerializer","ElementSerializer","propertyDescriptor","elementDescriptor","otherAttrs","parseGeneric","parseNsAttributes","nsPropertyTagName","nsTagName","addTagName","parseAttributes","parseContainments","parseGenericAttributes","effectiveNs","logNamespaceUsed","isLocalNs","nsAttributeName","inherited","getNamespaces","val","nonNsAttr","child","parseNsAttribute","$model","logNamespace","actualNs","genericAttrs","$attrs","attr","addAttribute","console","warn","isBody","asType","asProperty","serializer","TypeSerializer","local","parentNamespaces","nsUri","nsPrefix","existing","newPrefix","wellknownUri","join","serializeAttributes","a","firstBody","indent","b","unindent","typeNs","SavingWriter","write","FormatingWriter","out","format","Writer","preamble","toXML","tree","internalWriter","formatingWriter"],"sources":["C:/Users/sam/final/camunda-react/node_modules/moddle-xml/dist/index.esm.js"],"sourcesContent":["import { forEach, assign, find, filter, has, isString, findIndex } from 'min-dash';\r\nimport { Parser } from 'saxen';\r\nimport { coerceType, parseNameNS, isSimpleType, Moddle } from 'moddle';\r\n\r\nfunction hasLowerCaseAlias(pkg) {\r\n  return pkg.xml && pkg.xml.tagAlias === 'lowerCase';\r\n}\r\n\r\nvar DEFAULT_NS_MAP = {\r\n  'xsi': 'http://www.w3.org/2001/XMLSchema-instance',\r\n  'xml': 'http://www.w3.org/XML/1998/namespace'\r\n};\r\n\r\nvar XSI_TYPE = 'xsi:type';\r\n\r\nfunction serializeFormat(element) {\r\n  return element.xml && element.xml.serialize;\r\n}\r\n\r\nfunction serializeAsType(element) {\r\n  return serializeFormat(element) === XSI_TYPE;\r\n}\r\n\r\nfunction serializeAsProperty(element) {\r\n  return serializeFormat(element) === 'property';\r\n}\r\n\r\nfunction capitalize(str) {\r\n  return str.charAt(0).toUpperCase() + str.slice(1);\r\n}\r\n\r\nfunction aliasToName(aliasNs, pkg) {\r\n\r\n  if (!hasLowerCaseAlias(pkg)) {\r\n    return aliasNs.name;\r\n  }\r\n\r\n  return aliasNs.prefix + ':' + capitalize(aliasNs.localName);\r\n}\r\n\r\nfunction prefixedToName(nameNs, pkg) {\r\n\r\n  var name = nameNs.name,\r\n      localName = nameNs.localName;\r\n\r\n  var typePrefix = pkg.xml && pkg.xml.typePrefix;\r\n\r\n  if (typePrefix && localName.indexOf(typePrefix) === 0) {\r\n    return nameNs.prefix + ':' + localName.slice(typePrefix.length);\r\n  } else {\r\n    return name;\r\n  }\r\n}\r\n\r\nfunction normalizeXsiTypeName(name, model) {\r\n\r\n  var nameNs = parseNameNS(name);\r\n  var pkg = model.getPackage(nameNs.prefix);\r\n\r\n  return prefixedToName(nameNs, pkg);\r\n}\r\n\r\nfunction error(message) {\r\n  return new Error(message);\r\n}\r\n\r\n/**\r\n * Get the moddle descriptor for a given instance or type.\r\n *\r\n * @param  {ModdleElement|Function} element\r\n *\r\n * @return {Object} the moddle descriptor\r\n */\r\nfunction getModdleDescriptor(element) {\r\n  return element.$descriptor;\r\n}\r\n\r\n\r\n/**\r\n * A parse context.\r\n *\r\n * @class\r\n *\r\n * @param {Object} options\r\n * @param {ElementHandler} options.rootHandler the root handler for parsing a document\r\n * @param {boolean} [options.lax=false] whether or not to ignore invalid elements\r\n */\r\nfunction Context(options) {\r\n\r\n  /**\r\n   * @property {ElementHandler} rootHandler\r\n   */\r\n\r\n  /**\r\n   * @property {Boolean} lax\r\n   */\r\n\r\n  assign(this, options);\r\n\r\n  this.elementsById = {};\r\n  this.references = [];\r\n  this.warnings = [];\r\n\r\n  /**\r\n   * Add an unresolved reference.\r\n   *\r\n   * @param {Object} reference\r\n   */\r\n  this.addReference = function(reference) {\r\n    this.references.push(reference);\r\n  };\r\n\r\n  /**\r\n   * Add a processed element.\r\n   *\r\n   * @param {ModdleElement} element\r\n   */\r\n  this.addElement = function(element) {\r\n\r\n    if (!element) {\r\n      throw error('expected element');\r\n    }\r\n\r\n    var elementsById = this.elementsById;\r\n\r\n    var descriptor = getModdleDescriptor(element);\r\n\r\n    var idProperty = descriptor.idProperty,\r\n        id;\r\n\r\n    if (idProperty) {\r\n      id = element.get(idProperty.name);\r\n\r\n      if (id) {\r\n\r\n        // for QName validation as per http://www.w3.org/TR/REC-xml/#NT-NameChar\r\n        if (!/^([a-z][\\w-.]*:)?[a-z_][\\w-.]*$/i.test(id)) {\r\n          throw new Error('illegal ID <' + id + '>');\r\n        }\r\n\r\n        if (elementsById[id]) {\r\n          throw error('duplicate ID <' + id + '>');\r\n        }\r\n\r\n        elementsById[id] = element;\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Add an import warning.\r\n   *\r\n   * @param {Object} warning\r\n   * @param {String} warning.message\r\n   * @param {Error} [warning.error]\r\n   */\r\n  this.addWarning = function(warning) {\r\n    this.warnings.push(warning);\r\n  };\r\n}\r\n\r\nfunction BaseHandler() {}\r\n\r\nBaseHandler.prototype.handleEnd = function() {};\r\nBaseHandler.prototype.handleText = function() {};\r\nBaseHandler.prototype.handleNode = function() {};\r\n\r\n\r\n/**\r\n * A simple pass through handler that does nothing except for\r\n * ignoring all input it receives.\r\n *\r\n * This is used to ignore unknown elements and\r\n * attributes.\r\n */\r\nfunction NoopHandler() { }\r\n\r\nNoopHandler.prototype = Object.create(BaseHandler.prototype);\r\n\r\nNoopHandler.prototype.handleNode = function() {\r\n  return this;\r\n};\r\n\r\nfunction BodyHandler() {}\r\n\r\nBodyHandler.prototype = Object.create(BaseHandler.prototype);\r\n\r\nBodyHandler.prototype.handleText = function(text) {\r\n  this.body = (this.body || '') + text;\r\n};\r\n\r\nfunction ReferenceHandler(property, context) {\r\n  this.property = property;\r\n  this.context = context;\r\n}\r\n\r\nReferenceHandler.prototype = Object.create(BodyHandler.prototype);\r\n\r\nReferenceHandler.prototype.handleNode = function(node) {\r\n\r\n  if (this.element) {\r\n    throw error('expected no sub nodes');\r\n  } else {\r\n    this.element = this.createReference(node);\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nReferenceHandler.prototype.handleEnd = function() {\r\n  this.element.id = this.body;\r\n};\r\n\r\nReferenceHandler.prototype.createReference = function(node) {\r\n  return {\r\n    property: this.property.ns.name,\r\n    id: ''\r\n  };\r\n};\r\n\r\nfunction ValueHandler(propertyDesc, element) {\r\n  this.element = element;\r\n  this.propertyDesc = propertyDesc;\r\n}\r\n\r\nValueHandler.prototype = Object.create(BodyHandler.prototype);\r\n\r\nValueHandler.prototype.handleEnd = function() {\r\n\r\n  var value = this.body || '',\r\n      element = this.element,\r\n      propertyDesc = this.propertyDesc;\r\n\r\n  value = coerceType(propertyDesc.type, value);\r\n\r\n  if (propertyDesc.isMany) {\r\n    element.get(propertyDesc.name).push(value);\r\n  } else {\r\n    element.set(propertyDesc.name, value);\r\n  }\r\n};\r\n\r\n\r\nfunction BaseElementHandler() {}\r\n\r\nBaseElementHandler.prototype = Object.create(BodyHandler.prototype);\r\n\r\nBaseElementHandler.prototype.handleNode = function(node) {\r\n  var parser = this,\r\n      element = this.element;\r\n\r\n  if (!element) {\r\n    element = this.element = this.createElement(node);\r\n\r\n    this.context.addElement(element);\r\n  } else {\r\n    parser = this.handleChild(node);\r\n  }\r\n\r\n  return parser;\r\n};\r\n\r\n/**\r\n * @class Reader.ElementHandler\r\n *\r\n */\r\nfunction ElementHandler(model, typeName, context) {\r\n  this.model = model;\r\n  this.type = model.getType(typeName);\r\n  this.context = context;\r\n}\r\n\r\nElementHandler.prototype = Object.create(BaseElementHandler.prototype);\r\n\r\nElementHandler.prototype.addReference = function(reference) {\r\n  this.context.addReference(reference);\r\n};\r\n\r\nElementHandler.prototype.handleText = function(text) {\r\n\r\n  var element = this.element,\r\n      descriptor = getModdleDescriptor(element),\r\n      bodyProperty = descriptor.bodyProperty;\r\n\r\n  if (!bodyProperty) {\r\n    throw error('unexpected body text <' + text + '>');\r\n  }\r\n\r\n  BodyHandler.prototype.handleText.call(this, text);\r\n};\r\n\r\nElementHandler.prototype.handleEnd = function() {\r\n\r\n  var value = this.body,\r\n      element = this.element,\r\n      descriptor = getModdleDescriptor(element),\r\n      bodyProperty = descriptor.bodyProperty;\r\n\r\n  if (bodyProperty && value !== undefined) {\r\n    value = coerceType(bodyProperty.type, value);\r\n    element.set(bodyProperty.name, value);\r\n  }\r\n};\r\n\r\n/**\r\n * Create an instance of the model from the given node.\r\n *\r\n * @param  {Element} node the xml node\r\n */\r\nElementHandler.prototype.createElement = function(node) {\r\n  var attributes = node.attributes,\r\n      Type = this.type,\r\n      descriptor = getModdleDescriptor(Type),\r\n      context = this.context,\r\n      instance = new Type({}),\r\n      model = this.model,\r\n      propNameNs;\r\n\r\n  forEach(attributes, function(value, name) {\r\n\r\n    var prop = descriptor.propertiesByName[name],\r\n        values;\r\n\r\n    if (prop && prop.isReference) {\r\n\r\n      if (!prop.isMany) {\r\n        context.addReference({\r\n          element: instance,\r\n          property: prop.ns.name,\r\n          id: value\r\n        });\r\n      } else {\r\n\r\n        // IDREFS: parse references as whitespace-separated list\r\n        values = value.split(' ');\r\n\r\n        forEach(values, function(v) {\r\n          context.addReference({\r\n            element: instance,\r\n            property: prop.ns.name,\r\n            id: v\r\n          });\r\n        });\r\n      }\r\n\r\n    } else {\r\n      if (prop) {\r\n        value = coerceType(prop.type, value);\r\n      } else\r\n      if (name !== 'xmlns') {\r\n        propNameNs = parseNameNS(name, descriptor.ns.prefix);\r\n\r\n        // check whether attribute is defined in a well-known namespace\r\n        // if that is the case we emit a warning to indicate potential misuse\r\n        if (model.getPackage(propNameNs.prefix)) {\r\n\r\n          context.addWarning({\r\n            message: 'unknown attribute <' + name + '>',\r\n            element: instance,\r\n            property: name,\r\n            value: value\r\n          });\r\n        }\r\n      }\r\n\r\n      instance.set(name, value);\r\n    }\r\n  });\r\n\r\n  return instance;\r\n};\r\n\r\nElementHandler.prototype.getPropertyForNode = function(node) {\r\n\r\n  var name = node.name;\r\n  var nameNs = parseNameNS(name);\r\n\r\n  var type = this.type,\r\n      model = this.model,\r\n      descriptor = getModdleDescriptor(type);\r\n\r\n  var propertyName = nameNs.name,\r\n      property = descriptor.propertiesByName[propertyName],\r\n      elementTypeName,\r\n      elementType;\r\n\r\n  // search for properties by name first\r\n\r\n  if (property && !property.isAttr) {\r\n\r\n    if (serializeAsType(property)) {\r\n      elementTypeName = node.attributes[XSI_TYPE];\r\n\r\n      // xsi type is optional, if it does not exists the\r\n      // default type is assumed\r\n      if (elementTypeName) {\r\n\r\n        // take possible type prefixes from XML\r\n        // into account, i.e.: xsi:type=\"t{ActualType}\"\r\n        elementTypeName = normalizeXsiTypeName(elementTypeName, model);\r\n\r\n        elementType = model.getType(elementTypeName);\r\n\r\n        return assign({}, property, {\r\n          effectiveType: getModdleDescriptor(elementType).name\r\n        });\r\n      }\r\n    }\r\n\r\n    // search for properties by name first\r\n    return property;\r\n  }\r\n\r\n  var pkg = model.getPackage(nameNs.prefix);\r\n\r\n  if (pkg) {\r\n    elementTypeName = aliasToName(nameNs, pkg);\r\n    elementType = model.getType(elementTypeName);\r\n\r\n    // search for collection members later\r\n    property = find(descriptor.properties, function(p) {\r\n      return !p.isVirtual && !p.isReference && !p.isAttribute && elementType.hasType(p.type);\r\n    });\r\n\r\n    if (property) {\r\n      return assign({}, property, {\r\n        effectiveType: getModdleDescriptor(elementType).name\r\n      });\r\n    }\r\n  } else {\r\n\r\n    // parse unknown element (maybe extension)\r\n    property = find(descriptor.properties, function(p) {\r\n      return !p.isReference && !p.isAttribute && p.type === 'Element';\r\n    });\r\n\r\n    if (property) {\r\n      return property;\r\n    }\r\n  }\r\n\r\n  throw error('unrecognized element <' + nameNs.name + '>');\r\n};\r\n\r\nElementHandler.prototype.toString = function() {\r\n  return 'ElementDescriptor[' + getModdleDescriptor(this.type).name + ']';\r\n};\r\n\r\nElementHandler.prototype.valueHandler = function(propertyDesc, element) {\r\n  return new ValueHandler(propertyDesc, element);\r\n};\r\n\r\nElementHandler.prototype.referenceHandler = function(propertyDesc) {\r\n  return new ReferenceHandler(propertyDesc, this.context);\r\n};\r\n\r\nElementHandler.prototype.handler = function(type) {\r\n  if (type === 'Element') {\r\n    return new GenericElementHandler(this.model, type, this.context);\r\n  } else {\r\n    return new ElementHandler(this.model, type, this.context);\r\n  }\r\n};\r\n\r\n/**\r\n * Handle the child element parsing\r\n *\r\n * @param  {Element} node the xml node\r\n */\r\nElementHandler.prototype.handleChild = function(node) {\r\n  var propertyDesc, type, element, childHandler;\r\n\r\n  propertyDesc = this.getPropertyForNode(node);\r\n  element = this.element;\r\n\r\n  type = propertyDesc.effectiveType || propertyDesc.type;\r\n\r\n  if (isSimpleType(type)) {\r\n    return this.valueHandler(propertyDesc, element);\r\n  }\r\n\r\n  if (propertyDesc.isReference) {\r\n    childHandler = this.referenceHandler(propertyDesc).handleNode(node);\r\n  } else {\r\n    childHandler = this.handler(type).handleNode(node);\r\n  }\r\n\r\n  var newElement = childHandler.element;\r\n\r\n  // child handles may decide to skip elements\r\n  // by not returning anything\r\n  if (newElement !== undefined) {\r\n\r\n    if (propertyDesc.isMany) {\r\n      element.get(propertyDesc.name).push(newElement);\r\n    } else {\r\n      element.set(propertyDesc.name, newElement);\r\n    }\r\n\r\n    if (propertyDesc.isReference) {\r\n      assign(newElement, {\r\n        element: element\r\n      });\r\n\r\n      this.context.addReference(newElement);\r\n    } else {\r\n\r\n      // establish child -> parent relationship\r\n      newElement.$parent = element;\r\n    }\r\n  }\r\n\r\n  return childHandler;\r\n};\r\n\r\n/**\r\n * An element handler that performs special validation\r\n * to ensure the node it gets initialized with matches\r\n * the handlers type (namespace wise).\r\n *\r\n * @param {Moddle} model\r\n * @param {String} typeName\r\n * @param {Context} context\r\n */\r\nfunction RootElementHandler(model, typeName, context) {\r\n  ElementHandler.call(this, model, typeName, context);\r\n}\r\n\r\nRootElementHandler.prototype = Object.create(ElementHandler.prototype);\r\n\r\nRootElementHandler.prototype.createElement = function(node) {\r\n\r\n  var name = node.name,\r\n      nameNs = parseNameNS(name),\r\n      model = this.model,\r\n      type = this.type,\r\n      pkg = model.getPackage(nameNs.prefix),\r\n      typeName = pkg && aliasToName(nameNs, pkg) || name;\r\n\r\n  // verify the correct namespace if we parse\r\n  // the first element in the handler tree\r\n  //\r\n  // this ensures we don't mistakenly import wrong namespace elements\r\n  if (!type.hasType(typeName)) {\r\n    throw error('unexpected element <' + node.originalName + '>');\r\n  }\r\n\r\n  return ElementHandler.prototype.createElement.call(this, node);\r\n};\r\n\r\n\r\nfunction GenericElementHandler(model, typeName, context) {\r\n  this.model = model;\r\n  this.context = context;\r\n}\r\n\r\nGenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);\r\n\r\nGenericElementHandler.prototype.createElement = function(node) {\r\n\r\n  var name = node.name,\r\n      ns = parseNameNS(name),\r\n      prefix = ns.prefix,\r\n      uri = node.ns[prefix + '$uri'],\r\n      attributes = node.attributes;\r\n\r\n  return this.model.createAny(name, uri, attributes);\r\n};\r\n\r\nGenericElementHandler.prototype.handleChild = function(node) {\r\n\r\n  var handler = new GenericElementHandler(this.model, 'Element', this.context).handleNode(node),\r\n      element = this.element;\r\n\r\n  var newElement = handler.element,\r\n      children;\r\n\r\n  if (newElement !== undefined) {\r\n    children = element.$children = element.$children || [];\r\n    children.push(newElement);\r\n\r\n    // establish child -> parent relationship\r\n    newElement.$parent = element;\r\n  }\r\n\r\n  return handler;\r\n};\r\n\r\nGenericElementHandler.prototype.handleEnd = function() {\r\n  if (this.body) {\r\n    this.element.$body = this.body;\r\n  }\r\n};\r\n\r\n/**\r\n * A reader for a meta-model\r\n *\r\n * @param {Object} options\r\n * @param {Model} options.model used to read xml files\r\n * @param {Boolean} options.lax whether to make parse errors warnings\r\n */\r\nfunction Reader(options) {\r\n\r\n  if (options instanceof Moddle) {\r\n    options = {\r\n      model: options\r\n    };\r\n  }\r\n\r\n  assign(this, { lax: false }, options);\r\n}\r\n\r\n/**\r\n * The fromXML result.\r\n *\r\n * @typedef {Object} ParseResult\r\n *\r\n * @property {ModdleElement} rootElement\r\n * @property {Array<Object>} references\r\n * @property {Array<Error>} warnings\r\n * @property {Object} elementsById - a mapping containing each ID -> ModdleElement\r\n */\r\n\r\n/**\r\n * The fromXML result.\r\n *\r\n * @typedef {Error} ParseError\r\n *\r\n * @property {Array<Error>} warnings\r\n */\r\n\r\n/**\r\n * Parse the given XML into a moddle document tree.\r\n *\r\n * @param {String} xml\r\n * @param {ElementHandler|Object} options or rootHandler\r\n *\r\n * @returns {Promise<ParseResult, ParseError>}\r\n */\r\nReader.prototype.fromXML = function(xml, options, done) {\r\n\r\n  var rootHandler = options.rootHandler;\r\n\r\n  if (options instanceof ElementHandler) {\r\n\r\n    // root handler passed via (xml, { rootHandler: ElementHandler }, ...)\r\n    rootHandler = options;\r\n    options = {};\r\n  } else {\r\n    if (typeof options === 'string') {\r\n\r\n      // rootHandler passed via (xml, 'someString', ...)\r\n      rootHandler = this.handler(options);\r\n      options = {};\r\n    } else if (typeof rootHandler === 'string') {\r\n\r\n      // rootHandler passed via (xml, { rootHandler: 'someString' }, ...)\r\n      rootHandler = this.handler(rootHandler);\r\n    }\r\n  }\r\n\r\n  var model = this.model,\r\n      lax = this.lax;\r\n\r\n  var context = new Context(assign({}, options, { rootHandler: rootHandler })),\r\n      parser = new Parser({ proxy: true }),\r\n      stack = createStack();\r\n\r\n  rootHandler.context = context;\r\n\r\n  // push root handler\r\n  stack.push(rootHandler);\r\n\r\n\r\n  /**\r\n   * Handle error.\r\n   *\r\n   * @param  {Error} err\r\n   * @param  {Function} getContext\r\n   * @param  {boolean} lax\r\n   *\r\n   * @return {boolean} true if handled\r\n   */\r\n  function handleError(err, getContext, lax) {\r\n\r\n    var ctx = getContext();\r\n\r\n    var line = ctx.line,\r\n        column = ctx.column,\r\n        data = ctx.data;\r\n\r\n    // we receive the full context data here,\r\n    // for elements trim down the information\r\n    // to the tag name, only\r\n    if (data.charAt(0) === '<' && data.indexOf(' ') !== -1) {\r\n      data = data.slice(0, data.indexOf(' ')) + '>';\r\n    }\r\n\r\n    var message =\r\n      'unparsable content ' + (data ? data + ' ' : '') + 'detected\\n\\t' +\r\n        'line: ' + line + '\\n\\t' +\r\n        'column: ' + column + '\\n\\t' +\r\n        'nested error: ' + err.message;\r\n\r\n    if (lax) {\r\n      context.addWarning({\r\n        message: message,\r\n        error: err\r\n      });\r\n\r\n      return true;\r\n    } else {\r\n      throw error(message);\r\n    }\r\n  }\r\n\r\n  function handleWarning(err, getContext) {\r\n\r\n    // just like handling errors in <lax=true> mode\r\n    return handleError(err, getContext, true);\r\n  }\r\n\r\n  /**\r\n   * Resolve collected references on parse end.\r\n   */\r\n  function resolveReferences() {\r\n\r\n    var elementsById = context.elementsById;\r\n    var references = context.references;\r\n\r\n    var i, r;\r\n\r\n    for (i = 0; (r = references[i]); i++) {\r\n      var element = r.element;\r\n      var reference = elementsById[r.id];\r\n      var property = getModdleDescriptor(element).propertiesByName[r.property];\r\n\r\n      if (!reference) {\r\n        context.addWarning({\r\n          message: 'unresolved reference <' + r.id + '>',\r\n          element: r.element,\r\n          property: r.property,\r\n          value: r.id\r\n        });\r\n      }\r\n\r\n      if (property.isMany) {\r\n        var collection = element.get(property.name),\r\n            idx = collection.indexOf(r);\r\n\r\n        // we replace an existing place holder (idx != -1) or\r\n        // append to the collection instead\r\n        if (idx === -1) {\r\n          idx = collection.length;\r\n        }\r\n\r\n        if (!reference) {\r\n\r\n          // remove unresolvable reference\r\n          collection.splice(idx, 1);\r\n        } else {\r\n\r\n          // add or update reference in collection\r\n          collection[idx] = reference;\r\n        }\r\n      } else {\r\n        element.set(property.name, reference);\r\n      }\r\n    }\r\n  }\r\n\r\n  function handleClose() {\r\n    stack.pop().handleEnd();\r\n  }\r\n\r\n  var PREAMBLE_START_PATTERN = /^<\\?xml /i;\r\n\r\n  var ENCODING_PATTERN = / encoding=\"([^\"]+)\"/i;\r\n\r\n  var UTF_8_PATTERN = /^utf-8$/i;\r\n\r\n  function handleQuestion(question) {\r\n\r\n    if (!PREAMBLE_START_PATTERN.test(question)) {\r\n      return;\r\n    }\r\n\r\n    var match = ENCODING_PATTERN.exec(question);\r\n    var encoding = match && match[1];\r\n\r\n    if (!encoding || UTF_8_PATTERN.test(encoding)) {\r\n      return;\r\n    }\r\n\r\n    context.addWarning({\r\n      message:\r\n        'unsupported document encoding <' + encoding + '>, ' +\r\n        'falling back to UTF-8'\r\n    });\r\n  }\r\n\r\n  function handleOpen(node, getContext) {\r\n    var handler = stack.peek();\r\n\r\n    try {\r\n      stack.push(handler.handleNode(node));\r\n    } catch (err) {\r\n\r\n      if (handleError(err, getContext, lax)) {\r\n        stack.push(new NoopHandler());\r\n      }\r\n    }\r\n  }\r\n\r\n  function handleCData(text, getContext) {\r\n\r\n    try {\r\n      stack.peek().handleText(text);\r\n    } catch (err) {\r\n      handleWarning(err, getContext);\r\n    }\r\n  }\r\n\r\n  function handleText(text, getContext) {\r\n\r\n    // strip whitespace only nodes, i.e. before\r\n    // <!CDATA[ ... ]> sections and in between tags\r\n\r\n    if (!text.trim()) {\r\n      return;\r\n    }\r\n\r\n    handleCData(text, getContext);\r\n  }\r\n\r\n  var uriMap = model.getPackages().reduce(function(uriMap, p) {\r\n    uriMap[p.uri] = p.prefix;\r\n\r\n    return uriMap;\r\n  }, {\r\n    'http://www.w3.org/XML/1998/namespace': 'xml' // add default xml ns\r\n  });\r\n  parser\r\n    .ns(uriMap)\r\n    .on('openTag', function(obj, decodeStr, selfClosing, getContext) {\r\n\r\n      // gracefully handle unparsable attributes (attrs=false)\r\n      var attrs = obj.attrs || {};\r\n\r\n      var decodedAttrs = Object.keys(attrs).reduce(function(d, key) {\r\n        var value = decodeStr(attrs[key]);\r\n\r\n        d[key] = value;\r\n\r\n        return d;\r\n      }, {});\r\n\r\n      var node = {\r\n        name: obj.name,\r\n        originalName: obj.originalName,\r\n        attributes: decodedAttrs,\r\n        ns: obj.ns\r\n      };\r\n\r\n      handleOpen(node, getContext);\r\n    })\r\n    .on('question', handleQuestion)\r\n    .on('closeTag', handleClose)\r\n    .on('cdata', handleCData)\r\n    .on('text', function(text, decodeEntities, getContext) {\r\n      handleText(decodeEntities(text), getContext);\r\n    })\r\n    .on('error', handleError)\r\n    .on('warn', handleWarning);\r\n\r\n  // async XML parsing to make sure the execution environment\r\n  // (node or brower) is kept responsive and that certain optimization\r\n  // strategies can kick in.\r\n  return new Promise(function(resolve, reject) {\r\n\r\n    var err;\r\n\r\n    try {\r\n      parser.parse(xml);\r\n\r\n      resolveReferences();\r\n    } catch (e) {\r\n      err = e;\r\n    }\r\n\r\n    var rootElement = rootHandler.element;\r\n\r\n    if (!err && !rootElement) {\r\n      err = error('failed to parse document as <' + rootHandler.type.$descriptor.name + '>');\r\n    }\r\n\r\n    var warnings = context.warnings;\r\n    var references = context.references;\r\n    var elementsById = context.elementsById;\r\n\r\n    if (err) {\r\n      err.warnings = warnings;\r\n\r\n      return reject(err);\r\n    } else {\r\n      return resolve({\r\n        rootElement: rootElement,\r\n        elementsById: elementsById,\r\n        references: references,\r\n        warnings: warnings\r\n      });\r\n    }\r\n  });\r\n};\r\n\r\nReader.prototype.handler = function(name) {\r\n  return new RootElementHandler(this.model, name);\r\n};\r\n\r\n\r\n// helpers //////////////////////////\r\n\r\nfunction createStack() {\r\n  var stack = [];\r\n\r\n  Object.defineProperty(stack, 'peek', {\r\n    value: function() {\r\n      return this[this.length - 1];\r\n    }\r\n  });\r\n\r\n  return stack;\r\n}\r\n\r\nvar XML_PREAMBLE = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\r\n\r\nvar ESCAPE_ATTR_CHARS = /<|>|'|\"|&|\\n\\r|\\n/g;\r\nvar ESCAPE_CHARS = /<|>|&/g;\r\n\r\n\r\nfunction Namespaces(parent) {\r\n\r\n  var prefixMap = {};\r\n  var uriMap = {};\r\n  var used = {};\r\n\r\n  var wellknown = [];\r\n  var custom = [];\r\n\r\n  // API\r\n\r\n  this.byUri = function(uri) {\r\n    return uriMap[uri] || (\r\n      parent && parent.byUri(uri)\r\n    );\r\n  };\r\n\r\n  this.add = function(ns, isWellknown) {\r\n\r\n    uriMap[ns.uri] = ns;\r\n\r\n    if (isWellknown) {\r\n      wellknown.push(ns);\r\n    } else {\r\n      custom.push(ns);\r\n    }\r\n\r\n    this.mapPrefix(ns.prefix, ns.uri);\r\n  };\r\n\r\n  this.uriByPrefix = function(prefix) {\r\n    return prefixMap[prefix || 'xmlns'];\r\n  };\r\n\r\n  this.mapPrefix = function(prefix, uri) {\r\n    prefixMap[prefix || 'xmlns'] = uri;\r\n  };\r\n\r\n  this.getNSKey = function(ns) {\r\n    return (ns.prefix !== undefined) ? (ns.uri + '|' + ns.prefix) : ns.uri;\r\n  };\r\n\r\n  this.logUsed = function(ns) {\r\n\r\n    var uri = ns.uri;\r\n    var nsKey = this.getNSKey(ns);\r\n\r\n    used[nsKey] = this.byUri(uri);\r\n\r\n    // Inform parent recursively about the usage of this NS\r\n    if (parent) {\r\n      parent.logUsed(ns);\r\n    }\r\n  };\r\n\r\n  this.getUsed = function(ns) {\r\n\r\n    function isUsed(ns) {\r\n      var nsKey = self.getNSKey(ns);\r\n\r\n      return used[nsKey];\r\n    }\r\n\r\n    var self = this;\r\n\r\n    var allNs = [].concat(wellknown, custom);\r\n\r\n    return allNs.filter(isUsed);\r\n  };\r\n\r\n}\r\n\r\nfunction lower(string) {\r\n  return string.charAt(0).toLowerCase() + string.slice(1);\r\n}\r\n\r\nfunction nameToAlias(name, pkg) {\r\n  if (hasLowerCaseAlias(pkg)) {\r\n    return lower(name);\r\n  } else {\r\n    return name;\r\n  }\r\n}\r\n\r\nfunction inherits(ctor, superCtor) {\r\n  ctor.super_ = superCtor;\r\n  ctor.prototype = Object.create(superCtor.prototype, {\r\n    constructor: {\r\n      value: ctor,\r\n      enumerable: false,\r\n      writable: true,\r\n      configurable: true\r\n    }\r\n  });\r\n}\r\n\r\nfunction nsName(ns) {\r\n  if (isString(ns)) {\r\n    return ns;\r\n  } else {\r\n    return (ns.prefix ? ns.prefix + ':' : '') + ns.localName;\r\n  }\r\n}\r\n\r\nfunction getNsAttrs(namespaces) {\r\n\r\n  return namespaces.getUsed().filter(function(ns) {\r\n\r\n    // do not serialize built in <xml> namespace\r\n    return ns.prefix !== 'xml';\r\n  }).map(function(ns) {\r\n    var name = 'xmlns' + (ns.prefix ? ':' + ns.prefix : '');\r\n    return { name: name, value: ns.uri };\r\n  });\r\n\r\n}\r\n\r\nfunction getElementNs(ns, descriptor) {\r\n  if (descriptor.isGeneric) {\r\n    return assign({ localName: descriptor.ns.localName }, ns);\r\n  } else {\r\n    return assign({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns);\r\n  }\r\n}\r\n\r\nfunction getPropertyNs(ns, descriptor) {\r\n  return assign({ localName: descriptor.ns.localName }, ns);\r\n}\r\n\r\nfunction getSerializableProperties(element) {\r\n  var descriptor = element.$descriptor;\r\n\r\n  return filter(descriptor.properties, function(p) {\r\n    var name = p.name;\r\n\r\n    if (p.isVirtual) {\r\n      return false;\r\n    }\r\n\r\n    // do not serialize defaults\r\n    if (!has(element, name)) {\r\n      return false;\r\n    }\r\n\r\n    var value = element[name];\r\n\r\n    // do not serialize default equals\r\n    if (value === p.default) {\r\n      return false;\r\n    }\r\n\r\n    // do not serialize null properties\r\n    if (value === null) {\r\n      return false;\r\n    }\r\n\r\n    return p.isMany ? value.length : true;\r\n  });\r\n}\r\n\r\nvar ESCAPE_ATTR_MAP = {\r\n  '\\n': '#10',\r\n  '\\n\\r': '#10',\r\n  '\"': '#34',\r\n  '\\'': '#39',\r\n  '<': '#60',\r\n  '>': '#62',\r\n  '&': '#38'\r\n};\r\n\r\nvar ESCAPE_MAP = {\r\n  '<': 'lt',\r\n  '>': 'gt',\r\n  '&': 'amp'\r\n};\r\n\r\nfunction escape(str, charPattern, replaceMap) {\r\n\r\n  // ensure we are handling strings here\r\n  str = isString(str) ? str : '' + str;\r\n\r\n  return str.replace(charPattern, function(s) {\r\n    return '&' + replaceMap[s] + ';';\r\n  });\r\n}\r\n\r\n/**\r\n * Escape a string attribute to not contain any bad values (line breaks, '\"', ...)\r\n *\r\n * @param {String} str the string to escape\r\n * @return {String} the escaped string\r\n */\r\nfunction escapeAttr(str) {\r\n  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);\r\n}\r\n\r\nfunction escapeBody(str) {\r\n  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);\r\n}\r\n\r\nfunction filterAttributes(props) {\r\n  return filter(props, function(p) { return p.isAttr; });\r\n}\r\n\r\nfunction filterContained(props) {\r\n  return filter(props, function(p) { return !p.isAttr; });\r\n}\r\n\r\n\r\nfunction ReferenceSerializer(tagName) {\r\n  this.tagName = tagName;\r\n}\r\n\r\nReferenceSerializer.prototype.build = function(element) {\r\n  this.element = element;\r\n  return this;\r\n};\r\n\r\nReferenceSerializer.prototype.serializeTo = function(writer) {\r\n  writer\r\n    .appendIndent()\r\n    .append('<' + this.tagName + '>' + this.element.id + '</' + this.tagName + '>')\r\n    .appendNewLine();\r\n};\r\n\r\nfunction BodySerializer() {}\r\n\r\nBodySerializer.prototype.serializeValue =\r\nBodySerializer.prototype.serializeTo = function(writer) {\r\n  writer.append(\r\n    this.escape\r\n      ? escapeBody(this.value)\r\n      : this.value\r\n  );\r\n};\r\n\r\nBodySerializer.prototype.build = function(prop, value) {\r\n  this.value = value;\r\n\r\n  if (prop.type === 'String' && value.search(ESCAPE_CHARS) !== -1) {\r\n    this.escape = true;\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nfunction ValueSerializer(tagName) {\r\n  this.tagName = tagName;\r\n}\r\n\r\ninherits(ValueSerializer, BodySerializer);\r\n\r\nValueSerializer.prototype.serializeTo = function(writer) {\r\n\r\n  writer\r\n    .appendIndent()\r\n    .append('<' + this.tagName + '>');\r\n\r\n  this.serializeValue(writer);\r\n\r\n  writer\r\n    .append('</' + this.tagName + '>')\r\n    .appendNewLine();\r\n};\r\n\r\nfunction ElementSerializer(parent, propertyDescriptor) {\r\n  this.body = [];\r\n  this.attrs = [];\r\n\r\n  this.parent = parent;\r\n  this.propertyDescriptor = propertyDescriptor;\r\n}\r\n\r\nElementSerializer.prototype.build = function(element) {\r\n  this.element = element;\r\n\r\n  var elementDescriptor = element.$descriptor,\r\n      propertyDescriptor = this.propertyDescriptor;\r\n\r\n  var otherAttrs,\r\n      properties;\r\n\r\n  var isGeneric = elementDescriptor.isGeneric;\r\n\r\n  if (isGeneric) {\r\n    otherAttrs = this.parseGeneric(element);\r\n  } else {\r\n    otherAttrs = this.parseNsAttributes(element);\r\n  }\r\n\r\n  if (propertyDescriptor) {\r\n    this.ns = this.nsPropertyTagName(propertyDescriptor);\r\n  } else {\r\n    this.ns = this.nsTagName(elementDescriptor);\r\n  }\r\n\r\n  // compute tag name\r\n  this.tagName = this.addTagName(this.ns);\r\n\r\n  if (!isGeneric) {\r\n    properties = getSerializableProperties(element);\r\n\r\n    this.parseAttributes(filterAttributes(properties));\r\n    this.parseContainments(filterContained(properties));\r\n  }\r\n\r\n  this.parseGenericAttributes(element, otherAttrs);\r\n\r\n  return this;\r\n};\r\n\r\nElementSerializer.prototype.nsTagName = function(descriptor) {\r\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\r\n  return getElementNs(effectiveNs, descriptor);\r\n};\r\n\r\nElementSerializer.prototype.nsPropertyTagName = function(descriptor) {\r\n  var effectiveNs = this.logNamespaceUsed(descriptor.ns);\r\n  return getPropertyNs(effectiveNs, descriptor);\r\n};\r\n\r\nElementSerializer.prototype.isLocalNs = function(ns) {\r\n  return ns.uri === this.ns.uri;\r\n};\r\n\r\n/**\r\n * Get the actual ns attribute name for the given element.\r\n *\r\n * @param {Object} element\r\n * @param {Boolean} [element.inherited=false]\r\n *\r\n * @return {Object} nsName\r\n */\r\nElementSerializer.prototype.nsAttributeName = function(element) {\r\n\r\n  var ns;\r\n\r\n  if (isString(element)) {\r\n    ns = parseNameNS(element);\r\n  } else {\r\n    ns = element.ns;\r\n  }\r\n\r\n  // return just local name for inherited attributes\r\n  if (element.inherited) {\r\n    return { localName: ns.localName };\r\n  }\r\n\r\n  // parse + log effective ns\r\n  var effectiveNs = this.logNamespaceUsed(ns);\r\n\r\n  // LOG ACTUAL namespace use\r\n  this.getNamespaces().logUsed(effectiveNs);\r\n\r\n  // strip prefix if same namespace like parent\r\n  if (this.isLocalNs(effectiveNs)) {\r\n    return { localName: ns.localName };\r\n  } else {\r\n    return assign({ localName: ns.localName }, effectiveNs);\r\n  }\r\n};\r\n\r\nElementSerializer.prototype.parseGeneric = function(element) {\r\n\r\n  var self = this,\r\n      body = this.body;\r\n\r\n  var attributes = [];\r\n\r\n  forEach(element, function(val, key) {\r\n\r\n    var nonNsAttr;\r\n\r\n    if (key === '$body') {\r\n      body.push(new BodySerializer().build({ type: 'String' }, val));\r\n    } else\r\n    if (key === '$children') {\r\n      forEach(val, function(child) {\r\n        body.push(new ElementSerializer(self).build(child));\r\n      });\r\n    } else\r\n    if (key.indexOf('$') !== 0) {\r\n      nonNsAttr = self.parseNsAttribute(element, key, val);\r\n\r\n      if (nonNsAttr) {\r\n        attributes.push({ name: key, value: val });\r\n      }\r\n    }\r\n  });\r\n\r\n  return attributes;\r\n};\r\n\r\nElementSerializer.prototype.parseNsAttribute = function(element, name, value) {\r\n  var model = element.$model;\r\n\r\n  var nameNs = parseNameNS(name);\r\n\r\n  var ns;\r\n\r\n  // parse xmlns:foo=\"http://foo.bar\"\r\n  if (nameNs.prefix === 'xmlns') {\r\n    ns = { prefix: nameNs.localName, uri: value };\r\n  }\r\n\r\n  // parse xmlns=\"http://foo.bar\"\r\n  if (!nameNs.prefix && nameNs.localName === 'xmlns') {\r\n    ns = { uri: value };\r\n  }\r\n\r\n  if (!ns) {\r\n    return {\r\n      name: name,\r\n      value: value\r\n    };\r\n  }\r\n\r\n  if (model && model.getPackage(value)) {\r\n\r\n    // register well known namespace\r\n    this.logNamespace(ns, true, true);\r\n  } else {\r\n\r\n    // log custom namespace directly as used\r\n    var actualNs = this.logNamespaceUsed(ns, true);\r\n\r\n    this.getNamespaces().logUsed(actualNs);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Parse namespaces and return a list of left over generic attributes\r\n *\r\n * @param  {Object} element\r\n * @return {Array<Object>}\r\n */\r\nElementSerializer.prototype.parseNsAttributes = function(element, attrs) {\r\n  var self = this;\r\n\r\n  var genericAttrs = element.$attrs;\r\n\r\n  var attributes = [];\r\n\r\n  // parse namespace attributes first\r\n  // and log them. push non namespace attributes to a list\r\n  // and process them later\r\n  forEach(genericAttrs, function(value, name) {\r\n\r\n    var nonNsAttr = self.parseNsAttribute(element, name, value);\r\n\r\n    if (nonNsAttr) {\r\n      attributes.push(nonNsAttr);\r\n    }\r\n  });\r\n\r\n  return attributes;\r\n};\r\n\r\nElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {\r\n\r\n  var self = this;\r\n\r\n  forEach(attributes, function(attr) {\r\n\r\n    // do not serialize xsi:type attribute\r\n    // it is set manually based on the actual implementation type\r\n    if (attr.name === XSI_TYPE) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      self.addAttribute(self.nsAttributeName(attr.name), attr.value);\r\n    } catch (e) {\r\n      console.warn(\r\n        'missing namespace information for ',\r\n        attr.name, '=', attr.value, 'on', element,\r\n        e);\r\n    }\r\n  });\r\n};\r\n\r\nElementSerializer.prototype.parseContainments = function(properties) {\r\n\r\n  var self = this,\r\n      body = this.body,\r\n      element = this.element;\r\n\r\n  forEach(properties, function(p) {\r\n    var value = element.get(p.name),\r\n        isReference = p.isReference,\r\n        isMany = p.isMany;\r\n\r\n    if (!isMany) {\r\n      value = [ value ];\r\n    }\r\n\r\n    if (p.isBody) {\r\n      body.push(new BodySerializer().build(p, value[0]));\r\n    } else\r\n    if (isSimpleType(p.type)) {\r\n      forEach(value, function(v) {\r\n        body.push(new ValueSerializer(self.addTagName(self.nsPropertyTagName(p))).build(p, v));\r\n      });\r\n    } else\r\n    if (isReference) {\r\n      forEach(value, function(v) {\r\n        body.push(new ReferenceSerializer(self.addTagName(self.nsPropertyTagName(p))).build(v));\r\n      });\r\n    } else {\r\n\r\n      // allow serialization via type\r\n      // rather than element name\r\n      var asType = serializeAsType(p),\r\n          asProperty = serializeAsProperty(p);\r\n\r\n      forEach(value, function(v) {\r\n        var serializer;\r\n\r\n        if (asType) {\r\n          serializer = new TypeSerializer(self, p);\r\n        } else\r\n        if (asProperty) {\r\n          serializer = new ElementSerializer(self, p);\r\n        } else {\r\n          serializer = new ElementSerializer(self);\r\n        }\r\n\r\n        body.push(serializer.build(v));\r\n      });\r\n    }\r\n  });\r\n};\r\n\r\nElementSerializer.prototype.getNamespaces = function(local) {\r\n\r\n  var namespaces = this.namespaces,\r\n      parent = this.parent,\r\n      parentNamespaces;\r\n\r\n  if (!namespaces) {\r\n    parentNamespaces = parent && parent.getNamespaces();\r\n\r\n    if (local || !parentNamespaces) {\r\n      this.namespaces = namespaces = new Namespaces(parentNamespaces);\r\n    } else {\r\n      namespaces = parentNamespaces;\r\n    }\r\n  }\r\n\r\n  return namespaces;\r\n};\r\n\r\nElementSerializer.prototype.logNamespace = function(ns, wellknown, local) {\r\n  var namespaces = this.getNamespaces(local);\r\n\r\n  var nsUri = ns.uri,\r\n      nsPrefix = ns.prefix;\r\n\r\n  var existing = namespaces.byUri(nsUri);\r\n\r\n  if (!existing || local) {\r\n    namespaces.add(ns, wellknown);\r\n  }\r\n\r\n  namespaces.mapPrefix(nsPrefix, nsUri);\r\n\r\n  return ns;\r\n};\r\n\r\nElementSerializer.prototype.logNamespaceUsed = function(ns, local) {\r\n  var element = this.element,\r\n      model = element.$model,\r\n      namespaces = this.getNamespaces(local);\r\n\r\n  // ns may be\r\n  //\r\n  //   * prefix only\r\n  //   * prefix:uri\r\n  //   * localName only\r\n\r\n  var prefix = ns.prefix,\r\n      uri = ns.uri,\r\n      newPrefix, idx,\r\n      wellknownUri;\r\n\r\n  // handle anonymous namespaces (elementForm=unqualified), cf. #23\r\n  if (!prefix && !uri) {\r\n    return { localName: ns.localName };\r\n  }\r\n\r\n  wellknownUri = DEFAULT_NS_MAP[prefix] || model && (model.getPackage(prefix) || {}).uri;\r\n\r\n  uri = uri || wellknownUri || namespaces.uriByPrefix(prefix);\r\n\r\n  if (!uri) {\r\n    throw new Error('no namespace uri given for prefix <' + prefix + '>');\r\n  }\r\n\r\n  ns = namespaces.byUri(uri);\r\n\r\n  if (!ns) {\r\n    newPrefix = prefix;\r\n    idx = 1;\r\n\r\n    // find a prefix that is not mapped yet\r\n    while (namespaces.uriByPrefix(newPrefix)) {\r\n      newPrefix = prefix + '_' + idx++;\r\n    }\r\n\r\n    ns = this.logNamespace({ prefix: newPrefix, uri: uri }, wellknownUri === uri);\r\n  }\r\n\r\n  if (prefix) {\r\n    namespaces.mapPrefix(prefix, uri);\r\n  }\r\n\r\n  return ns;\r\n};\r\n\r\nElementSerializer.prototype.parseAttributes = function(properties) {\r\n  var self = this,\r\n      element = this.element;\r\n\r\n  forEach(properties, function(p) {\r\n\r\n    var value = element.get(p.name);\r\n\r\n    if (p.isReference) {\r\n\r\n      if (!p.isMany) {\r\n        value = value.id;\r\n      }\r\n      else {\r\n        var values = [];\r\n        forEach(value, function(v) {\r\n          values.push(v.id);\r\n        });\r\n\r\n        // IDREFS is a whitespace-separated list of references.\r\n        value = values.join(' ');\r\n      }\r\n\r\n    }\r\n\r\n    self.addAttribute(self.nsAttributeName(p), value);\r\n  });\r\n};\r\n\r\nElementSerializer.prototype.addTagName = function(nsTagName) {\r\n  var actualNs = this.logNamespaceUsed(nsTagName);\r\n\r\n  this.getNamespaces().logUsed(actualNs);\r\n\r\n  return nsName(nsTagName);\r\n};\r\n\r\nElementSerializer.prototype.addAttribute = function(name, value) {\r\n  var attrs = this.attrs;\r\n\r\n  if (isString(value)) {\r\n    value = escapeAttr(value);\r\n  }\r\n\r\n  // de-duplicate attributes\r\n  // https://github.com/bpmn-io/moddle-xml/issues/66\r\n  var idx = findIndex(attrs, function(element) {\r\n    return (\r\n      element.name.localName === name.localName &&\r\n      element.name.uri === name.uri &&\r\n      element.name.prefix === name.prefix\r\n    );\r\n  });\r\n\r\n  var attr = { name: name, value: value };\r\n\r\n  if (idx !== -1) {\r\n    attrs.splice(idx, 1, attr);\r\n  } else {\r\n    attrs.push(attr);\r\n  }\r\n};\r\n\r\nElementSerializer.prototype.serializeAttributes = function(writer) {\r\n  var attrs = this.attrs,\r\n      namespaces = this.namespaces;\r\n\r\n  if (namespaces) {\r\n    attrs = getNsAttrs(namespaces).concat(attrs);\r\n  }\r\n\r\n  forEach(attrs, function(a) {\r\n    writer\r\n      .append(' ')\r\n      .append(nsName(a.name)).append('=\"').append(a.value).append('\"');\r\n  });\r\n};\r\n\r\nElementSerializer.prototype.serializeTo = function(writer) {\r\n  var firstBody = this.body[0],\r\n      indent = firstBody && firstBody.constructor !== BodySerializer;\r\n\r\n  writer\r\n    .appendIndent()\r\n    .append('<' + this.tagName);\r\n\r\n  this.serializeAttributes(writer);\r\n\r\n  writer.append(firstBody ? '>' : ' />');\r\n\r\n  if (firstBody) {\r\n\r\n    if (indent) {\r\n      writer\r\n        .appendNewLine()\r\n        .indent();\r\n    }\r\n\r\n    forEach(this.body, function(b) {\r\n      b.serializeTo(writer);\r\n    });\r\n\r\n    if (indent) {\r\n      writer\r\n        .unindent()\r\n        .appendIndent();\r\n    }\r\n\r\n    writer.append('</' + this.tagName + '>');\r\n  }\r\n\r\n  writer.appendNewLine();\r\n};\r\n\r\n/**\r\n * A serializer for types that handles serialization of data types\r\n */\r\nfunction TypeSerializer(parent, propertyDescriptor) {\r\n  ElementSerializer.call(this, parent, propertyDescriptor);\r\n}\r\n\r\ninherits(TypeSerializer, ElementSerializer);\r\n\r\nTypeSerializer.prototype.parseNsAttributes = function(element) {\r\n\r\n  // extracted attributes\r\n  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element);\r\n\r\n  var descriptor = element.$descriptor;\r\n\r\n  // only serialize xsi:type if necessary\r\n  if (descriptor.name === this.propertyDescriptor.type) {\r\n    return attributes;\r\n  }\r\n\r\n  var typeNs = this.typeNs = this.nsTagName(descriptor);\r\n  this.getNamespaces().logUsed(this.typeNs);\r\n\r\n  // add xsi:type attribute to represent the elements\r\n  // actual type\r\n\r\n  var pkg = element.$model.getPackage(typeNs.uri),\r\n      typePrefix = (pkg.xml && pkg.xml.typePrefix) || '';\r\n\r\n  this.addAttribute(\r\n    this.nsAttributeName(XSI_TYPE),\r\n    (typeNs.prefix ? typeNs.prefix + ':' : '') + typePrefix + descriptor.ns.localName\r\n  );\r\n\r\n  return attributes;\r\n};\r\n\r\nTypeSerializer.prototype.isLocalNs = function(ns) {\r\n  return ns.uri === (this.typeNs || this.ns).uri;\r\n};\r\n\r\nfunction SavingWriter() {\r\n  this.value = '';\r\n\r\n  this.write = function(str) {\r\n    this.value += str;\r\n  };\r\n}\r\n\r\nfunction FormatingWriter(out, format) {\r\n\r\n  var indent = [''];\r\n\r\n  this.append = function(str) {\r\n    out.write(str);\r\n\r\n    return this;\r\n  };\r\n\r\n  this.appendNewLine = function() {\r\n    if (format) {\r\n      out.write('\\n');\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  this.appendIndent = function() {\r\n    if (format) {\r\n      out.write(indent.join('  '));\r\n    }\r\n\r\n    return this;\r\n  };\r\n\r\n  this.indent = function() {\r\n    indent.push('');\r\n    return this;\r\n  };\r\n\r\n  this.unindent = function() {\r\n    indent.pop();\r\n    return this;\r\n  };\r\n}\r\n\r\n/**\r\n * A writer for meta-model backed document trees\r\n *\r\n * @param {Object} options output options to pass into the writer\r\n */\r\nfunction Writer(options) {\r\n\r\n  options = assign({ format: false, preamble: true }, options || {});\r\n\r\n  function toXML(tree, writer) {\r\n    var internalWriter = writer || new SavingWriter();\r\n    var formatingWriter = new FormatingWriter(internalWriter, options.format);\r\n\r\n    if (options.preamble) {\r\n      formatingWriter.append(XML_PREAMBLE);\r\n    }\r\n\r\n    new ElementSerializer().build(tree).serializeTo(formatingWriter);\r\n\r\n    if (!writer) {\r\n      return internalWriter.value;\r\n    }\r\n  }\r\n\r\n  return {\r\n    toXML: toXML\r\n  };\r\n}\r\n\r\nexport { Reader, Writer };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}