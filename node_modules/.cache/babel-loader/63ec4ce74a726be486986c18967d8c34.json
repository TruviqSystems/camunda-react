{"ast":null,"code":"var CLASS_PATTERN = /^class /;\nfunction isClass(fn) {\n  return CLASS_PATTERN.test(fn.toString());\n}\nfunction isArray(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\nfunction hasOwnProp(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nfunction annotate() {\n  var args = Array.prototype.slice.call(arguments);\n  if (args.length === 1 && isArray(args[0])) {\n    args = args[0];\n  }\n  var fn = args.pop();\n  fn.$inject = args;\n  return fn;\n}\n\n// Current limitations:\n// - can't put into \"function arg\" comments\n// function /* (no parenthesis like this) */ (){}\n// function abc( /* xx (no parenthesis like this) */ a, b) {}\n//\n// Just put the comment before function or inside:\n// /* (((this is fine))) */ function(a, b) {}\n// function abc(a) { /* (((this is fine))) */}\n//\n// - can't reliably auto-annotate constructor; we'll match the\n// first constructor(...) pattern found which may be the one\n// of a nested class, too.\n\nvar CONSTRUCTOR_ARGS = /constructor\\s*[^(]*\\(\\s*([^)]*)\\)/m;\nvar FN_ARGS = /^(?:async )?(?:function\\s*)?[^(]*\\(\\s*([^)]*)\\)/m;\nvar FN_ARG = /\\/\\*([^*]*)\\*\\//m;\nfunction parseAnnotations(fn) {\n  if (typeof fn !== 'function') {\n    throw new Error('Cannot annotate \"' + fn + '\". Expected a function!');\n  }\n  var match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);\n\n  // may parse class without constructor\n  if (!match) {\n    return [];\n  }\n  return match[1] && match[1].split(',').map(function (arg) {\n    match = arg.match(FN_ARG);\n    return match ? match[1].trim() : arg.trim();\n  }) || [];\n}\nfunction Module() {\n  var providers = [];\n  this.factory = function (name, factory) {\n    providers.push([name, 'factory', factory]);\n    return this;\n  };\n  this.value = function (name, value) {\n    providers.push([name, 'value', value]);\n    return this;\n  };\n  this.type = function (name, type) {\n    providers.push([name, 'type', type]);\n    return this;\n  };\n  this.forEach = function (iterator) {\n    providers.forEach(iterator);\n  };\n}\nfunction Injector(modules, parent) {\n  parent = parent || {\n    get: function (name, strict) {\n      currentlyResolving.push(name);\n      if (strict === false) {\n        return null;\n      } else {\n        throw error('No provider for \"' + name + '\"!');\n      }\n    }\n  };\n  var currentlyResolving = [];\n  var providers = this._providers = Object.create(parent._providers || null);\n  var instances = this._instances = Object.create(null);\n  var self = instances.injector = this;\n  var error = function (msg) {\n    var stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);\n  };\n\n  /**\n   * Return a named service.\n   *\n   * @param {String} name\n   * @param {Boolean} [strict=true] if false, resolve missing services to null\n   *\n   * @return {Object}\n   */\n  var get = function (name, strict) {\n    if (!providers[name] && name.indexOf('.') !== -1) {\n      var parts = name.split('.');\n      var pivot = get(parts.shift());\n      while (parts.length) {\n        pivot = pivot[parts.shift()];\n      }\n      return pivot;\n    }\n    if (hasOwnProp(instances, name)) {\n      return instances[name];\n    }\n    if (hasOwnProp(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Cannot resolve circular dependency!');\n      }\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n      return instances[name];\n    }\n    return parent.get(name, strict);\n  };\n  var fnDef = function (fn, locals) {\n    if (typeof locals === 'undefined') {\n      locals = {};\n    }\n    if (typeof fn !== 'function') {\n      if (isArray(fn)) {\n        fn = annotate(fn.slice());\n      } else {\n        throw new Error('Cannot invoke \"' + fn + '\". Expected a function!');\n      }\n    }\n    var inject = fn.$inject || parseAnnotations(fn);\n    var dependencies = inject.map(function (dep) {\n      if (hasOwnProp(locals, dep)) {\n        return locals[dep];\n      } else {\n        return get(dep);\n      }\n    });\n    return {\n      fn: fn,\n      dependencies: dependencies\n    };\n  };\n  var instantiate = function (Type) {\n    var def = fnDef(Type);\n    var fn = def.fn,\n      dependencies = def.dependencies;\n\n    // instantiate var args constructor\n    var Constructor = Function.prototype.bind.apply(fn, [null].concat(dependencies));\n    return new Constructor();\n  };\n  var invoke = function (func, context, locals) {\n    var def = fnDef(func, locals);\n    var fn = def.fn,\n      dependencies = def.dependencies;\n    return fn.apply(context, dependencies);\n  };\n  var createPrivateInjectorFactory = function (privateChildInjector) {\n    return annotate(function (key) {\n      return privateChildInjector.get(key);\n    });\n  };\n  var createChild = function (modules, forceNewInstances) {\n    if (forceNewInstances && forceNewInstances.length) {\n      var fromParentModule = Object.create(null);\n      var matchedScopes = Object.create(null);\n      var privateInjectorsCache = [];\n      var privateChildInjectors = [];\n      var privateChildFactories = [];\n      var provider;\n      var cacheIdx;\n      var privateChildInjector;\n      var privateChildInjectorFactory;\n      for (var name in providers) {\n        provider = providers[name];\n        if (forceNewInstances.indexOf(name) !== -1) {\n          if (provider[2] === 'private') {\n            cacheIdx = privateInjectorsCache.indexOf(provider[3]);\n            if (cacheIdx === -1) {\n              privateChildInjector = provider[3].createChild([], forceNewInstances);\n              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);\n              privateInjectorsCache.push(provider[3]);\n              privateChildInjectors.push(privateChildInjector);\n              privateChildFactories.push(privateChildInjectorFactory);\n              fromParentModule[name] = [privateChildInjectorFactory, name, 'private', privateChildInjector];\n            } else {\n              fromParentModule[name] = [privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx]];\n            }\n          } else {\n            fromParentModule[name] = [provider[2], provider[1]];\n          }\n          matchedScopes[name] = true;\n        }\n        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {\n          /* jshint -W083 */\n          forceNewInstances.forEach(function (scope) {\n            if (provider[1].$scope.indexOf(scope) !== -1) {\n              fromParentModule[name] = [provider[2], provider[1]];\n              matchedScopes[scope] = true;\n            }\n          });\n        }\n      }\n      forceNewInstances.forEach(function (scope) {\n        if (!matchedScopes[scope]) {\n          throw new Error('No provider for \"' + scope + '\". Cannot use provider from the parent!');\n        }\n      });\n      modules.unshift(fromParentModule);\n    }\n    return new Injector(modules, self);\n  };\n  var factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function (value) {\n      return value;\n    }\n  };\n  modules.forEach(function (module) {\n    function arrayUnwrap(type, value) {\n      if (type !== 'value' && isArray(value)) {\n        value = annotate(value.slice());\n      }\n      return value;\n    }\n\n    // TODO(vojta): handle wrong inputs (modules)\n    if (module instanceof Module) {\n      module.forEach(function (provider) {\n        var name = provider[0];\n        var type = provider[1];\n        var value = provider[2];\n        providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];\n      });\n    } else if (typeof module === 'object') {\n      if (module.__exports__) {\n        var clonedModule = Object.keys(module).reduce(function (m, key) {\n          if (key.substring(0, 2) !== '__') {\n            m[key] = module[key];\n          }\n          return m;\n        }, Object.create(null));\n        var privateInjector = new Injector((module.__modules__ || []).concat([clonedModule]), self);\n        var getFromPrivateInjector = annotate(function (key) {\n          return privateInjector.get(key);\n        });\n        module.__exports__.forEach(function (key) {\n          providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];\n        });\n      } else {\n        Object.keys(module).forEach(function (name) {\n          if (module[name][2] === 'private') {\n            providers[name] = module[name];\n            return;\n          }\n          var type = module[name][0];\n          var value = module[name][1];\n          providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];\n        });\n      }\n    }\n  });\n\n  // public API\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n}\nexport { annotate, parseAnnotations, Module, Injector };","map":{"version":3,"names":["CLASS_PATTERN","isClass","fn","test","toString","isArray","obj","Object","prototype","call","hasOwnProp","prop","hasOwnProperty","annotate","args","Array","slice","arguments","length","pop","$inject","CONSTRUCTOR_ARGS","FN_ARGS","FN_ARG","parseAnnotations","Error","match","split","map","arg","trim","Module","providers","factory","name","push","value","type","forEach","iterator","Injector","modules","parent","get","strict","currentlyResolving","error","_providers","create","instances","_instances","self","injector","msg","stack","join","indexOf","parts","pivot","shift","fnDef","locals","inject","dependencies","dep","instantiate","Type","def","Constructor","Function","bind","apply","concat","invoke","func","context","createPrivateInjectorFactory","privateChildInjector","key","createChild","forceNewInstances","fromParentModule","matchedScopes","privateInjectorsCache","privateChildInjectors","privateChildFactories","provider","cacheIdx","privateChildInjectorFactory","$scope","scope","unshift","factoryMap","module","arrayUnwrap","__exports__","clonedModule","keys","reduce","m","substring","privateInjector","__modules__","getFromPrivateInjector"],"sources":["C:/Users/KondalaRaoThota/Truviq_Camunda/camunda-react/node_modules/didi/dist/index.esm.js"],"sourcesContent":["var CLASS_PATTERN = /^class /;\n\nfunction isClass(fn) {\n  return CLASS_PATTERN.test(fn.toString());\n}\n\nfunction isArray(obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n}\n\nfunction hasOwnProp(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nfunction annotate() {\n  var args = Array.prototype.slice.call(arguments);\n\n  if (args.length === 1 && isArray(args[0])) {\n    args = args[0];\n  }\n\n  var fn = args.pop();\n\n  fn.$inject = args;\n\n  return fn;\n}\n\n\n// Current limitations:\n// - can't put into \"function arg\" comments\n// function /* (no parenthesis like this) */ (){}\n// function abc( /* xx (no parenthesis like this) */ a, b) {}\n//\n// Just put the comment before function or inside:\n// /* (((this is fine))) */ function(a, b) {}\n// function abc(a) { /* (((this is fine))) */}\n//\n// - can't reliably auto-annotate constructor; we'll match the\n// first constructor(...) pattern found which may be the one\n// of a nested class, too.\n\nvar CONSTRUCTOR_ARGS = /constructor\\s*[^(]*\\(\\s*([^)]*)\\)/m;\nvar FN_ARGS = /^(?:async )?(?:function\\s*)?[^(]*\\(\\s*([^)]*)\\)/m;\nvar FN_ARG = /\\/\\*([^*]*)\\*\\//m;\n\nfunction parseAnnotations(fn) {\n\n  if (typeof fn !== 'function') {\n    throw new Error('Cannot annotate \"' + fn + '\". Expected a function!');\n  }\n\n  var match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);\n\n  // may parse class without constructor\n  if (!match) {\n    return [];\n  }\n\n  return match[1] && match[1].split(',').map(function(arg) {\n    match = arg.match(FN_ARG);\n    return match ? match[1].trim() : arg.trim();\n  }) || [];\n}\n\nfunction Module() {\n  var providers = [];\n\n  this.factory = function(name, factory) {\n    providers.push([name, 'factory', factory]);\n    return this;\n  };\n\n  this.value = function(name, value) {\n    providers.push([name, 'value', value]);\n    return this;\n  };\n\n  this.type = function(name, type) {\n    providers.push([name, 'type', type]);\n    return this;\n  };\n\n  this.forEach = function(iterator) {\n    providers.forEach(iterator);\n  };\n\n}\n\nfunction Injector(modules, parent) {\n  parent = parent || {\n    get: function(name, strict) {\n      currentlyResolving.push(name);\n\n      if (strict === false) {\n        return null;\n      } else {\n        throw error('No provider for \"' + name + '\"!');\n      }\n    }\n  };\n\n  var currentlyResolving = [];\n  var providers = this._providers = Object.create(parent._providers || null);\n  var instances = this._instances = Object.create(null);\n\n  var self = instances.injector = this;\n\n  var error = function(msg) {\n    var stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);\n  };\n\n  /**\n   * Return a named service.\n   *\n   * @param {String} name\n   * @param {Boolean} [strict=true] if false, resolve missing services to null\n   *\n   * @return {Object}\n   */\n  var get = function(name, strict) {\n    if (!providers[name] && name.indexOf('.') !== -1) {\n      var parts = name.split('.');\n      var pivot = get(parts.shift());\n\n      while (parts.length) {\n        pivot = pivot[parts.shift()];\n      }\n\n      return pivot;\n    }\n\n    if (hasOwnProp(instances, name)) {\n      return instances[name];\n    }\n\n    if (hasOwnProp(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Cannot resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n\n      return instances[name];\n    }\n\n    return parent.get(name, strict);\n  };\n\n  var fnDef = function(fn, locals) {\n\n    if (typeof locals === 'undefined') {\n      locals = {};\n    }\n\n    if (typeof fn !== 'function') {\n      if (isArray(fn)) {\n        fn = annotate(fn.slice());\n      } else {\n        throw new Error('Cannot invoke \"' + fn + '\". Expected a function!');\n      }\n    }\n\n    var inject = fn.$inject || parseAnnotations(fn);\n    var dependencies = inject.map(function(dep) {\n      if (hasOwnProp(locals, dep)) {\n        return locals[dep];\n      } else {\n        return get(dep);\n      }\n    });\n\n    return {\n      fn: fn,\n      dependencies: dependencies\n    };\n  };\n\n  var instantiate = function(Type) {\n    var def = fnDef(Type);\n\n    var fn = def.fn,\n        dependencies = def.dependencies;\n\n    // instantiate var args constructor\n    var Constructor = Function.prototype.bind.apply(fn, [ null ].concat(dependencies));\n\n    return new Constructor();\n  };\n\n  var invoke = function(func, context, locals) {\n    var def = fnDef(func, locals);\n\n    var fn = def.fn,\n        dependencies = def.dependencies;\n\n    return fn.apply(context, dependencies);\n  };\n\n\n  var createPrivateInjectorFactory = function(privateChildInjector) {\n    return annotate(function(key) {\n      return privateChildInjector.get(key);\n    });\n  };\n\n  var createChild = function(modules, forceNewInstances) {\n    if (forceNewInstances && forceNewInstances.length) {\n      var fromParentModule = Object.create(null);\n      var matchedScopes = Object.create(null);\n\n      var privateInjectorsCache = [];\n      var privateChildInjectors = [];\n      var privateChildFactories = [];\n\n      var provider;\n      var cacheIdx;\n      var privateChildInjector;\n      var privateChildInjectorFactory;\n      for (var name in providers) {\n        provider = providers[name];\n\n        if (forceNewInstances.indexOf(name) !== -1) {\n          if (provider[2] === 'private') {\n            cacheIdx = privateInjectorsCache.indexOf(provider[3]);\n            if (cacheIdx === -1) {\n              privateChildInjector = provider[3].createChild([], forceNewInstances);\n              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);\n              privateInjectorsCache.push(provider[3]);\n              privateChildInjectors.push(privateChildInjector);\n              privateChildFactories.push(privateChildInjectorFactory);\n              fromParentModule[name] = [privateChildInjectorFactory, name, 'private', privateChildInjector];\n            } else {\n              fromParentModule[name] = [privateChildFactories[cacheIdx], name, 'private', privateChildInjectors[cacheIdx]];\n            }\n          } else {\n            fromParentModule[name] = [provider[2], provider[1]];\n          }\n          matchedScopes[name] = true;\n        }\n\n        if ((provider[2] === 'factory' || provider[2] === 'type') && provider[1].$scope) {\n          /* jshint -W083 */\n          forceNewInstances.forEach(function(scope) {\n            if (provider[1].$scope.indexOf(scope) !== -1) {\n              fromParentModule[name] = [provider[2], provider[1]];\n              matchedScopes[scope] = true;\n            }\n          });\n        }\n      }\n\n      forceNewInstances.forEach(function(scope) {\n        if (!matchedScopes[scope]) {\n          throw new Error('No provider for \"' + scope + '\". Cannot use provider from the parent!');\n        }\n      });\n\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, self);\n  };\n\n  var factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function(value) {\n      return value;\n    }\n  };\n\n  modules.forEach(function(module) {\n\n    function arrayUnwrap(type, value) {\n      if (type !== 'value' && isArray(value)) {\n        value = annotate(value.slice());\n      }\n\n      return value;\n    }\n\n    // TODO(vojta): handle wrong inputs (modules)\n    if (module instanceof Module) {\n      module.forEach(function(provider) {\n        var name = provider[0];\n        var type = provider[1];\n        var value = provider[2];\n\n        providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];\n      });\n    } else if (typeof module === 'object') {\n      if (module.__exports__) {\n        var clonedModule = Object.keys(module).reduce(function(m, key) {\n          if (key.substring(0, 2) !== '__') {\n            m[key] = module[key];\n          }\n          return m;\n        }, Object.create(null));\n\n        var privateInjector = new Injector((module.__modules__ || []).concat([clonedModule]), self);\n        var getFromPrivateInjector = annotate(function(key) {\n          return privateInjector.get(key);\n        });\n        module.__exports__.forEach(function(key) {\n          providers[key] = [getFromPrivateInjector, key, 'private', privateInjector];\n        });\n      } else {\n        Object.keys(module).forEach(function(name) {\n          if (module[name][2] === 'private') {\n            providers[name] = module[name];\n            return;\n          }\n\n          var type = module[name][0];\n          var value = module[name][1];\n\n          providers[name] = [factoryMap[type], arrayUnwrap(type, value), type];\n        });\n      }\n    }\n  });\n\n  // public API\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n}\n\nexport { annotate, parseAnnotations, Module, Injector };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}