{"ast":null,"code":"var mapping = require('./_mapping'),\n  fallbackHolder = require('./placeholder');\n\n/** Built-in value reference. */\nvar push = Array.prototype.push;\n\n/**\n * Creates a function, with an arity of `n`, that invokes `func` with the\n * arguments it receives.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {number} n The arity of the new function.\n * @returns {Function} Returns the new function.\n */\nfunction baseArity(func, n) {\n  return n == 2 ? function (a, b) {\n    return func.apply(undefined, arguments);\n  } : function (a) {\n    return func.apply(undefined, arguments);\n  };\n}\n\n/**\n * Creates a function that invokes `func`, with up to `n` arguments, ignoring\n * any additional arguments.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @param {number} n The arity cap.\n * @returns {Function} Returns the new function.\n */\nfunction baseAry(func, n) {\n  return n == 2 ? function (a, b) {\n    return func(a, b);\n  } : function (a) {\n    return func(a);\n  };\n}\n\n/**\n * Creates a clone of `array`.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the cloned array.\n */\nfunction cloneArray(array) {\n  var length = array ? array.length : 0,\n    result = Array(length);\n  while (length--) {\n    result[length] = array[length];\n  }\n  return result;\n}\n\n/**\n * Creates a function that clones a given object using the assignment `func`.\n *\n * @private\n * @param {Function} func The assignment function.\n * @returns {Function} Returns the new cloner function.\n */\nfunction createCloner(func) {\n  return function (object) {\n    return func({}, object);\n  };\n}\n\n/**\n * A specialized version of `_.spread` which flattens the spread array into\n * the arguments of the invoked `func`.\n *\n * @private\n * @param {Function} func The function to spread arguments over.\n * @param {number} start The start position of the spread.\n * @returns {Function} Returns the new function.\n */\nfunction flatSpread(func, start) {\n  return function () {\n    var length = arguments.length,\n      lastIndex = length - 1,\n      args = Array(length);\n    while (length--) {\n      args[length] = arguments[length];\n    }\n    var array = args[start],\n      otherArgs = args.slice(0, start);\n    if (array) {\n      push.apply(otherArgs, array);\n    }\n    if (start != lastIndex) {\n      push.apply(otherArgs, args.slice(start + 1));\n    }\n    return func.apply(this, otherArgs);\n  };\n}\n\n/**\n * Creates a function that wraps `func` and uses `cloner` to clone the first\n * argument it receives.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} cloner The function to clone arguments.\n * @returns {Function} Returns the new immutable function.\n */\nfunction wrapImmutable(func, cloner) {\n  return function () {\n    var length = arguments.length;\n    if (!length) {\n      return;\n    }\n    var args = Array(length);\n    while (length--) {\n      args[length] = arguments[length];\n    }\n    var result = args[0] = cloner.apply(undefined, args);\n    func.apply(undefined, args);\n    return result;\n  };\n}\n\n/**\n * The base implementation of `convert` which accepts a `util` object of methods\n * required to perform conversions.\n *\n * @param {Object} util The util object.\n * @param {string} name The name of the function to convert.\n * @param {Function} func The function to convert.\n * @param {Object} [options] The options object.\n * @param {boolean} [options.cap=true] Specify capping iteratee arguments.\n * @param {boolean} [options.curry=true] Specify currying.\n * @param {boolean} [options.fixed=true] Specify fixed arity.\n * @param {boolean} [options.immutable=true] Specify immutable operations.\n * @param {boolean} [options.rearg=true] Specify rearranging arguments.\n * @returns {Function|Object} Returns the converted function or object.\n */\nfunction baseConvert(util, name, func, options) {\n  var isLib = typeof name == 'function',\n    isObj = name === Object(name);\n  if (isObj) {\n    options = func;\n    func = name;\n    name = undefined;\n  }\n  if (func == null) {\n    throw new TypeError();\n  }\n  options || (options = {});\n  var config = {\n    'cap': 'cap' in options ? options.cap : true,\n    'curry': 'curry' in options ? options.curry : true,\n    'fixed': 'fixed' in options ? options.fixed : true,\n    'immutable': 'immutable' in options ? options.immutable : true,\n    'rearg': 'rearg' in options ? options.rearg : true\n  };\n  var defaultHolder = isLib ? func : fallbackHolder,\n    forceCurry = 'curry' in options && options.curry,\n    forceFixed = 'fixed' in options && options.fixed,\n    forceRearg = 'rearg' in options && options.rearg,\n    pristine = isLib ? func.runInContext() : undefined;\n  var helpers = isLib ? func : {\n    'ary': util.ary,\n    'assign': util.assign,\n    'clone': util.clone,\n    'curry': util.curry,\n    'forEach': util.forEach,\n    'isArray': util.isArray,\n    'isError': util.isError,\n    'isFunction': util.isFunction,\n    'isWeakMap': util.isWeakMap,\n    'iteratee': util.iteratee,\n    'keys': util.keys,\n    'rearg': util.rearg,\n    'toInteger': util.toInteger,\n    'toPath': util.toPath\n  };\n  var ary = helpers.ary,\n    assign = helpers.assign,\n    clone = helpers.clone,\n    curry = helpers.curry,\n    each = helpers.forEach,\n    isArray = helpers.isArray,\n    isError = helpers.isError,\n    isFunction = helpers.isFunction,\n    isWeakMap = helpers.isWeakMap,\n    keys = helpers.keys,\n    rearg = helpers.rearg,\n    toInteger = helpers.toInteger,\n    toPath = helpers.toPath;\n  var aryMethodKeys = keys(mapping.aryMethod);\n  var wrappers = {\n    'castArray': function (castArray) {\n      return function () {\n        var value = arguments[0];\n        return isArray(value) ? castArray(cloneArray(value)) : castArray.apply(undefined, arguments);\n      };\n    },\n    'iteratee': function (iteratee) {\n      return function () {\n        var func = arguments[0],\n          arity = arguments[1],\n          result = iteratee(func, arity),\n          length = result.length;\n        if (config.cap && typeof arity == 'number') {\n          arity = arity > 2 ? arity - 2 : 1;\n          return length && length <= arity ? result : baseAry(result, arity);\n        }\n        return result;\n      };\n    },\n    'mixin': function (mixin) {\n      return function (source) {\n        var func = this;\n        if (!isFunction(func)) {\n          return mixin(func, Object(source));\n        }\n        var pairs = [];\n        each(keys(source), function (key) {\n          if (isFunction(source[key])) {\n            pairs.push([key, func.prototype[key]]);\n          }\n        });\n        mixin(func, Object(source));\n        each(pairs, function (pair) {\n          var value = pair[1];\n          if (isFunction(value)) {\n            func.prototype[pair[0]] = value;\n          } else {\n            delete func.prototype[pair[0]];\n          }\n        });\n        return func;\n      };\n    },\n    'nthArg': function (nthArg) {\n      return function (n) {\n        var arity = n < 0 ? 1 : toInteger(n) + 1;\n        return curry(nthArg(n), arity);\n      };\n    },\n    'rearg': function (rearg) {\n      return function (func, indexes) {\n        var arity = indexes ? indexes.length : 0;\n        return curry(rearg(func, indexes), arity);\n      };\n    },\n    'runInContext': function (runInContext) {\n      return function (context) {\n        return baseConvert(util, runInContext(context), options);\n      };\n    }\n  };\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Casts `func` to a function with an arity capped iteratee if needed.\n   *\n   * @private\n   * @param {string} name The name of the function to inspect.\n   * @param {Function} func The function to inspect.\n   * @returns {Function} Returns the cast function.\n   */\n  function castCap(name, func) {\n    if (config.cap) {\n      var indexes = mapping.iterateeRearg[name];\n      if (indexes) {\n        return iterateeRearg(func, indexes);\n      }\n      var n = !isLib && mapping.iterateeAry[name];\n      if (n) {\n        return iterateeAry(func, n);\n      }\n    }\n    return func;\n  }\n\n  /**\n   * Casts `func` to a curried function if needed.\n   *\n   * @private\n   * @param {string} name The name of the function to inspect.\n   * @param {Function} func The function to inspect.\n   * @param {number} n The arity of `func`.\n   * @returns {Function} Returns the cast function.\n   */\n  function castCurry(name, func, n) {\n    return forceCurry || config.curry && n > 1 ? curry(func, n) : func;\n  }\n\n  /**\n   * Casts `func` to a fixed arity function if needed.\n   *\n   * @private\n   * @param {string} name The name of the function to inspect.\n   * @param {Function} func The function to inspect.\n   * @param {number} n The arity cap.\n   * @returns {Function} Returns the cast function.\n   */\n  function castFixed(name, func, n) {\n    if (config.fixed && (forceFixed || !mapping.skipFixed[name])) {\n      var data = mapping.methodSpread[name],\n        start = data && data.start;\n      return start === undefined ? ary(func, n) : flatSpread(func, start);\n    }\n    return func;\n  }\n\n  /**\n   * Casts `func` to an rearged function if needed.\n   *\n   * @private\n   * @param {string} name The name of the function to inspect.\n   * @param {Function} func The function to inspect.\n   * @param {number} n The arity of `func`.\n   * @returns {Function} Returns the cast function.\n   */\n  function castRearg(name, func, n) {\n    return config.rearg && n > 1 && (forceRearg || !mapping.skipRearg[name]) ? rearg(func, mapping.methodRearg[name] || mapping.aryRearg[n]) : func;\n  }\n\n  /**\n   * Creates a clone of `object` by `path`.\n   *\n   * @private\n   * @param {Object} object The object to clone.\n   * @param {Array|string} path The path to clone by.\n   * @returns {Object} Returns the cloned object.\n   */\n  function cloneByPath(object, path) {\n    path = toPath(path);\n    var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      result = clone(Object(object)),\n      nested = result;\n    while (nested != null && ++index < length) {\n      var key = path[index],\n        value = nested[key];\n      if (value != null && !(isFunction(value) || isError(value) || isWeakMap(value))) {\n        nested[key] = clone(index == lastIndex ? value : Object(value));\n      }\n      nested = nested[key];\n    }\n    return result;\n  }\n\n  /**\n   * Converts `lodash` to an immutable auto-curried iteratee-first data-last\n   * version with conversion `options` applied.\n   *\n   * @param {Object} [options] The options object. See `baseConvert` for more details.\n   * @returns {Function} Returns the converted `lodash`.\n   */\n  function convertLib(options) {\n    return _.runInContext.convert(options)(undefined);\n  }\n\n  /**\n   * Create a converter function for `func` of `name`.\n   *\n   * @param {string} name The name of the function to convert.\n   * @param {Function} func The function to convert.\n   * @returns {Function} Returns the new converter function.\n   */\n  function createConverter(name, func) {\n    var realName = mapping.aliasToReal[name] || name,\n      methodName = mapping.remap[realName] || realName,\n      oldOptions = options;\n    return function (options) {\n      var newUtil = isLib ? pristine : helpers,\n        newFunc = isLib ? pristine[methodName] : func,\n        newOptions = assign(assign({}, oldOptions), options);\n      return baseConvert(newUtil, realName, newFunc, newOptions);\n    };\n  }\n\n  /**\n   * Creates a function that wraps `func` to invoke its iteratee, with up to `n`\n   * arguments, ignoring any additional arguments.\n   *\n   * @private\n   * @param {Function} func The function to cap iteratee arguments for.\n   * @param {number} n The arity cap.\n   * @returns {Function} Returns the new function.\n   */\n  function iterateeAry(func, n) {\n    return overArg(func, function (func) {\n      return typeof func == 'function' ? baseAry(func, n) : func;\n    });\n  }\n\n  /**\n   * Creates a function that wraps `func` to invoke its iteratee with arguments\n   * arranged according to the specified `indexes` where the argument value at\n   * the first index is provided as the first argument, the argument value at\n   * the second index is provided as the second argument, and so on.\n   *\n   * @private\n   * @param {Function} func The function to rearrange iteratee arguments for.\n   * @param {number[]} indexes The arranged argument indexes.\n   * @returns {Function} Returns the new function.\n   */\n  function iterateeRearg(func, indexes) {\n    return overArg(func, function (func) {\n      var n = indexes.length;\n      return baseArity(rearg(baseAry(func, n), indexes), n);\n    });\n  }\n\n  /**\n   * Creates a function that invokes `func` with its first argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function () {\n      var length = arguments.length;\n      if (!length) {\n        return func();\n      }\n      var args = Array(length);\n      while (length--) {\n        args[length] = arguments[length];\n      }\n      var index = config.rearg ? 0 : length - 1;\n      args[index] = transform(args[index]);\n      return func.apply(undefined, args);\n    };\n  }\n\n  /**\n   * Creates a function that wraps `func` and applys the conversions\n   * rules by `name`.\n   *\n   * @private\n   * @param {string} name The name of the function to wrap.\n   * @param {Function} func The function to wrap.\n   * @returns {Function} Returns the converted function.\n   */\n  function wrap(name, func, placeholder) {\n    var result,\n      realName = mapping.aliasToReal[name] || name,\n      wrapped = func,\n      wrapper = wrappers[realName];\n    if (wrapper) {\n      wrapped = wrapper(func);\n    } else if (config.immutable) {\n      if (mapping.mutate.array[realName]) {\n        wrapped = wrapImmutable(func, cloneArray);\n      } else if (mapping.mutate.object[realName]) {\n        wrapped = wrapImmutable(func, createCloner(func));\n      } else if (mapping.mutate.set[realName]) {\n        wrapped = wrapImmutable(func, cloneByPath);\n      }\n    }\n    each(aryMethodKeys, function (aryKey) {\n      each(mapping.aryMethod[aryKey], function (otherName) {\n        if (realName == otherName) {\n          var data = mapping.methodSpread[realName],\n            afterRearg = data && data.afterRearg;\n          result = afterRearg ? castFixed(realName, castRearg(realName, wrapped, aryKey), aryKey) : castRearg(realName, castFixed(realName, wrapped, aryKey), aryKey);\n          result = castCap(realName, result);\n          result = castCurry(realName, result, aryKey);\n          return false;\n        }\n      });\n      return !result;\n    });\n    result || (result = wrapped);\n    if (result == func) {\n      result = forceCurry ? curry(result, 1) : function () {\n        return func.apply(this, arguments);\n      };\n    }\n    result.convert = createConverter(realName, func);\n    result.placeholder = func.placeholder = placeholder;\n    return result;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  if (!isObj) {\n    return wrap(name, func, defaultHolder);\n  }\n  var _ = func;\n\n  // Convert methods by ary cap.\n  var pairs = [];\n  each(aryMethodKeys, function (aryKey) {\n    each(mapping.aryMethod[aryKey], function (key) {\n      var func = _[mapping.remap[key] || key];\n      if (func) {\n        pairs.push([key, wrap(key, func, _)]);\n      }\n    });\n  });\n\n  // Convert remaining methods.\n  each(keys(_), function (key) {\n    var func = _[key];\n    if (typeof func == 'function') {\n      var length = pairs.length;\n      while (length--) {\n        if (pairs[length][0] == key) {\n          return;\n        }\n      }\n      func.convert = createConverter(key, func);\n      pairs.push([key, func]);\n    }\n  });\n\n  // Assign to `_` leaving `_.prototype` unchanged to allow chaining.\n  each(pairs, function (pair) {\n    _[pair[0]] = pair[1];\n  });\n  _.convert = convertLib;\n  _.placeholder = _;\n\n  // Assign aliases.\n  each(keys(_), function (key) {\n    each(mapping.realToAlias[key] || [], function (alias) {\n      _[alias] = _[key];\n    });\n  });\n  return _;\n}\nmodule.exports = baseConvert;","map":{"version":3,"names":["mapping","require","fallbackHolder","push","Array","prototype","baseArity","func","n","a","b","apply","undefined","arguments","baseAry","cloneArray","array","length","result","createCloner","object","flatSpread","start","lastIndex","args","otherArgs","slice","wrapImmutable","cloner","baseConvert","util","name","options","isLib","isObj","Object","TypeError","config","cap","curry","fixed","immutable","rearg","defaultHolder","forceCurry","forceFixed","forceRearg","pristine","runInContext","helpers","ary","assign","clone","forEach","isArray","isError","isFunction","isWeakMap","iteratee","keys","toInteger","toPath","each","aryMethodKeys","aryMethod","wrappers","castArray","value","arity","mixin","source","pairs","key","pair","nthArg","indexes","context","castCap","iterateeRearg","iterateeAry","castCurry","castFixed","skipFixed","data","methodSpread","castRearg","skipRearg","methodRearg","aryRearg","cloneByPath","path","index","nested","convertLib","_","convert","createConverter","realName","aliasToReal","methodName","remap","oldOptions","newUtil","newFunc","newOptions","overArg","transform","wrap","placeholder","wrapped","wrapper","mutate","set","aryKey","otherName","afterRearg","realToAlias","alias","module","exports"],"sources":["C:/Users/KondalaRaoThota/Truviq_Camunda/camunda-react/node_modules/lodash/fp/_baseConvert.js"],"sourcesContent":["var mapping = require('./_mapping'),\n    fallbackHolder = require('./placeholder');\n\n/** Built-in value reference. */\nvar push = Array.prototype.push;\n\n/**\n * Creates a function, with an arity of `n`, that invokes `func` with the\n * arguments it receives.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {number} n The arity of the new function.\n * @returns {Function} Returns the new function.\n */\nfunction baseArity(func, n) {\n  return n == 2\n    ? function(a, b) { return func.apply(undefined, arguments); }\n    : function(a) { return func.apply(undefined, arguments); };\n}\n\n/**\n * Creates a function that invokes `func`, with up to `n` arguments, ignoring\n * any additional arguments.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @param {number} n The arity cap.\n * @returns {Function} Returns the new function.\n */\nfunction baseAry(func, n) {\n  return n == 2\n    ? function(a, b) { return func(a, b); }\n    : function(a) { return func(a); };\n}\n\n/**\n * Creates a clone of `array`.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the cloned array.\n */\nfunction cloneArray(array) {\n  var length = array ? array.length : 0,\n      result = Array(length);\n\n  while (length--) {\n    result[length] = array[length];\n  }\n  return result;\n}\n\n/**\n * Creates a function that clones a given object using the assignment `func`.\n *\n * @private\n * @param {Function} func The assignment function.\n * @returns {Function} Returns the new cloner function.\n */\nfunction createCloner(func) {\n  return function(object) {\n    return func({}, object);\n  };\n}\n\n/**\n * A specialized version of `_.spread` which flattens the spread array into\n * the arguments of the invoked `func`.\n *\n * @private\n * @param {Function} func The function to spread arguments over.\n * @param {number} start The start position of the spread.\n * @returns {Function} Returns the new function.\n */\nfunction flatSpread(func, start) {\n  return function() {\n    var length = arguments.length,\n        lastIndex = length - 1,\n        args = Array(length);\n\n    while (length--) {\n      args[length] = arguments[length];\n    }\n    var array = args[start],\n        otherArgs = args.slice(0, start);\n\n    if (array) {\n      push.apply(otherArgs, array);\n    }\n    if (start != lastIndex) {\n      push.apply(otherArgs, args.slice(start + 1));\n    }\n    return func.apply(this, otherArgs);\n  };\n}\n\n/**\n * Creates a function that wraps `func` and uses `cloner` to clone the first\n * argument it receives.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} cloner The function to clone arguments.\n * @returns {Function} Returns the new immutable function.\n */\nfunction wrapImmutable(func, cloner) {\n  return function() {\n    var length = arguments.length;\n    if (!length) {\n      return;\n    }\n    var args = Array(length);\n    while (length--) {\n      args[length] = arguments[length];\n    }\n    var result = args[0] = cloner.apply(undefined, args);\n    func.apply(undefined, args);\n    return result;\n  };\n}\n\n/**\n * The base implementation of `convert` which accepts a `util` object of methods\n * required to perform conversions.\n *\n * @param {Object} util The util object.\n * @param {string} name The name of the function to convert.\n * @param {Function} func The function to convert.\n * @param {Object} [options] The options object.\n * @param {boolean} [options.cap=true] Specify capping iteratee arguments.\n * @param {boolean} [options.curry=true] Specify currying.\n * @param {boolean} [options.fixed=true] Specify fixed arity.\n * @param {boolean} [options.immutable=true] Specify immutable operations.\n * @param {boolean} [options.rearg=true] Specify rearranging arguments.\n * @returns {Function|Object} Returns the converted function or object.\n */\nfunction baseConvert(util, name, func, options) {\n  var isLib = typeof name == 'function',\n      isObj = name === Object(name);\n\n  if (isObj) {\n    options = func;\n    func = name;\n    name = undefined;\n  }\n  if (func == null) {\n    throw new TypeError;\n  }\n  options || (options = {});\n\n  var config = {\n    'cap': 'cap' in options ? options.cap : true,\n    'curry': 'curry' in options ? options.curry : true,\n    'fixed': 'fixed' in options ? options.fixed : true,\n    'immutable': 'immutable' in options ? options.immutable : true,\n    'rearg': 'rearg' in options ? options.rearg : true\n  };\n\n  var defaultHolder = isLib ? func : fallbackHolder,\n      forceCurry = ('curry' in options) && options.curry,\n      forceFixed = ('fixed' in options) && options.fixed,\n      forceRearg = ('rearg' in options) && options.rearg,\n      pristine = isLib ? func.runInContext() : undefined;\n\n  var helpers = isLib ? func : {\n    'ary': util.ary,\n    'assign': util.assign,\n    'clone': util.clone,\n    'curry': util.curry,\n    'forEach': util.forEach,\n    'isArray': util.isArray,\n    'isError': util.isError,\n    'isFunction': util.isFunction,\n    'isWeakMap': util.isWeakMap,\n    'iteratee': util.iteratee,\n    'keys': util.keys,\n    'rearg': util.rearg,\n    'toInteger': util.toInteger,\n    'toPath': util.toPath\n  };\n\n  var ary = helpers.ary,\n      assign = helpers.assign,\n      clone = helpers.clone,\n      curry = helpers.curry,\n      each = helpers.forEach,\n      isArray = helpers.isArray,\n      isError = helpers.isError,\n      isFunction = helpers.isFunction,\n      isWeakMap = helpers.isWeakMap,\n      keys = helpers.keys,\n      rearg = helpers.rearg,\n      toInteger = helpers.toInteger,\n      toPath = helpers.toPath;\n\n  var aryMethodKeys = keys(mapping.aryMethod);\n\n  var wrappers = {\n    'castArray': function(castArray) {\n      return function() {\n        var value = arguments[0];\n        return isArray(value)\n          ? castArray(cloneArray(value))\n          : castArray.apply(undefined, arguments);\n      };\n    },\n    'iteratee': function(iteratee) {\n      return function() {\n        var func = arguments[0],\n            arity = arguments[1],\n            result = iteratee(func, arity),\n            length = result.length;\n\n        if (config.cap && typeof arity == 'number') {\n          arity = arity > 2 ? (arity - 2) : 1;\n          return (length && length <= arity) ? result : baseAry(result, arity);\n        }\n        return result;\n      };\n    },\n    'mixin': function(mixin) {\n      return function(source) {\n        var func = this;\n        if (!isFunction(func)) {\n          return mixin(func, Object(source));\n        }\n        var pairs = [];\n        each(keys(source), function(key) {\n          if (isFunction(source[key])) {\n            pairs.push([key, func.prototype[key]]);\n          }\n        });\n\n        mixin(func, Object(source));\n\n        each(pairs, function(pair) {\n          var value = pair[1];\n          if (isFunction(value)) {\n            func.prototype[pair[0]] = value;\n          } else {\n            delete func.prototype[pair[0]];\n          }\n        });\n        return func;\n      };\n    },\n    'nthArg': function(nthArg) {\n      return function(n) {\n        var arity = n < 0 ? 1 : (toInteger(n) + 1);\n        return curry(nthArg(n), arity);\n      };\n    },\n    'rearg': function(rearg) {\n      return function(func, indexes) {\n        var arity = indexes ? indexes.length : 0;\n        return curry(rearg(func, indexes), arity);\n      };\n    },\n    'runInContext': function(runInContext) {\n      return function(context) {\n        return baseConvert(util, runInContext(context), options);\n      };\n    }\n  };\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Casts `func` to a function with an arity capped iteratee if needed.\n   *\n   * @private\n   * @param {string} name The name of the function to inspect.\n   * @param {Function} func The function to inspect.\n   * @returns {Function} Returns the cast function.\n   */\n  function castCap(name, func) {\n    if (config.cap) {\n      var indexes = mapping.iterateeRearg[name];\n      if (indexes) {\n        return iterateeRearg(func, indexes);\n      }\n      var n = !isLib && mapping.iterateeAry[name];\n      if (n) {\n        return iterateeAry(func, n);\n      }\n    }\n    return func;\n  }\n\n  /**\n   * Casts `func` to a curried function if needed.\n   *\n   * @private\n   * @param {string} name The name of the function to inspect.\n   * @param {Function} func The function to inspect.\n   * @param {number} n The arity of `func`.\n   * @returns {Function} Returns the cast function.\n   */\n  function castCurry(name, func, n) {\n    return (forceCurry || (config.curry && n > 1))\n      ? curry(func, n)\n      : func;\n  }\n\n  /**\n   * Casts `func` to a fixed arity function if needed.\n   *\n   * @private\n   * @param {string} name The name of the function to inspect.\n   * @param {Function} func The function to inspect.\n   * @param {number} n The arity cap.\n   * @returns {Function} Returns the cast function.\n   */\n  function castFixed(name, func, n) {\n    if (config.fixed && (forceFixed || !mapping.skipFixed[name])) {\n      var data = mapping.methodSpread[name],\n          start = data && data.start;\n\n      return start  === undefined ? ary(func, n) : flatSpread(func, start);\n    }\n    return func;\n  }\n\n  /**\n   * Casts `func` to an rearged function if needed.\n   *\n   * @private\n   * @param {string} name The name of the function to inspect.\n   * @param {Function} func The function to inspect.\n   * @param {number} n The arity of `func`.\n   * @returns {Function} Returns the cast function.\n   */\n  function castRearg(name, func, n) {\n    return (config.rearg && n > 1 && (forceRearg || !mapping.skipRearg[name]))\n      ? rearg(func, mapping.methodRearg[name] || mapping.aryRearg[n])\n      : func;\n  }\n\n  /**\n   * Creates a clone of `object` by `path`.\n   *\n   * @private\n   * @param {Object} object The object to clone.\n   * @param {Array|string} path The path to clone by.\n   * @returns {Object} Returns the cloned object.\n   */\n  function cloneByPath(object, path) {\n    path = toPath(path);\n\n    var index = -1,\n        length = path.length,\n        lastIndex = length - 1,\n        result = clone(Object(object)),\n        nested = result;\n\n    while (nested != null && ++index < length) {\n      var key = path[index],\n          value = nested[key];\n\n      if (value != null &&\n          !(isFunction(value) || isError(value) || isWeakMap(value))) {\n        nested[key] = clone(index == lastIndex ? value : Object(value));\n      }\n      nested = nested[key];\n    }\n    return result;\n  }\n\n  /**\n   * Converts `lodash` to an immutable auto-curried iteratee-first data-last\n   * version with conversion `options` applied.\n   *\n   * @param {Object} [options] The options object. See `baseConvert` for more details.\n   * @returns {Function} Returns the converted `lodash`.\n   */\n  function convertLib(options) {\n    return _.runInContext.convert(options)(undefined);\n  }\n\n  /**\n   * Create a converter function for `func` of `name`.\n   *\n   * @param {string} name The name of the function to convert.\n   * @param {Function} func The function to convert.\n   * @returns {Function} Returns the new converter function.\n   */\n  function createConverter(name, func) {\n    var realName = mapping.aliasToReal[name] || name,\n        methodName = mapping.remap[realName] || realName,\n        oldOptions = options;\n\n    return function(options) {\n      var newUtil = isLib ? pristine : helpers,\n          newFunc = isLib ? pristine[methodName] : func,\n          newOptions = assign(assign({}, oldOptions), options);\n\n      return baseConvert(newUtil, realName, newFunc, newOptions);\n    };\n  }\n\n  /**\n   * Creates a function that wraps `func` to invoke its iteratee, with up to `n`\n   * arguments, ignoring any additional arguments.\n   *\n   * @private\n   * @param {Function} func The function to cap iteratee arguments for.\n   * @param {number} n The arity cap.\n   * @returns {Function} Returns the new function.\n   */\n  function iterateeAry(func, n) {\n    return overArg(func, function(func) {\n      return typeof func == 'function' ? baseAry(func, n) : func;\n    });\n  }\n\n  /**\n   * Creates a function that wraps `func` to invoke its iteratee with arguments\n   * arranged according to the specified `indexes` where the argument value at\n   * the first index is provided as the first argument, the argument value at\n   * the second index is provided as the second argument, and so on.\n   *\n   * @private\n   * @param {Function} func The function to rearrange iteratee arguments for.\n   * @param {number[]} indexes The arranged argument indexes.\n   * @returns {Function} Returns the new function.\n   */\n  function iterateeRearg(func, indexes) {\n    return overArg(func, function(func) {\n      var n = indexes.length;\n      return baseArity(rearg(baseAry(func, n), indexes), n);\n    });\n  }\n\n  /**\n   * Creates a function that invokes `func` with its first argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function() {\n      var length = arguments.length;\n      if (!length) {\n        return func();\n      }\n      var args = Array(length);\n      while (length--) {\n        args[length] = arguments[length];\n      }\n      var index = config.rearg ? 0 : (length - 1);\n      args[index] = transform(args[index]);\n      return func.apply(undefined, args);\n    };\n  }\n\n  /**\n   * Creates a function that wraps `func` and applys the conversions\n   * rules by `name`.\n   *\n   * @private\n   * @param {string} name The name of the function to wrap.\n   * @param {Function} func The function to wrap.\n   * @returns {Function} Returns the converted function.\n   */\n  function wrap(name, func, placeholder) {\n    var result,\n        realName = mapping.aliasToReal[name] || name,\n        wrapped = func,\n        wrapper = wrappers[realName];\n\n    if (wrapper) {\n      wrapped = wrapper(func);\n    }\n    else if (config.immutable) {\n      if (mapping.mutate.array[realName]) {\n        wrapped = wrapImmutable(func, cloneArray);\n      }\n      else if (mapping.mutate.object[realName]) {\n        wrapped = wrapImmutable(func, createCloner(func));\n      }\n      else if (mapping.mutate.set[realName]) {\n        wrapped = wrapImmutable(func, cloneByPath);\n      }\n    }\n    each(aryMethodKeys, function(aryKey) {\n      each(mapping.aryMethod[aryKey], function(otherName) {\n        if (realName == otherName) {\n          var data = mapping.methodSpread[realName],\n              afterRearg = data && data.afterRearg;\n\n          result = afterRearg\n            ? castFixed(realName, castRearg(realName, wrapped, aryKey), aryKey)\n            : castRearg(realName, castFixed(realName, wrapped, aryKey), aryKey);\n\n          result = castCap(realName, result);\n          result = castCurry(realName, result, aryKey);\n          return false;\n        }\n      });\n      return !result;\n    });\n\n    result || (result = wrapped);\n    if (result == func) {\n      result = forceCurry ? curry(result, 1) : function() {\n        return func.apply(this, arguments);\n      };\n    }\n    result.convert = createConverter(realName, func);\n    result.placeholder = func.placeholder = placeholder;\n\n    return result;\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  if (!isObj) {\n    return wrap(name, func, defaultHolder);\n  }\n  var _ = func;\n\n  // Convert methods by ary cap.\n  var pairs = [];\n  each(aryMethodKeys, function(aryKey) {\n    each(mapping.aryMethod[aryKey], function(key) {\n      var func = _[mapping.remap[key] || key];\n      if (func) {\n        pairs.push([key, wrap(key, func, _)]);\n      }\n    });\n  });\n\n  // Convert remaining methods.\n  each(keys(_), function(key) {\n    var func = _[key];\n    if (typeof func == 'function') {\n      var length = pairs.length;\n      while (length--) {\n        if (pairs[length][0] == key) {\n          return;\n        }\n      }\n      func.convert = createConverter(key, func);\n      pairs.push([key, func]);\n    }\n  });\n\n  // Assign to `_` leaving `_.prototype` unchanged to allow chaining.\n  each(pairs, function(pair) {\n    _[pair[0]] = pair[1];\n  });\n\n  _.convert = convertLib;\n  _.placeholder = _;\n\n  // Assign aliases.\n  each(keys(_), function(key) {\n    each(mapping.realToAlias[key] || [], function(alias) {\n      _[alias] = _[key];\n    });\n  });\n\n  return _;\n}\n\nmodule.exports = baseConvert;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}