{"ast":null,"code":"import { normalize, schema } from 'normalizr';\nimport { camelizeKeys } from 'humps';\nconst API_ROOT = '/engine-rest/';\n\n// Fetches an API response and normalizes the result JSON according to schema.\n// This makes every API response have the same shape, regardless of how nested it was.\nconst callApi = function (endpoint, schema) {\n  let settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const fullUrl = endpoint.indexOf(API_ROOT) === -1 ? API_ROOT + endpoint : endpoint;\n  return fetch(fullUrl, settings).then(response => response.json().then(json => {\n    if (!response.ok) {\n      return Promise.reject(json);\n    }\n    const camelizedJson = camelizeKeys(json);\n    return Object.assign({}, normalize(camelizedJson, schema), {});\n  }));\n};\n\n// We use this Normalizr schemas to transform API responses from a nested form\n// to a flat form where repos and users are placed in `entities`, and nested\n// JSON objects are replaced with their IDs. This is very convenient for\n// consumption by reducers, because we can easily build a normalized tree\n// and keep it updated as we fetch more data.\n\n// Read more about Normalizr: https://github.com/paularmstrong/normalizr\n\nconst processDefinitionSchema = new schema.Entity('processDefinition', {}, {\n  id: processDefinition => processDefinition.id,\n  name: processDefinition => processDefinition.name\n});\nconst processDefinitionXMLSchema = new schema.Entity('processDefinitionXML', {}, {});\nconst formKeySchema = new schema.Entity('formKey', {}, {\n  idAttribute: 'test'\n});\nconst processInstanceStartedSchema = new schema.Entity('processInstanceStarted', {}, {});\nconst taskSchema = new schema.Entity('task', {}, {\n  id: task => task.id\n});\nconst taskVariableSchema = new schema.Entity('taskVariable', {}, {\n  processStrategy: (value, parent, key) => {\n    return {\n      values: value,\n      test: key,\n      parent: parent\n    };\n  }\n});\nconst taskVariableArraySchema = new schema.Entity('taskVariables', {}, {\n  idAttribute: variable => 'variables',\n  processStrategy: (value, parent, key) => {\n    let values = {};\n    Object.keys(value).forEach(item => {\n      values[item] = value[item].value;\n    });\n    return values;\n  }\n});\nconst processDeploymentSchema = new schema.Entity('processDeployment', {}, {});\n\n// Schemas for Github API responses.\nexport const Schemas = {\n  PROCESS_DEFINITION: processDefinitionSchema,\n  PROCESS_DEFINITION_ARRAY: [processDefinitionSchema],\n  PROCESS_DEFINITION_XML: processDefinitionXMLSchema,\n  FORM_KEY: formKeySchema,\n  TASK: taskSchema,\n  TASK_ARRAY: [taskSchema],\n  PROCESS_INSTANCE_STARTED: processInstanceStartedSchema,\n  TASK_VARIABLE: taskVariableSchema,\n  TASK_VARIABLES: taskVariableArraySchema,\n  PROCESS_DEPLOYMENT: processDeploymentSchema\n};\n\n// Action key that carries API call info interpreted by this Redux middleware.\nexport const CALL_API = 'Call API';\n\n// A Redux middleware that interprets actions with CALL_API info specified.\n// Performs the call and promises when such actions are dispatched.\nexport default (store => next => action => {\n  const callAPI = action[CALL_API];\n  if (typeof callAPI === 'undefined') {\n    return next(action);\n  }\n  let {\n    endpoint\n  } = callAPI;\n  const {\n    schema,\n    types,\n    settings\n  } = callAPI;\n  if (typeof endpoint === 'function') {\n    endpoint = endpoint(store.getState());\n  }\n  if (typeof endpoint !== 'string') {\n    throw new Error('Specify a string endpoint URL.');\n  }\n  if (!schema) {\n    throw new Error('Specify one of the exported Schemas.');\n  }\n  if (!Array.isArray(types) || types.length !== 3) {\n    throw new Error('Expected an array of three action types.');\n  }\n  if (!types.every(type => typeof type === 'string')) {\n    throw new Error('Expected action types to be strings.');\n  }\n  const actionWith = data => {\n    const finalAction = Object.assign({}, action, data);\n    delete finalAction[CALL_API];\n    return finalAction;\n  };\n  const [requestType, successType, failureType] = types;\n  next(actionWith({\n    type: requestType\n  }));\n  return callApi(endpoint, schema, settings).then(response => next(actionWith({\n    response,\n    type: successType\n  })), error => next(actionWith({\n    type: failureType,\n    error: error.message || 'Something bad happened'\n  })));\n});","map":{"version":3,"names":["normalize","schema","camelizeKeys","API_ROOT","callApi","endpoint","settings","arguments","length","undefined","fullUrl","indexOf","fetch","then","response","json","ok","Promise","reject","camelizedJson","Object","assign","processDefinitionSchema","Entity","id","processDefinition","name","processDefinitionXMLSchema","formKeySchema","idAttribute","processInstanceStartedSchema","taskSchema","task","taskVariableSchema","processStrategy","value","parent","key","values","test","taskVariableArraySchema","variable","keys","forEach","item","processDeploymentSchema","Schemas","PROCESS_DEFINITION","PROCESS_DEFINITION_ARRAY","PROCESS_DEFINITION_XML","FORM_KEY","TASK","TASK_ARRAY","PROCESS_INSTANCE_STARTED","TASK_VARIABLE","TASK_VARIABLES","PROCESS_DEPLOYMENT","CALL_API","store","next","action","callAPI","types","getState","Error","Array","isArray","every","type","actionWith","data","finalAction","requestType","successType","failureType","error","message"],"sources":["C:/Users/sam/final/camunda-react/src/middleware/api.js"],"sourcesContent":["import { normalize, schema } from 'normalizr'\r\nimport { camelizeKeys } from 'humps'\r\n\r\nconst API_ROOT = '/engine-rest/'\r\n\r\n// Fetches an API response and normalizes the result JSON according to schema.\r\n// This makes every API response have the same shape, regardless of how nested it was.\r\nconst callApi = (endpoint, schema, settings = {}) => {\r\n  const fullUrl = (endpoint.indexOf(API_ROOT) === -1) ? API_ROOT + endpoint : endpoint\r\n\r\n  return fetch(fullUrl, settings)\r\n    .then(response =>\r\n      response.json().then(json => {\r\n        if (!response.ok) {\r\n          return Promise.reject(json)\r\n        }\r\n\r\n        const camelizedJson = camelizeKeys(json)\r\n          return Object.assign({},\r\n          normalize(camelizedJson, schema),\r\n          {  }\r\n        )\r\n      })\r\n    )\r\n}\r\n\r\n// We use this Normalizr schemas to transform API responses from a nested form\r\n// to a flat form where repos and users are placed in `entities`, and nested\r\n// JSON objects are replaced with their IDs. This is very convenient for\r\n// consumption by reducers, because we can easily build a normalized tree\r\n// and keep it updated as we fetch more data.\r\n\r\n// Read more about Normalizr: https://github.com/paularmstrong/normalizr\r\n\r\nconst processDefinitionSchema = new schema.Entity('processDefinition', {}, {\r\n  id: processDefinition => processDefinition.id,\r\n  name: processDefinition => processDefinition.name\r\n})\r\n\r\nconst processDefinitionXMLSchema = new schema.Entity('processDefinitionXML', {}, {\r\n\r\n});\r\n\r\nconst formKeySchema = new schema.Entity('formKey', {}, {\r\n  idAttribute: 'test',\r\n});\r\n\r\nconst processInstanceStartedSchema = new schema.Entity('processInstanceStarted', {}, {\r\n\r\n});\r\n\r\nconst taskSchema = new schema.Entity('task', {}, {\r\n  id: task => task.id,\r\n});\r\n\r\nconst taskVariableSchema = new schema.Entity('taskVariable', {}, {\r\n  processStrategy: (value, parent, key) => {\r\n    return {\r\n      values: value,\r\n      test: key,\r\n      parent: parent\r\n    }\r\n  }\r\n})\r\nconst taskVariableArraySchema = new schema.Entity('taskVariables', {}, {\r\n  idAttribute: variable => 'variables',\r\n  processStrategy: (value, parent, key) => {\r\n    let values = {};\r\n    Object.keys(value).forEach((item) => {\r\n      values[item] = value[item].value\r\n    })\r\n    return values\r\n  }\r\n})\r\n\r\nconst processDeploymentSchema = new schema.Entity('processDeployment', {}, {})\r\n\r\n// Schemas for Github API responses.\r\nexport const Schemas = {\r\n  PROCESS_DEFINITION: processDefinitionSchema,\r\n  PROCESS_DEFINITION_ARRAY: [processDefinitionSchema],\r\n  PROCESS_DEFINITION_XML: processDefinitionXMLSchema,\r\n  FORM_KEY: formKeySchema,\r\n  TASK: taskSchema,\r\n  TASK_ARRAY: [taskSchema],\r\n  PROCESS_INSTANCE_STARTED: processInstanceStartedSchema,\r\n  TASK_VARIABLE: taskVariableSchema,\r\n  TASK_VARIABLES: taskVariableArraySchema,\r\n  PROCESS_DEPLOYMENT: processDeploymentSchema\r\n}\r\n\r\n// Action key that carries API call info interpreted by this Redux middleware.\r\nexport const CALL_API = 'Call API'\r\n\r\n// A Redux middleware that interprets actions with CALL_API info specified.\r\n// Performs the call and promises when such actions are dispatched.\r\nexport default store => next => action => {\r\n  const callAPI = action[CALL_API]\r\n\r\n  if (typeof callAPI === 'undefined') {\r\n    return next(action)\r\n  }\r\n\r\n  let { endpoint } = callAPI\r\n  const { schema, types, settings } = callAPI\r\n\r\n  if (typeof endpoint === 'function') {\r\n    endpoint = endpoint(store.getState())\r\n  }\r\n\r\n  if (typeof endpoint !== 'string') {\r\n    throw new Error('Specify a string endpoint URL.')\r\n  }\r\n  if (!schema) {\r\n    throw new Error('Specify one of the exported Schemas.')\r\n  }\r\n  if (!Array.isArray(types) || types.length !== 3) {\r\n    throw new Error('Expected an array of three action types.')\r\n  }\r\n  if (!types.every(type => typeof type === 'string')) {\r\n    throw new Error('Expected action types to be strings.')\r\n  }\r\n\r\n  const actionWith = data => {\r\n    const finalAction = Object.assign({}, action, data)\r\n    delete finalAction[CALL_API]\r\n    return finalAction\r\n  }\r\n\r\n  const [ requestType, successType, failureType ] = types\r\n  next(actionWith({ type: requestType }))\r\n\r\n  return callApi(endpoint, schema, settings).then(\r\n    response => next(actionWith({\r\n      response,\r\n      type: successType\r\n    })),\r\n    error => next(actionWith({\r\n      type: failureType,\r\n      error: error.message || 'Something bad happened'\r\n    }))\r\n  )\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}