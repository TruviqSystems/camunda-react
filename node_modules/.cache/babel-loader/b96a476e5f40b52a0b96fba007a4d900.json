{"ast":null,"code":"import _has from \"lodash-es/has\";\nimport _keys from \"lodash-es/keys\";\nimport _forEach from \"lodash-es/forEach\";\nimport _filter from \"lodash-es/filter\";\nimport _keyBy from \"lodash-es/keyBy\";\nimport { Children, isValidElement } from 'react';\n/**\r\n * Given `this.props.children`, return an object mapping key to child.\r\n *\r\n * @param {object} children Element's children\r\n * @return {object} Mapping of key to child\r\n */\n\nexport var getChildMapping = function getChildMapping(children) {\n  return _keyBy(_filter(Children.toArray(children), isValidElement), 'key');\n};\nvar getPendingKeys = function getPendingKeys(prev, next) {\n  var nextKeysPending = {};\n  var pendingKeys = [];\n  _forEach(_keys(prev), function (prevKey) {\n    if (!_has(next, prevKey)) {\n      pendingKeys.push(prevKey);\n      return;\n    }\n    if (pendingKeys.length) {\n      nextKeysPending[prevKey] = pendingKeys;\n      pendingKeys = [];\n    }\n  });\n  return [nextKeysPending, pendingKeys];\n};\nvar getValue = function getValue(key, prev, next) {\n  return _has(next, key) ? next[key] : prev[key];\n};\n/**\r\n * When you're adding or removing children some may be added or removed in the same render pass. We want to show *both*\r\n * since we want to simultaneously animate elements in and out. This function takes a previous set of keys and a new set\r\n * of keys and merges them with its best guess of the correct ordering.\r\n *\r\n * @param {object} prev Prev children as returned from `getChildMapping()`\r\n * @param {object} next Next children as returned from `getChildMapping()`\r\n * @return {object} A key set that contains all keys in `prev` and all keys in `next` in a reasonable order\r\n */\n\nexport var mergeChildMappings = function mergeChildMappings(prev, next) {\n  if (prev === void 0) {\n    prev = {};\n  }\n  if (next === void 0) {\n    next = {};\n  }\n  var childMapping = {};\n  var _getPendingKeys = getPendingKeys(prev, next),\n    nextKeysPending = _getPendingKeys[0],\n    pendingKeys = _getPendingKeys[1];\n  _forEach(_keys(next), function (nextKey) {\n    if (_has(nextKeysPending, nextKey)) {\n      _forEach(nextKeysPending[nextKey], function (pendingKey) {\n        childMapping[pendingKey] = getValue(pendingKey, prev, next);\n      });\n    }\n    childMapping[nextKey] = getValue(nextKey, prev, next);\n  });\n  _forEach(pendingKeys, function (pendingKey) {\n    childMapping[pendingKey] = getValue(pendingKey, prev, next);\n  });\n  return childMapping;\n};","map":{"version":3,"names":["_has","_keys","_forEach","_filter","_keyBy","Children","isValidElement","getChildMapping","children","toArray","getPendingKeys","prev","next","nextKeysPending","pendingKeys","prevKey","push","length","getValue","key","mergeChildMappings","childMapping","_getPendingKeys","nextKey","pendingKey"],"sources":["C:/Users/sam/final/camunda-react/node_modules/semantic-ui-react/dist/es/modules/Transition/utils/childMapping.js"],"sourcesContent":["import _has from \"lodash-es/has\";\r\nimport _keys from \"lodash-es/keys\";\r\nimport _forEach from \"lodash-es/forEach\";\r\nimport _filter from \"lodash-es/filter\";\r\nimport _keyBy from \"lodash-es/keyBy\";\r\nimport { Children, isValidElement } from 'react';\r\n/**\r\n * Given `this.props.children`, return an object mapping key to child.\r\n *\r\n * @param {object} children Element's children\r\n * @return {object} Mapping of key to child\r\n */\r\n\r\nexport var getChildMapping = function getChildMapping(children) {\r\n  return _keyBy(_filter(Children.toArray(children), isValidElement), 'key');\r\n};\r\n\r\nvar getPendingKeys = function getPendingKeys(prev, next) {\r\n  var nextKeysPending = {};\r\n  var pendingKeys = [];\r\n\r\n  _forEach(_keys(prev), function (prevKey) {\r\n    if (!_has(next, prevKey)) {\r\n      pendingKeys.push(prevKey);\r\n      return;\r\n    }\r\n\r\n    if (pendingKeys.length) {\r\n      nextKeysPending[prevKey] = pendingKeys;\r\n      pendingKeys = [];\r\n    }\r\n  });\r\n\r\n  return [nextKeysPending, pendingKeys];\r\n};\r\n\r\nvar getValue = function getValue(key, prev, next) {\r\n  return _has(next, key) ? next[key] : prev[key];\r\n};\r\n/**\r\n * When you're adding or removing children some may be added or removed in the same render pass. We want to show *both*\r\n * since we want to simultaneously animate elements in and out. This function takes a previous set of keys and a new set\r\n * of keys and merges them with its best guess of the correct ordering.\r\n *\r\n * @param {object} prev Prev children as returned from `getChildMapping()`\r\n * @param {object} next Next children as returned from `getChildMapping()`\r\n * @return {object} A key set that contains all keys in `prev` and all keys in `next` in a reasonable order\r\n */\r\n\r\n\r\nexport var mergeChildMappings = function mergeChildMappings(prev, next) {\r\n  if (prev === void 0) {\r\n    prev = {};\r\n  }\r\n\r\n  if (next === void 0) {\r\n    next = {};\r\n  }\r\n\r\n  var childMapping = {};\r\n\r\n  var _getPendingKeys = getPendingKeys(prev, next),\r\n      nextKeysPending = _getPendingKeys[0],\r\n      pendingKeys = _getPendingKeys[1];\r\n\r\n  _forEach(_keys(next), function (nextKey) {\r\n    if (_has(nextKeysPending, nextKey)) {\r\n      _forEach(nextKeysPending[nextKey], function (pendingKey) {\r\n        childMapping[pendingKey] = getValue(pendingKey, prev, next);\r\n      });\r\n    }\r\n\r\n    childMapping[nextKey] = getValue(nextKey, prev, next);\r\n  });\r\n\r\n  _forEach(pendingKeys, function (pendingKey) {\r\n    childMapping[pendingKey] = getValue(pendingKey, prev, next);\r\n  });\r\n\r\n  return childMapping;\r\n};"],"mappings":"AAAA,OAAOA,IAAI,MAAM,eAAe;AAChC,OAAOC,KAAK,MAAM,gBAAgB;AAClC,OAAOC,QAAQ,MAAM,mBAAmB;AACxC,OAAOC,OAAO,MAAM,kBAAkB;AACtC,OAAOC,MAAM,MAAM,iBAAiB;AACpC,SAASC,QAAQ,EAAEC,cAAc,QAAQ,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAIC,eAAe,GAAG,SAASA,eAAeA,CAACC,QAAQ,EAAE;EAC9D,OAAOJ,MAAM,CAACD,OAAO,CAACE,QAAQ,CAACI,OAAO,CAACD,QAAQ,CAAC,EAAEF,cAAc,CAAC,EAAE,KAAK,CAAC;AAC3E,CAAC;AAED,IAAII,cAAc,GAAG,SAASA,cAAcA,CAACC,IAAI,EAAEC,IAAI,EAAE;EACvD,IAAIC,eAAe,GAAG,CAAC,CAAC;EACxB,IAAIC,WAAW,GAAG,EAAE;EAEpBZ,QAAQ,CAACD,KAAK,CAACU,IAAI,CAAC,EAAE,UAAUI,OAAO,EAAE;IACvC,IAAI,CAACf,IAAI,CAACY,IAAI,EAAEG,OAAO,CAAC,EAAE;MACxBD,WAAW,CAACE,IAAI,CAACD,OAAO,CAAC;MACzB;IACF;IAEA,IAAID,WAAW,CAACG,MAAM,EAAE;MACtBJ,eAAe,CAACE,OAAO,CAAC,GAAGD,WAAW;MACtCA,WAAW,GAAG,EAAE;IAClB;EACF,CAAC,CAAC;EAEF,OAAO,CAACD,eAAe,EAAEC,WAAW,CAAC;AACvC,CAAC;AAED,IAAII,QAAQ,GAAG,SAASA,QAAQA,CAACC,GAAG,EAAER,IAAI,EAAEC,IAAI,EAAE;EAChD,OAAOZ,IAAI,CAACY,IAAI,EAAEO,GAAG,CAAC,GAAGP,IAAI,CAACO,GAAG,CAAC,GAAGR,IAAI,CAACQ,GAAG,CAAC;AAChD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,OAAO,IAAIC,kBAAkB,GAAG,SAASA,kBAAkBA,CAACT,IAAI,EAAEC,IAAI,EAAE;EACtE,IAAID,IAAI,KAAK,KAAK,CAAC,EAAE;IACnBA,IAAI,GAAG,CAAC,CAAC;EACX;EAEA,IAAIC,IAAI,KAAK,KAAK,CAAC,EAAE;IACnBA,IAAI,GAAG,CAAC,CAAC;EACX;EAEA,IAAIS,YAAY,GAAG,CAAC,CAAC;EAErB,IAAIC,eAAe,GAAGZ,cAAc,CAACC,IAAI,EAAEC,IAAI,CAAC;IAC5CC,eAAe,GAAGS,eAAe,CAAC,CAAC,CAAC;IACpCR,WAAW,GAAGQ,eAAe,CAAC,CAAC,CAAC;EAEpCpB,QAAQ,CAACD,KAAK,CAACW,IAAI,CAAC,EAAE,UAAUW,OAAO,EAAE;IACvC,IAAIvB,IAAI,CAACa,eAAe,EAAEU,OAAO,CAAC,EAAE;MAClCrB,QAAQ,CAACW,eAAe,CAACU,OAAO,CAAC,EAAE,UAAUC,UAAU,EAAE;QACvDH,YAAY,CAACG,UAAU,CAAC,GAAGN,QAAQ,CAACM,UAAU,EAAEb,IAAI,EAAEC,IAAI,CAAC;MAC7D,CAAC,CAAC;IACJ;IAEAS,YAAY,CAACE,OAAO,CAAC,GAAGL,QAAQ,CAACK,OAAO,EAAEZ,IAAI,EAAEC,IAAI,CAAC;EACvD,CAAC,CAAC;EAEFV,QAAQ,CAACY,WAAW,EAAE,UAAUU,UAAU,EAAE;IAC1CH,YAAY,CAACG,UAAU,CAAC,GAAGN,QAAQ,CAACM,UAAU,EAAEb,IAAI,EAAEC,IAAI,CAAC;EAC7D,CAAC,CAAC;EAEF,OAAOS,YAAY;AACrB,CAAC"},"metadata":{},"sourceType":"module"}